{"ast":null,"code":"import { useState } from 'react';\nimport { SortDirection, strategies, DEFAULT_SORT_DIRECTION, transition } from './sorting.js';\nfunction useTable({\n  columns,\n  data,\n  initialSortColumn,\n  initialSortDirection\n}) {\n  const [rowOrder, setRowOrder] = useState(data);\n  const [prevData, setPrevData] = useState(data);\n  const [prevColumns, setPrevColumns] = useState(columns);\n  const [sortByColumn, setSortByColumn] = useState(() => {\n    return getInitialSortState(columns, initialSortColumn, initialSortDirection);\n  });\n  const {\n    gridTemplateColumns\n  } = useTableLayout(columns);\n\n  // Reset the `sortByColumn` state if the columns change and that column is no\n  // longer provided\n  if (columns !== prevColumns) {\n    setPrevColumns(columns);\n    if (sortByColumn) {\n      const column = columns.find(column => {\n        var _column$id;\n        const id = (_column$id = column.id) !== null && _column$id !== void 0 ? _column$id : column.field;\n        return sortByColumn.id === id;\n      });\n      if (!column) {\n        setSortByColumn(null);\n      }\n    }\n  }\n  const headers = columns.map(column => {\n    var _column$id2;\n    const id = (_column$id2 = column.id) !== null && _column$id2 !== void 0 ? _column$id2 : column.field;\n    if (id === undefined) {\n      throw new Error(`Expected either an \\`id\\` or \\`field\\` to be defined for a Column`);\n    }\n    const sortable = column.sortBy !== undefined && column.sortBy !== false;\n    return {\n      id,\n      column,\n      isSortable() {\n        return sortable;\n      },\n      getSortDirection() {\n        if (sortByColumn && sortByColumn.id === id) {\n          return sortByColumn.direction;\n        }\n        return SortDirection.NONE;\n      }\n    };\n  });\n\n  // Update the row order and apply the current sort column to the incoming data\n  if (data !== prevData) {\n    setPrevData(data);\n    setRowOrder(data);\n    if (sortByColumn) {\n      sortRows(sortByColumn);\n    }\n  }\n\n  /**\n   * Sort the input row data by the given header\n   */\n  function sortBy(header) {\n    const sortState = {\n      id: header.id,\n      direction: sortByColumn && sortByColumn.id === header.id ? transition(sortByColumn.direction) : DEFAULT_SORT_DIRECTION\n    };\n    setSortByColumn(sortState);\n    sortRows(sortState);\n  }\n\n  /**\n   * Sort the rows of a table with the given column sort state. If the data in the table is sparse,\n   * blank values will be ordered last regardless of the sort direction.\n   */\n  function sortRows(state) {\n    const header = headers.find(header => {\n      return header.id === state.id;\n    });\n    if (!header) {\n      throw new Error(`Unable to find header with id: ${state.id}`);\n    }\n    if (header.column.sortBy === false || header.column.sortBy === undefined) {\n      throw new Error(`The column for this header is not sortable`);\n    }\n    const sortMethod = header.column.sortBy === true ? strategies.basic : typeof header.column.sortBy === 'string' ? strategies[header.column.sortBy] : header.column.sortBy;\n    setRowOrder(rowOrder => {\n      return rowOrder.slice().sort((a, b) => {\n        if (header.column.field === undefined) {\n          return 0;\n        }\n\n        // Custom sort functions operate on the row versus the field\n        if (typeof header.column.sortBy === 'function') {\n          if (state.direction === SortDirection.ASC) {\n            // @ts-ignore todo\n            return sortMethod(a, b);\n          }\n          // @ts-ignore todo\n          return sortMethod(b, a);\n        }\n        const valueA = get(a, header.column.field);\n        const valueB = get(b, header.column.field);\n        if (valueA && valueB) {\n          if (state.direction === SortDirection.ASC) {\n            // @ts-ignore todo\n            return sortMethod(valueA, valueB);\n          }\n          // @ts-ignore todo\n          return sortMethod(valueB, valueA);\n        }\n        if (valueA) {\n          return -1;\n        }\n        if (valueB) {\n          return 1;\n        }\n        return 0;\n      });\n    });\n  }\n  return {\n    headers,\n    rows: rowOrder.map(row => {\n      return {\n        id: `${row.id}`,\n        getValue() {\n          return row;\n        },\n        getCells() {\n          return headers.map(header => {\n            var _header$column$rowHea;\n            return {\n              id: `${row.id}:${header.id}`,\n              column: header.column,\n              rowHeader: (_header$column$rowHea = header.column.rowHeader) !== null && _header$column$rowHea !== void 0 ? _header$column$rowHea : false,\n              getValue() {\n                if (header.column.field !== undefined) {\n                  return get(row, header.column.field);\n                }\n                throw new Error(`Unable to get value for column header ${header.id}`);\n              }\n            };\n          });\n        }\n      };\n    }),\n    actions: {\n      sortBy\n    },\n    gridTemplateColumns\n  };\n}\nfunction getInitialSortState(columns, initialSortColumn, initialSortDirection) {\n  if (initialSortColumn !== undefined) {\n    const column = columns.find(column => {\n      return column.id === initialSortColumn || column.field === initialSortColumn;\n    });\n    if (column === undefined) {\n      if (process.env.NODE_ENV !== \"production\") {\n        // eslint-disable-next-line no-console\n        console.warn(`Warning: Unable to find a column with id or field set to: ${initialSortColumn}. Please provide a value to \\`initialSortColumn\\` which corresponds to a \\`id\\` or \\`field\\` value in a column.`);\n      }\n      return null;\n    }\n    if (column.sortBy === false || column.sortBy === undefined) {\n      if (process.env.NODE_ENV !== \"production\") {\n        // eslint-disable-next-line no-console\n        console.warn(`Warning: The column specified by initialSortColumn={${initialSortColumn}} is not sortable. Please set \\`sortBy\\` to true or provide a sort strategy.`);\n      }\n      return null;\n    }\n    return {\n      id: `${initialSortColumn}`,\n      direction: initialSortDirection !== null && initialSortDirection !== void 0 ? initialSortDirection : DEFAULT_SORT_DIRECTION\n    };\n  }\n  if (initialSortDirection !== undefined) {\n    var _column$id3;\n    const column = columns.find(column => {\n      return column.sortBy !== false && column.sortBy !== undefined;\n    });\n    if (!column) {\n      if (process.env.NODE_ENV !== \"production\") {\n        // eslint-disable-next-line no-console\n        console.warn(`Warning: An initialSortDirection value was provided but no columns are sortable. Please set \\`sortBy\\` to true or provide a sort strategy to a column.`);\n      }\n      return null;\n    }\n    const id = (_column$id3 = column.id) !== null && _column$id3 !== void 0 ? _column$id3 : column.field;\n    if (id === undefined) {\n      if (process.env.NODE_ENV !== \"production\") {\n        // eslint-disable-next-line no-console\n        console.warn(`Warning: Unable to find an \\`id\\` or \\`field\\` for the column: ${column}. Please set one of these properties on the column.`);\n      }\n      return null;\n    }\n    return {\n      id,\n      direction: initialSortDirection\n    };\n  }\n  return null;\n}\nfunction useTableLayout(columns) {\n  return {\n    gridTemplateColumns: getGridTemplateFromColumns(columns).join(' ')\n  };\n}\nfunction getGridTemplateFromColumns(columns) {\n  return columns.map(column => {\n    var _column$width;\n    const columnWidth = (_column$width = column.width) !== null && _column$width !== void 0 ? _column$width : 'grow';\n    let minWidth = 'auto';\n    let maxWidth = '1fr';\n    if (columnWidth === 'auto') {\n      maxWidth = 'auto';\n    }\n\n    // Setting a min-width of 'max-content' ensures that the column will grow to fit the widest cell's content.\n    // However, If the column has a max width, we can't set the min width to `max-content` because\n    // the widest cell's content might overflow the container.\n    if (columnWidth === 'grow' && !column.maxWidth) {\n      minWidth = 'max-content';\n    }\n\n    // Column widths set to \"growCollapse\" don't need a min width unless one is explicitly provided.\n    if (columnWidth === 'growCollapse') {\n      minWidth = '0';\n    }\n\n    // If a consumer passes `minWidth` or `maxWidth`, we need to override whatever we set above.\n    if (column.minWidth) {\n      minWidth = typeof column.minWidth === 'number' ? `${column.minWidth}px` : column.minWidth;\n    }\n    if (column.maxWidth) {\n      maxWidth = typeof column.maxWidth === 'number' ? `${column.maxWidth}px` : column.maxWidth;\n    }\n\n    // If a consumer is passing one of the shorthand widths or doesn't pass a width at all, we use the\n    // min and max width calculated above to create a minmax() column template value.\n    if (typeof columnWidth !== 'number' && ['grow', 'growCollapse', 'auto'].includes(columnWidth)) {\n      return minWidth === maxWidth ? minWidth : `minmax(${minWidth}, ${maxWidth})`;\n    }\n\n    // If we reach this point, the consumer is passing an explicit width value.\n    return typeof columnWidth === 'number' ? `${columnWidth}px` : columnWidth;\n  });\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction get(object, path) {\n  return path.split('.').reduce((value, key) => {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return value[key];\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  }, object);\n}\nexport { getGridTemplateFromColumns, useTable, useTableLayout };","map":{"version":3,"names":["useState","SortDirection","strategies","DEFAULT_SORT_DIRECTION","transition","useTable","columns","data","initialSortColumn","initialSortDirection","rowOrder","setRowOrder","prevData","setPrevData","prevColumns","setPrevColumns","sortByColumn","setSortByColumn","getInitialSortState","gridTemplateColumns","useTableLayout","column","find","_column$id","id","field","headers","map","_column$id2","undefined","Error","sortable","sortBy","isSortable","getSortDirection","direction","NONE","sortRows","header","sortState","state","sortMethod","basic","slice","sort","a","b","ASC","valueA","get","valueB","rows","row","getValue","getCells","_header$column$rowHea","rowHeader","actions","process","env","NODE_ENV","console","warn","_column$id3","getGridTemplateFromColumns","join","_column$width","columnWidth","width","minWidth","maxWidth","includes","object","path","split","reduce","value","key"],"sources":["/Users/steve/Documents/repos/github/api-insights/node_modules/@primer/react/lib-esm/DataTable/useTable.js"],"sourcesContent":["import { useState } from 'react';\nimport { SortDirection, strategies, DEFAULT_SORT_DIRECTION, transition } from './sorting.js';\n\nfunction useTable({\n  columns,\n  data,\n  initialSortColumn,\n  initialSortDirection\n}) {\n  const [rowOrder, setRowOrder] = useState(data);\n  const [prevData, setPrevData] = useState(data);\n  const [prevColumns, setPrevColumns] = useState(columns);\n  const [sortByColumn, setSortByColumn] = useState(() => {\n    return getInitialSortState(columns, initialSortColumn, initialSortDirection);\n  });\n  const {\n    gridTemplateColumns\n  } = useTableLayout(columns);\n\n  // Reset the `sortByColumn` state if the columns change and that column is no\n  // longer provided\n  if (columns !== prevColumns) {\n    setPrevColumns(columns);\n    if (sortByColumn) {\n      const column = columns.find(column => {\n        var _column$id;\n        const id = (_column$id = column.id) !== null && _column$id !== void 0 ? _column$id : column.field;\n        return sortByColumn.id === id;\n      });\n      if (!column) {\n        setSortByColumn(null);\n      }\n    }\n  }\n  const headers = columns.map(column => {\n    var _column$id2;\n    const id = (_column$id2 = column.id) !== null && _column$id2 !== void 0 ? _column$id2 : column.field;\n    if (id === undefined) {\n      throw new Error(`Expected either an \\`id\\` or \\`field\\` to be defined for a Column`);\n    }\n    const sortable = column.sortBy !== undefined && column.sortBy !== false;\n    return {\n      id,\n      column,\n      isSortable() {\n        return sortable;\n      },\n      getSortDirection() {\n        if (sortByColumn && sortByColumn.id === id) {\n          return sortByColumn.direction;\n        }\n        return SortDirection.NONE;\n      }\n    };\n  });\n\n  // Update the row order and apply the current sort column to the incoming data\n  if (data !== prevData) {\n    setPrevData(data);\n    setRowOrder(data);\n    if (sortByColumn) {\n      sortRows(sortByColumn);\n    }\n  }\n\n  /**\n   * Sort the input row data by the given header\n   */\n  function sortBy(header) {\n    const sortState = {\n      id: header.id,\n      direction: sortByColumn && sortByColumn.id === header.id ? transition(sortByColumn.direction) : DEFAULT_SORT_DIRECTION\n    };\n    setSortByColumn(sortState);\n    sortRows(sortState);\n  }\n\n  /**\n   * Sort the rows of a table with the given column sort state. If the data in the table is sparse,\n   * blank values will be ordered last regardless of the sort direction.\n   */\n  function sortRows(state) {\n    const header = headers.find(header => {\n      return header.id === state.id;\n    });\n    if (!header) {\n      throw new Error(`Unable to find header with id: ${state.id}`);\n    }\n    if (header.column.sortBy === false || header.column.sortBy === undefined) {\n      throw new Error(`The column for this header is not sortable`);\n    }\n    const sortMethod = header.column.sortBy === true ? strategies.basic : typeof header.column.sortBy === 'string' ? strategies[header.column.sortBy] : header.column.sortBy;\n    setRowOrder(rowOrder => {\n      return rowOrder.slice().sort((a, b) => {\n        if (header.column.field === undefined) {\n          return 0;\n        }\n\n        // Custom sort functions operate on the row versus the field\n        if (typeof header.column.sortBy === 'function') {\n          if (state.direction === SortDirection.ASC) {\n            // @ts-ignore todo\n            return sortMethod(a, b);\n          }\n          // @ts-ignore todo\n          return sortMethod(b, a);\n        }\n        const valueA = get(a, header.column.field);\n        const valueB = get(b, header.column.field);\n        if (valueA && valueB) {\n          if (state.direction === SortDirection.ASC) {\n            // @ts-ignore todo\n            return sortMethod(valueA, valueB);\n          }\n          // @ts-ignore todo\n          return sortMethod(valueB, valueA);\n        }\n        if (valueA) {\n          return -1;\n        }\n        if (valueB) {\n          return 1;\n        }\n        return 0;\n      });\n    });\n  }\n  return {\n    headers,\n    rows: rowOrder.map(row => {\n      return {\n        id: `${row.id}`,\n        getValue() {\n          return row;\n        },\n        getCells() {\n          return headers.map(header => {\n            var _header$column$rowHea;\n            return {\n              id: `${row.id}:${header.id}`,\n              column: header.column,\n              rowHeader: (_header$column$rowHea = header.column.rowHeader) !== null && _header$column$rowHea !== void 0 ? _header$column$rowHea : false,\n              getValue() {\n                if (header.column.field !== undefined) {\n                  return get(row, header.column.field);\n                }\n                throw new Error(`Unable to get value for column header ${header.id}`);\n              }\n            };\n          });\n        }\n      };\n    }),\n    actions: {\n      sortBy\n    },\n    gridTemplateColumns\n  };\n}\nfunction getInitialSortState(columns, initialSortColumn, initialSortDirection) {\n  if (initialSortColumn !== undefined) {\n    const column = columns.find(column => {\n      return column.id === initialSortColumn || column.field === initialSortColumn;\n    });\n    if (column === undefined) {\n      if (process.env.NODE_ENV !== \"production\") {\n        // eslint-disable-next-line no-console\n        console.warn(`Warning: Unable to find a column with id or field set to: ${initialSortColumn}. Please provide a value to \\`initialSortColumn\\` which corresponds to a \\`id\\` or \\`field\\` value in a column.`);\n      }\n      return null;\n    }\n    if (column.sortBy === false || column.sortBy === undefined) {\n      if (process.env.NODE_ENV !== \"production\") {\n        // eslint-disable-next-line no-console\n        console.warn(`Warning: The column specified by initialSortColumn={${initialSortColumn}} is not sortable. Please set \\`sortBy\\` to true or provide a sort strategy.`);\n      }\n      return null;\n    }\n    return {\n      id: `${initialSortColumn}`,\n      direction: initialSortDirection !== null && initialSortDirection !== void 0 ? initialSortDirection : DEFAULT_SORT_DIRECTION\n    };\n  }\n  if (initialSortDirection !== undefined) {\n    var _column$id3;\n    const column = columns.find(column => {\n      return column.sortBy !== false && column.sortBy !== undefined;\n    });\n    if (!column) {\n      if (process.env.NODE_ENV !== \"production\") {\n        // eslint-disable-next-line no-console\n        console.warn(`Warning: An initialSortDirection value was provided but no columns are sortable. Please set \\`sortBy\\` to true or provide a sort strategy to a column.`);\n      }\n      return null;\n    }\n    const id = (_column$id3 = column.id) !== null && _column$id3 !== void 0 ? _column$id3 : column.field;\n    if (id === undefined) {\n      if (process.env.NODE_ENV !== \"production\") {\n        // eslint-disable-next-line no-console\n        console.warn(`Warning: Unable to find an \\`id\\` or \\`field\\` for the column: ${column}. Please set one of these properties on the column.`);\n      }\n      return null;\n    }\n    return {\n      id,\n      direction: initialSortDirection\n    };\n  }\n  return null;\n}\nfunction useTableLayout(columns) {\n  return {\n    gridTemplateColumns: getGridTemplateFromColumns(columns).join(' ')\n  };\n}\nfunction getGridTemplateFromColumns(columns) {\n  return columns.map(column => {\n    var _column$width;\n    const columnWidth = (_column$width = column.width) !== null && _column$width !== void 0 ? _column$width : 'grow';\n    let minWidth = 'auto';\n    let maxWidth = '1fr';\n    if (columnWidth === 'auto') {\n      maxWidth = 'auto';\n    }\n\n    // Setting a min-width of 'max-content' ensures that the column will grow to fit the widest cell's content.\n    // However, If the column has a max width, we can't set the min width to `max-content` because\n    // the widest cell's content might overflow the container.\n    if (columnWidth === 'grow' && !column.maxWidth) {\n      minWidth = 'max-content';\n    }\n\n    // Column widths set to \"growCollapse\" don't need a min width unless one is explicitly provided.\n    if (columnWidth === 'growCollapse') {\n      minWidth = '0';\n    }\n\n    // If a consumer passes `minWidth` or `maxWidth`, we need to override whatever we set above.\n    if (column.minWidth) {\n      minWidth = typeof column.minWidth === 'number' ? `${column.minWidth}px` : column.minWidth;\n    }\n    if (column.maxWidth) {\n      maxWidth = typeof column.maxWidth === 'number' ? `${column.maxWidth}px` : column.maxWidth;\n    }\n\n    // If a consumer is passing one of the shorthand widths or doesn't pass a width at all, we use the\n    // min and max width calculated above to create a minmax() column template value.\n    if (typeof columnWidth !== 'number' && ['grow', 'growCollapse', 'auto'].includes(columnWidth)) {\n      return minWidth === maxWidth ? minWidth : `minmax(${minWidth}, ${maxWidth})`;\n    }\n\n    // If we reach this point, the consumer is passing an explicit width value.\n    return typeof columnWidth === 'number' ? `${columnWidth}px` : columnWidth;\n  });\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction get(object, path) {\n  return path.split('.').reduce((value, key) => {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return value[key];\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  }, object);\n}\n\nexport { getGridTemplateFromColumns, useTable, useTableLayout };\n"],"mappings":"AAAA,SAASA,QAAQ,QAAQ,OAAO;AAChC,SAASC,aAAa,EAAEC,UAAU,EAAEC,sBAAsB,EAAEC,UAAU,QAAQ,cAAc;AAE5F,SAASC,QAAQA,CAAC;EAChBC,OAAO;EACPC,IAAI;EACJC,iBAAiB;EACjBC;AACF,CAAC,EAAE;EACD,MAAM,CAACC,QAAQ,EAAEC,WAAW,CAAC,GAAGX,QAAQ,CAACO,IAAI,CAAC;EAC9C,MAAM,CAACK,QAAQ,EAAEC,WAAW,CAAC,GAAGb,QAAQ,CAACO,IAAI,CAAC;EAC9C,MAAM,CAACO,WAAW,EAAEC,cAAc,CAAC,GAAGf,QAAQ,CAACM,OAAO,CAAC;EACvD,MAAM,CAACU,YAAY,EAAEC,eAAe,CAAC,GAAGjB,QAAQ,CAAC,MAAM;IACrD,OAAOkB,mBAAmB,CAACZ,OAAO,EAAEE,iBAAiB,EAAEC,oBAAoB,CAAC;EAC9E,CAAC,CAAC;EACF,MAAM;IACJU;EACF,CAAC,GAAGC,cAAc,CAACd,OAAO,CAAC;;EAE3B;EACA;EACA,IAAIA,OAAO,KAAKQ,WAAW,EAAE;IAC3BC,cAAc,CAACT,OAAO,CAAC;IACvB,IAAIU,YAAY,EAAE;MAChB,MAAMK,MAAM,GAAGf,OAAO,CAACgB,IAAI,CAACD,MAAM,IAAI;QACpC,IAAIE,UAAU;QACd,MAAMC,EAAE,GAAG,CAACD,UAAU,GAAGF,MAAM,CAACG,EAAE,MAAM,IAAI,IAAID,UAAU,KAAK,KAAK,CAAC,GAAGA,UAAU,GAAGF,MAAM,CAACI,KAAK;QACjG,OAAOT,YAAY,CAACQ,EAAE,KAAKA,EAAE;MAC/B,CAAC,CAAC;MACF,IAAI,CAACH,MAAM,EAAE;QACXJ,eAAe,CAAC,IAAI,CAAC;MACvB;IACF;EACF;EACA,MAAMS,OAAO,GAAGpB,OAAO,CAACqB,GAAG,CAACN,MAAM,IAAI;IACpC,IAAIO,WAAW;IACf,MAAMJ,EAAE,GAAG,CAACI,WAAW,GAAGP,MAAM,CAACG,EAAE,MAAM,IAAI,IAAII,WAAW,KAAK,KAAK,CAAC,GAAGA,WAAW,GAAGP,MAAM,CAACI,KAAK;IACpG,IAAID,EAAE,KAAKK,SAAS,EAAE;MACpB,MAAM,IAAIC,KAAK,CAAE,mEAAkE,CAAC;IACtF;IACA,MAAMC,QAAQ,GAAGV,MAAM,CAACW,MAAM,KAAKH,SAAS,IAAIR,MAAM,CAACW,MAAM,KAAK,KAAK;IACvE,OAAO;MACLR,EAAE;MACFH,MAAM;MACNY,UAAUA,CAAA,EAAG;QACX,OAAOF,QAAQ;MACjB,CAAC;MACDG,gBAAgBA,CAAA,EAAG;QACjB,IAAIlB,YAAY,IAAIA,YAAY,CAACQ,EAAE,KAAKA,EAAE,EAAE;UAC1C,OAAOR,YAAY,CAACmB,SAAS;QAC/B;QACA,OAAOlC,aAAa,CAACmC,IAAI;MAC3B;IACF,CAAC;EACH,CAAC,CAAC;;EAEF;EACA,IAAI7B,IAAI,KAAKK,QAAQ,EAAE;IACrBC,WAAW,CAACN,IAAI,CAAC;IACjBI,WAAW,CAACJ,IAAI,CAAC;IACjB,IAAIS,YAAY,EAAE;MAChBqB,QAAQ,CAACrB,YAAY,CAAC;IACxB;EACF;;EAEA;AACF;AACA;EACE,SAASgB,MAAMA,CAACM,MAAM,EAAE;IACtB,MAAMC,SAAS,GAAG;MAChBf,EAAE,EAAEc,MAAM,CAACd,EAAE;MACbW,SAAS,EAAEnB,YAAY,IAAIA,YAAY,CAACQ,EAAE,KAAKc,MAAM,CAACd,EAAE,GAAGpB,UAAU,CAACY,YAAY,CAACmB,SAAS,CAAC,GAAGhC;IAClG,CAAC;IACDc,eAAe,CAACsB,SAAS,CAAC;IAC1BF,QAAQ,CAACE,SAAS,CAAC;EACrB;;EAEA;AACF;AACA;AACA;EACE,SAASF,QAAQA,CAACG,KAAK,EAAE;IACvB,MAAMF,MAAM,GAAGZ,OAAO,CAACJ,IAAI,CAACgB,MAAM,IAAI;MACpC,OAAOA,MAAM,CAACd,EAAE,KAAKgB,KAAK,CAAChB,EAAE;IAC/B,CAAC,CAAC;IACF,IAAI,CAACc,MAAM,EAAE;MACX,MAAM,IAAIR,KAAK,CAAE,kCAAiCU,KAAK,CAAChB,EAAG,EAAC,CAAC;IAC/D;IACA,IAAIc,MAAM,CAACjB,MAAM,CAACW,MAAM,KAAK,KAAK,IAAIM,MAAM,CAACjB,MAAM,CAACW,MAAM,KAAKH,SAAS,EAAE;MACxE,MAAM,IAAIC,KAAK,CAAE,4CAA2C,CAAC;IAC/D;IACA,MAAMW,UAAU,GAAGH,MAAM,CAACjB,MAAM,CAACW,MAAM,KAAK,IAAI,GAAG9B,UAAU,CAACwC,KAAK,GAAG,OAAOJ,MAAM,CAACjB,MAAM,CAACW,MAAM,KAAK,QAAQ,GAAG9B,UAAU,CAACoC,MAAM,CAACjB,MAAM,CAACW,MAAM,CAAC,GAAGM,MAAM,CAACjB,MAAM,CAACW,MAAM;IACxKrB,WAAW,CAACD,QAAQ,IAAI;MACtB,OAAOA,QAAQ,CAACiC,KAAK,CAAC,CAAC,CAACC,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAK;QACrC,IAAIR,MAAM,CAACjB,MAAM,CAACI,KAAK,KAAKI,SAAS,EAAE;UACrC,OAAO,CAAC;QACV;;QAEA;QACA,IAAI,OAAOS,MAAM,CAACjB,MAAM,CAACW,MAAM,KAAK,UAAU,EAAE;UAC9C,IAAIQ,KAAK,CAACL,SAAS,KAAKlC,aAAa,CAAC8C,GAAG,EAAE;YACzC;YACA,OAAON,UAAU,CAACI,CAAC,EAAEC,CAAC,CAAC;UACzB;UACA;UACA,OAAOL,UAAU,CAACK,CAAC,EAAED,CAAC,CAAC;QACzB;QACA,MAAMG,MAAM,GAAGC,GAAG,CAACJ,CAAC,EAAEP,MAAM,CAACjB,MAAM,CAACI,KAAK,CAAC;QAC1C,MAAMyB,MAAM,GAAGD,GAAG,CAACH,CAAC,EAAER,MAAM,CAACjB,MAAM,CAACI,KAAK,CAAC;QAC1C,IAAIuB,MAAM,IAAIE,MAAM,EAAE;UACpB,IAAIV,KAAK,CAACL,SAAS,KAAKlC,aAAa,CAAC8C,GAAG,EAAE;YACzC;YACA,OAAON,UAAU,CAACO,MAAM,EAAEE,MAAM,CAAC;UACnC;UACA;UACA,OAAOT,UAAU,CAACS,MAAM,EAAEF,MAAM,CAAC;QACnC;QACA,IAAIA,MAAM,EAAE;UACV,OAAO,CAAC,CAAC;QACX;QACA,IAAIE,MAAM,EAAE;UACV,OAAO,CAAC;QACV;QACA,OAAO,CAAC;MACV,CAAC,CAAC;IACJ,CAAC,CAAC;EACJ;EACA,OAAO;IACLxB,OAAO;IACPyB,IAAI,EAAEzC,QAAQ,CAACiB,GAAG,CAACyB,GAAG,IAAI;MACxB,OAAO;QACL5B,EAAE,EAAG,GAAE4B,GAAG,CAAC5B,EAAG,EAAC;QACf6B,QAAQA,CAAA,EAAG;UACT,OAAOD,GAAG;QACZ,CAAC;QACDE,QAAQA,CAAA,EAAG;UACT,OAAO5B,OAAO,CAACC,GAAG,CAACW,MAAM,IAAI;YAC3B,IAAIiB,qBAAqB;YACzB,OAAO;cACL/B,EAAE,EAAG,GAAE4B,GAAG,CAAC5B,EAAG,IAAGc,MAAM,CAACd,EAAG,EAAC;cAC5BH,MAAM,EAAEiB,MAAM,CAACjB,MAAM;cACrBmC,SAAS,EAAE,CAACD,qBAAqB,GAAGjB,MAAM,CAACjB,MAAM,CAACmC,SAAS,MAAM,IAAI,IAAID,qBAAqB,KAAK,KAAK,CAAC,GAAGA,qBAAqB,GAAG,KAAK;cACzIF,QAAQA,CAAA,EAAG;gBACT,IAAIf,MAAM,CAACjB,MAAM,CAACI,KAAK,KAAKI,SAAS,EAAE;kBACrC,OAAOoB,GAAG,CAACG,GAAG,EAAEd,MAAM,CAACjB,MAAM,CAACI,KAAK,CAAC;gBACtC;gBACA,MAAM,IAAIK,KAAK,CAAE,yCAAwCQ,MAAM,CAACd,EAAG,EAAC,CAAC;cACvE;YACF,CAAC;UACH,CAAC,CAAC;QACJ;MACF,CAAC;IACH,CAAC,CAAC;IACFiC,OAAO,EAAE;MACPzB;IACF,CAAC;IACDb;EACF,CAAC;AACH;AACA,SAASD,mBAAmBA,CAACZ,OAAO,EAAEE,iBAAiB,EAAEC,oBAAoB,EAAE;EAC7E,IAAID,iBAAiB,KAAKqB,SAAS,EAAE;IACnC,MAAMR,MAAM,GAAGf,OAAO,CAACgB,IAAI,CAACD,MAAM,IAAI;MACpC,OAAOA,MAAM,CAACG,EAAE,KAAKhB,iBAAiB,IAAIa,MAAM,CAACI,KAAK,KAAKjB,iBAAiB;IAC9E,CAAC,CAAC;IACF,IAAIa,MAAM,KAAKQ,SAAS,EAAE;MACxB,IAAI6B,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;QACzC;QACAC,OAAO,CAACC,IAAI,CAAE,6DAA4DtD,iBAAkB,iHAAgH,CAAC;MAC/M;MACA,OAAO,IAAI;IACb;IACA,IAAIa,MAAM,CAACW,MAAM,KAAK,KAAK,IAAIX,MAAM,CAACW,MAAM,KAAKH,SAAS,EAAE;MAC1D,IAAI6B,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;QACzC;QACAC,OAAO,CAACC,IAAI,CAAE,uDAAsDtD,iBAAkB,8EAA6E,CAAC;MACtK;MACA,OAAO,IAAI;IACb;IACA,OAAO;MACLgB,EAAE,EAAG,GAAEhB,iBAAkB,EAAC;MAC1B2B,SAAS,EAAE1B,oBAAoB,KAAK,IAAI,IAAIA,oBAAoB,KAAK,KAAK,CAAC,GAAGA,oBAAoB,GAAGN;IACvG,CAAC;EACH;EACA,IAAIM,oBAAoB,KAAKoB,SAAS,EAAE;IACtC,IAAIkC,WAAW;IACf,MAAM1C,MAAM,GAAGf,OAAO,CAACgB,IAAI,CAACD,MAAM,IAAI;MACpC,OAAOA,MAAM,CAACW,MAAM,KAAK,KAAK,IAAIX,MAAM,CAACW,MAAM,KAAKH,SAAS;IAC/D,CAAC,CAAC;IACF,IAAI,CAACR,MAAM,EAAE;MACX,IAAIqC,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;QACzC;QACAC,OAAO,CAACC,IAAI,CAAE,wJAAuJ,CAAC;MACxK;MACA,OAAO,IAAI;IACb;IACA,MAAMtC,EAAE,GAAG,CAACuC,WAAW,GAAG1C,MAAM,CAACG,EAAE,MAAM,IAAI,IAAIuC,WAAW,KAAK,KAAK,CAAC,GAAGA,WAAW,GAAG1C,MAAM,CAACI,KAAK;IACpG,IAAID,EAAE,KAAKK,SAAS,EAAE;MACpB,IAAI6B,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;QACzC;QACAC,OAAO,CAACC,IAAI,CAAE,kEAAiEzC,MAAO,qDAAoD,CAAC;MAC7I;MACA,OAAO,IAAI;IACb;IACA,OAAO;MACLG,EAAE;MACFW,SAAS,EAAE1B;IACb,CAAC;EACH;EACA,OAAO,IAAI;AACb;AACA,SAASW,cAAcA,CAACd,OAAO,EAAE;EAC/B,OAAO;IACLa,mBAAmB,EAAE6C,0BAA0B,CAAC1D,OAAO,CAAC,CAAC2D,IAAI,CAAC,GAAG;EACnE,CAAC;AACH;AACA,SAASD,0BAA0BA,CAAC1D,OAAO,EAAE;EAC3C,OAAOA,OAAO,CAACqB,GAAG,CAACN,MAAM,IAAI;IAC3B,IAAI6C,aAAa;IACjB,MAAMC,WAAW,GAAG,CAACD,aAAa,GAAG7C,MAAM,CAAC+C,KAAK,MAAM,IAAI,IAAIF,aAAa,KAAK,KAAK,CAAC,GAAGA,aAAa,GAAG,MAAM;IAChH,IAAIG,QAAQ,GAAG,MAAM;IACrB,IAAIC,QAAQ,GAAG,KAAK;IACpB,IAAIH,WAAW,KAAK,MAAM,EAAE;MAC1BG,QAAQ,GAAG,MAAM;IACnB;;IAEA;IACA;IACA;IACA,IAAIH,WAAW,KAAK,MAAM,IAAI,CAAC9C,MAAM,CAACiD,QAAQ,EAAE;MAC9CD,QAAQ,GAAG,aAAa;IAC1B;;IAEA;IACA,IAAIF,WAAW,KAAK,cAAc,EAAE;MAClCE,QAAQ,GAAG,GAAG;IAChB;;IAEA;IACA,IAAIhD,MAAM,CAACgD,QAAQ,EAAE;MACnBA,QAAQ,GAAG,OAAOhD,MAAM,CAACgD,QAAQ,KAAK,QAAQ,GAAI,GAAEhD,MAAM,CAACgD,QAAS,IAAG,GAAGhD,MAAM,CAACgD,QAAQ;IAC3F;IACA,IAAIhD,MAAM,CAACiD,QAAQ,EAAE;MACnBA,QAAQ,GAAG,OAAOjD,MAAM,CAACiD,QAAQ,KAAK,QAAQ,GAAI,GAAEjD,MAAM,CAACiD,QAAS,IAAG,GAAGjD,MAAM,CAACiD,QAAQ;IAC3F;;IAEA;IACA;IACA,IAAI,OAAOH,WAAW,KAAK,QAAQ,IAAI,CAAC,MAAM,EAAE,cAAc,EAAE,MAAM,CAAC,CAACI,QAAQ,CAACJ,WAAW,CAAC,EAAE;MAC7F,OAAOE,QAAQ,KAAKC,QAAQ,GAAGD,QAAQ,GAAI,UAASA,QAAS,KAAIC,QAAS,GAAE;IAC9E;;IAEA;IACA,OAAO,OAAOH,WAAW,KAAK,QAAQ,GAAI,GAAEA,WAAY,IAAG,GAAGA,WAAW;EAC3E,CAAC,CAAC;AACJ;;AAEA;AACA,SAASlB,GAAGA,CAACuB,MAAM,EAAEC,IAAI,EAAE;EACzB,OAAOA,IAAI,CAACC,KAAK,CAAC,GAAG,CAAC,CAACC,MAAM,CAAC,CAACC,KAAK,EAAEC,GAAG,KAAK;IAC5C;IACA,OAAOD,KAAK,CAACC,GAAG,CAAC;IACjB;EACF,CAAC,EAAEL,MAAM,CAAC;AACZ;AAEA,SAASR,0BAA0B,EAAE3D,QAAQ,EAAEe,cAAc"},"metadata":{},"sourceType":"module","externalDependencies":[]}