{"ast":null,"code":"import { isMacOS } from '@primer/behaviors/utils';\nconst getSelectedLineRange = textarea => {\n  // Subtract one from the caret position so the newline found is not the one _at_ the caret position\n  // then add one because we don't want to include the found newline. Also changes -1 (not found) result to 0\n  const start = textarea.value.lastIndexOf('\\n', textarea.selectionStart - 1) + 1;\n\n  // activeLineEnd will be the index of the next newline inclusive, which works because slice is last-index exclusive\n  let end = textarea.value.indexOf('\\n', textarea.selectionEnd);\n  if (end === -1) end = textarea.value.length;\n  return [start, end];\n};\nconst markdownComment = text => `<!-- ${text.replaceAll('--', '\\\\-\\\\-')} -->`;\nconst markdownLink = (text, url) => `[${text.replaceAll('[', '\\\\[').replaceAll(']', '\\\\]')}](${url.replaceAll('(', '\\\\(').replaceAll(')', '\\\\)')})`;\nconst markdownImage = (altText, url) => `!${markdownLink(altText, url)}`;\nconst isModifierKey = event => isMacOS() ? event.metaKey : event.ctrlKey;\nexport { getSelectedLineRange, isModifierKey, markdownComment, markdownImage, markdownLink };","map":{"version":3,"names":["isMacOS","getSelectedLineRange","textarea","start","value","lastIndexOf","selectionStart","end","indexOf","selectionEnd","length","markdownComment","text","replaceAll","markdownLink","url","markdownImage","altText","isModifierKey","event","metaKey","ctrlKey"],"sources":["/Users/steve/Documents/repos/github/api-insights/node_modules/@primer/react/lib-esm/drafts/MarkdownEditor/utils.js"],"sourcesContent":["import { isMacOS } from '@primer/behaviors/utils';\n\nconst getSelectedLineRange = textarea => {\n  // Subtract one from the caret position so the newline found is not the one _at_ the caret position\n  // then add one because we don't want to include the found newline. Also changes -1 (not found) result to 0\n  const start = textarea.value.lastIndexOf('\\n', textarea.selectionStart - 1) + 1;\n\n  // activeLineEnd will be the index of the next newline inclusive, which works because slice is last-index exclusive\n  let end = textarea.value.indexOf('\\n', textarea.selectionEnd);\n  if (end === -1) end = textarea.value.length;\n  return [start, end];\n};\nconst markdownComment = text => `<!-- ${text.replaceAll('--', '\\\\-\\\\-')} -->`;\nconst markdownLink = (text, url) => `[${text.replaceAll('[', '\\\\[').replaceAll(']', '\\\\]')}](${url.replaceAll('(', '\\\\(').replaceAll(')', '\\\\)')})`;\nconst markdownImage = (altText, url) => `!${markdownLink(altText, url)}`;\nconst isModifierKey = event => isMacOS() ? event.metaKey : event.ctrlKey;\n\nexport { getSelectedLineRange, isModifierKey, markdownComment, markdownImage, markdownLink };\n"],"mappings":"AAAA,SAASA,OAAO,QAAQ,yBAAyB;AAEjD,MAAMC,oBAAoB,GAAGC,QAAQ,IAAI;EACvC;EACA;EACA,MAAMC,KAAK,GAAGD,QAAQ,CAACE,KAAK,CAACC,WAAW,CAAC,IAAI,EAAEH,QAAQ,CAACI,cAAc,GAAG,CAAC,CAAC,GAAG,CAAC;;EAE/E;EACA,IAAIC,GAAG,GAAGL,QAAQ,CAACE,KAAK,CAACI,OAAO,CAAC,IAAI,EAAEN,QAAQ,CAACO,YAAY,CAAC;EAC7D,IAAIF,GAAG,KAAK,CAAC,CAAC,EAAEA,GAAG,GAAGL,QAAQ,CAACE,KAAK,CAACM,MAAM;EAC3C,OAAO,CAACP,KAAK,EAAEI,GAAG,CAAC;AACrB,CAAC;AACD,MAAMI,eAAe,GAAGC,IAAI,IAAK,QAAOA,IAAI,CAACC,UAAU,CAAC,IAAI,EAAE,QAAQ,CAAE,MAAK;AAC7E,MAAMC,YAAY,GAAGA,CAACF,IAAI,EAAEG,GAAG,KAAM,IAAGH,IAAI,CAACC,UAAU,CAAC,GAAG,EAAE,KAAK,CAAC,CAACA,UAAU,CAAC,GAAG,EAAE,KAAK,CAAE,KAAIE,GAAG,CAACF,UAAU,CAAC,GAAG,EAAE,KAAK,CAAC,CAACA,UAAU,CAAC,GAAG,EAAE,KAAK,CAAE,GAAE;AACnJ,MAAMG,aAAa,GAAGA,CAACC,OAAO,EAAEF,GAAG,KAAM,IAAGD,YAAY,CAACG,OAAO,EAAEF,GAAG,CAAE,EAAC;AACxE,MAAMG,aAAa,GAAGC,KAAK,IAAInB,OAAO,CAAC,CAAC,GAAGmB,KAAK,CAACC,OAAO,GAAGD,KAAK,CAACE,OAAO;AAExE,SAASpB,oBAAoB,EAAEiB,aAAa,EAAEP,eAAe,EAAEK,aAAa,EAAEF,YAAY"},"metadata":{},"sourceType":"module","externalDependencies":[]}