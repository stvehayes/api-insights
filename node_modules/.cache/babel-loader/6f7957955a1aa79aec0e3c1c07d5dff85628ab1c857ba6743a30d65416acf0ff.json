{"ast":null,"code":"const alternateOrders = {\n  'outside-top': ['outside-bottom', 'outside-right', 'outside-left', 'outside-bottom'],\n  'outside-bottom': ['outside-top', 'outside-right', 'outside-left', 'outside-bottom'],\n  'outside-left': ['outside-right', 'outside-bottom', 'outside-top', 'outside-bottom'],\n  'outside-right': ['outside-left', 'outside-bottom', 'outside-top', 'outside-bottom']\n};\nconst alternateAlignments = {\n  start: ['end', 'center'],\n  end: ['start', 'center'],\n  center: ['end', 'start']\n};\nexport function getAnchoredPosition(floatingElement, anchorElement, settings = {}) {\n  const parentElement = getPositionedParent(floatingElement);\n  const clippingRect = getClippingRect(parentElement);\n  const parentElementStyle = getComputedStyle(parentElement);\n  const parentElementRect = parentElement.getBoundingClientRect();\n  const [borderTop, borderLeft] = [parentElementStyle.borderTopWidth, parentElementStyle.borderLeftWidth].map(v => parseInt(v, 10) || 0);\n  const relativeRect = {\n    top: parentElementRect.top + borderTop,\n    left: parentElementRect.left + borderLeft\n  };\n  return pureCalculateAnchoredPosition(clippingRect, relativeRect, floatingElement.getBoundingClientRect(), anchorElement instanceof Element ? anchorElement.getBoundingClientRect() : anchorElement, getDefaultSettings(settings));\n}\nfunction getPositionedParent(element) {\n  if (isOnTopLayer(element)) return document.body;\n  let parentNode = element.parentNode;\n  while (parentNode !== null) {\n    if (parentNode instanceof HTMLElement && getComputedStyle(parentNode).position !== 'static') {\n      return parentNode;\n    }\n    parentNode = parentNode.parentNode;\n  }\n  return document.body;\n}\nfunction isOnTopLayer(element) {\n  var _a;\n  if (element.tagName === 'DIALOG') {\n    return true;\n  }\n  try {\n    if (element.matches(':popover-open') && /native code/.test((_a = document.body.showPopover) === null || _a === void 0 ? void 0 : _a.toString())) {\n      return true;\n    }\n  } catch (_b) {\n    return false;\n  }\n  return false;\n}\nfunction getClippingRect(element) {\n  let parentNode = element;\n  while (parentNode !== null) {\n    if (!(parentNode instanceof Element)) {\n      break;\n    }\n    const parentNodeStyle = getComputedStyle(parentNode);\n    if (parentNodeStyle.overflow !== 'visible') {\n      break;\n    }\n    parentNode = parentNode.parentNode;\n  }\n  const clippingNode = parentNode === document.body || !(parentNode instanceof HTMLElement) ? document.body : parentNode;\n  const elemRect = clippingNode.getBoundingClientRect();\n  const elemStyle = getComputedStyle(clippingNode);\n  const [borderTop, borderLeft, borderRight, borderBottom] = [elemStyle.borderTopWidth, elemStyle.borderLeftWidth, elemStyle.borderRightWidth, elemStyle.borderBottomWidth].map(v => parseInt(v, 10) || 0);\n  return {\n    top: elemRect.top + borderTop,\n    left: elemRect.left + borderLeft,\n    width: elemRect.width - borderRight - borderLeft,\n    height: Math.max(elemRect.height - borderTop - borderBottom, clippingNode === document.body ? window.innerHeight : -Infinity)\n  };\n}\nconst positionDefaults = {\n  side: 'outside-bottom',\n  align: 'start',\n  anchorOffset: 4,\n  alignmentOffset: 4,\n  allowOutOfBounds: false\n};\nfunction getDefaultSettings(settings = {}) {\n  var _a, _b, _c, _d, _e;\n  const side = (_a = settings.side) !== null && _a !== void 0 ? _a : positionDefaults.side;\n  const align = (_b = settings.align) !== null && _b !== void 0 ? _b : positionDefaults.align;\n  return {\n    side,\n    align,\n    anchorOffset: (_c = settings.anchorOffset) !== null && _c !== void 0 ? _c : side === 'inside-center' ? 0 : positionDefaults.anchorOffset,\n    alignmentOffset: (_d = settings.alignmentOffset) !== null && _d !== void 0 ? _d : align !== 'center' && side.startsWith('inside') ? positionDefaults.alignmentOffset : 0,\n    allowOutOfBounds: (_e = settings.allowOutOfBounds) !== null && _e !== void 0 ? _e : positionDefaults.allowOutOfBounds\n  };\n}\nfunction pureCalculateAnchoredPosition(viewportRect, relativePosition, floatingRect, anchorRect, {\n  side,\n  align,\n  allowOutOfBounds,\n  anchorOffset,\n  alignmentOffset\n}) {\n  const relativeViewportRect = {\n    top: viewportRect.top - relativePosition.top,\n    left: viewportRect.left - relativePosition.left,\n    width: viewportRect.width,\n    height: viewportRect.height\n  };\n  let pos = calculatePosition(floatingRect, anchorRect, side, align, anchorOffset, alignmentOffset);\n  let anchorSide = side;\n  let anchorAlign = align;\n  pos.top -= relativePosition.top;\n  pos.left -= relativePosition.left;\n  if (!allowOutOfBounds) {\n    const alternateOrder = alternateOrders[side];\n    let positionAttempt = 0;\n    if (alternateOrder) {\n      let prevSide = side;\n      while (positionAttempt < alternateOrder.length && shouldRecalculatePosition(prevSide, pos, relativeViewportRect, floatingRect)) {\n        const nextSide = alternateOrder[positionAttempt++];\n        prevSide = nextSide;\n        pos = calculatePosition(floatingRect, anchorRect, nextSide, align, anchorOffset, alignmentOffset);\n        pos.top -= relativePosition.top;\n        pos.left -= relativePosition.left;\n        anchorSide = nextSide;\n      }\n    }\n    const alternateAlignment = alternateAlignments[align];\n    let alignmentAttempt = 0;\n    if (alternateAlignment) {\n      let prevAlign = align;\n      while (alignmentAttempt < alternateAlignment.length && shouldRecalculateAlignment(prevAlign, pos, relativeViewportRect, floatingRect)) {\n        const nextAlign = alternateAlignment[alignmentAttempt++];\n        prevAlign = nextAlign;\n        pos = calculatePosition(floatingRect, anchorRect, anchorSide, nextAlign, anchorOffset, alignmentOffset);\n        pos.top -= relativePosition.top;\n        pos.left -= relativePosition.left;\n        anchorAlign = nextAlign;\n      }\n    }\n    if (pos.top < relativeViewportRect.top) {\n      pos.top = relativeViewportRect.top;\n    }\n    if (pos.left < relativeViewportRect.left) {\n      pos.left = relativeViewportRect.left;\n    }\n    if (pos.left + floatingRect.width > viewportRect.width + relativeViewportRect.left) {\n      pos.left = viewportRect.width + relativeViewportRect.left - floatingRect.width;\n    }\n    if (alternateOrder && positionAttempt < alternateOrder.length) {\n      if (pos.top + floatingRect.height > viewportRect.height + relativeViewportRect.top) {\n        pos.top = Math.max(viewportRect.height + relativeViewportRect.top - floatingRect.height, 0);\n      }\n    }\n  }\n  return Object.assign(Object.assign({}, pos), {\n    anchorSide,\n    anchorAlign\n  });\n}\nfunction calculatePosition(elementDimensions, anchorPosition, side, align, anchorOffset, alignmentOffset) {\n  const anchorRight = anchorPosition.left + anchorPosition.width;\n  const anchorBottom = anchorPosition.top + anchorPosition.height;\n  let top = -1;\n  let left = -1;\n  if (side === 'outside-top') {\n    top = anchorPosition.top - anchorOffset - elementDimensions.height;\n  } else if (side === 'outside-bottom') {\n    top = anchorBottom + anchorOffset;\n  } else if (side === 'outside-left') {\n    left = anchorPosition.left - anchorOffset - elementDimensions.width;\n  } else if (side === 'outside-right') {\n    left = anchorRight + anchorOffset;\n  }\n  if (side === 'outside-top' || side === 'outside-bottom') {\n    if (align === 'start') {\n      left = anchorPosition.left + alignmentOffset;\n    } else if (align === 'center') {\n      left = anchorPosition.left - (elementDimensions.width - anchorPosition.width) / 2 + alignmentOffset;\n    } else {\n      left = anchorRight - elementDimensions.width - alignmentOffset;\n    }\n  }\n  if (side === 'outside-left' || side === 'outside-right') {\n    if (align === 'start') {\n      top = anchorPosition.top + alignmentOffset;\n    } else if (align === 'center') {\n      top = anchorPosition.top - (elementDimensions.height - anchorPosition.height) / 2 + alignmentOffset;\n    } else {\n      top = anchorBottom - elementDimensions.height - alignmentOffset;\n    }\n  }\n  if (side === 'inside-top') {\n    top = anchorPosition.top + anchorOffset;\n  } else if (side === 'inside-bottom') {\n    top = anchorBottom - anchorOffset - elementDimensions.height;\n  } else if (side === 'inside-left') {\n    left = anchorPosition.left + anchorOffset;\n  } else if (side === 'inside-right') {\n    left = anchorRight - anchorOffset - elementDimensions.width;\n  } else if (side === 'inside-center') {\n    left = (anchorRight + anchorPosition.left) / 2 - elementDimensions.width / 2 + anchorOffset;\n  }\n  if (side === 'inside-top' || side === 'inside-bottom') {\n    if (align === 'start') {\n      left = anchorPosition.left + alignmentOffset;\n    } else if (align === 'center') {\n      left = anchorPosition.left - (elementDimensions.width - anchorPosition.width) / 2 + alignmentOffset;\n    } else {\n      left = anchorRight - elementDimensions.width - alignmentOffset;\n    }\n  } else if (side === 'inside-left' || side === 'inside-right' || side === 'inside-center') {\n    if (align === 'start') {\n      top = anchorPosition.top + alignmentOffset;\n    } else if (align === 'center') {\n      top = anchorPosition.top - (elementDimensions.height - anchorPosition.height) / 2 + alignmentOffset;\n    } else {\n      top = anchorBottom - elementDimensions.height - alignmentOffset;\n    }\n  }\n  return {\n    top,\n    left\n  };\n}\nfunction shouldRecalculatePosition(side, currentPos, containerDimensions, elementDimensions) {\n  if (side === 'outside-top' || side === 'outside-bottom') {\n    return currentPos.top < containerDimensions.top || currentPos.top + elementDimensions.height > containerDimensions.height + containerDimensions.top;\n  } else {\n    return currentPos.left < containerDimensions.left || currentPos.left + elementDimensions.width > containerDimensions.width + containerDimensions.left;\n  }\n}\nfunction shouldRecalculateAlignment(align, currentPos, containerDimensions, elementDimensions) {\n  if (align === 'end') {\n    return currentPos.left < containerDimensions.left;\n  } else if (align === 'start' || align === 'center') {\n    return currentPos.left + elementDimensions.width > containerDimensions.left + containerDimensions.width || currentPos.left < containerDimensions.left;\n  }\n}","map":{"version":3,"names":["alternateOrders","alternateAlignments","start","end","center","getAnchoredPosition","floatingElement","anchorElement","settings","parentElement","getPositionedParent","clippingRect","getClippingRect","parentElementStyle","getComputedStyle","parentElementRect","getBoundingClientRect","borderTop","borderLeft","borderTopWidth","borderLeftWidth","map","v","parseInt","relativeRect","top","left","pureCalculateAnchoredPosition","Element","getDefaultSettings","element","isOnTopLayer","document","body","parentNode","HTMLElement","position","_a","tagName","matches","test","showPopover","toString","_b","parentNodeStyle","overflow","clippingNode","elemRect","elemStyle","borderRight","borderBottom","borderRightWidth","borderBottomWidth","width","height","Math","max","window","innerHeight","Infinity","positionDefaults","side","align","anchorOffset","alignmentOffset","allowOutOfBounds","_c","_d","_e","startsWith","viewportRect","relativePosition","floatingRect","anchorRect","relativeViewportRect","pos","calculatePosition","anchorSide","anchorAlign","alternateOrder","positionAttempt","prevSide","length","shouldRecalculatePosition","nextSide","alternateAlignment","alignmentAttempt","prevAlign","shouldRecalculateAlignment","nextAlign","Object","assign","elementDimensions","anchorPosition","anchorRight","anchorBottom","currentPos","containerDimensions"],"sources":["/Users/steve/Documents/repos/github/licensing/node_modules/@primer/behaviors/dist/esm/anchored-position.js"],"sourcesContent":["const alternateOrders = {\n    'outside-top': ['outside-bottom', 'outside-right', 'outside-left', 'outside-bottom'],\n    'outside-bottom': ['outside-top', 'outside-right', 'outside-left', 'outside-bottom'],\n    'outside-left': ['outside-right', 'outside-bottom', 'outside-top', 'outside-bottom'],\n    'outside-right': ['outside-left', 'outside-bottom', 'outside-top', 'outside-bottom'],\n};\nconst alternateAlignments = {\n    start: ['end', 'center'],\n    end: ['start', 'center'],\n    center: ['end', 'start'],\n};\nexport function getAnchoredPosition(floatingElement, anchorElement, settings = {}) {\n    const parentElement = getPositionedParent(floatingElement);\n    const clippingRect = getClippingRect(parentElement);\n    const parentElementStyle = getComputedStyle(parentElement);\n    const parentElementRect = parentElement.getBoundingClientRect();\n    const [borderTop, borderLeft] = [parentElementStyle.borderTopWidth, parentElementStyle.borderLeftWidth].map(v => parseInt(v, 10) || 0);\n    const relativeRect = {\n        top: parentElementRect.top + borderTop,\n        left: parentElementRect.left + borderLeft,\n    };\n    return pureCalculateAnchoredPosition(clippingRect, relativeRect, floatingElement.getBoundingClientRect(), anchorElement instanceof Element ? anchorElement.getBoundingClientRect() : anchorElement, getDefaultSettings(settings));\n}\nfunction getPositionedParent(element) {\n    if (isOnTopLayer(element))\n        return document.body;\n    let parentNode = element.parentNode;\n    while (parentNode !== null) {\n        if (parentNode instanceof HTMLElement && getComputedStyle(parentNode).position !== 'static') {\n            return parentNode;\n        }\n        parentNode = parentNode.parentNode;\n    }\n    return document.body;\n}\nfunction isOnTopLayer(element) {\n    var _a;\n    if (element.tagName === 'DIALOG') {\n        return true;\n    }\n    try {\n        if (element.matches(':popover-open') && /native code/.test((_a = document.body.showPopover) === null || _a === void 0 ? void 0 : _a.toString())) {\n            return true;\n        }\n    }\n    catch (_b) {\n        return false;\n    }\n    return false;\n}\nfunction getClippingRect(element) {\n    let parentNode = element;\n    while (parentNode !== null) {\n        if (!(parentNode instanceof Element)) {\n            break;\n        }\n        const parentNodeStyle = getComputedStyle(parentNode);\n        if (parentNodeStyle.overflow !== 'visible') {\n            break;\n        }\n        parentNode = parentNode.parentNode;\n    }\n    const clippingNode = parentNode === document.body || !(parentNode instanceof HTMLElement) ? document.body : parentNode;\n    const elemRect = clippingNode.getBoundingClientRect();\n    const elemStyle = getComputedStyle(clippingNode);\n    const [borderTop, borderLeft, borderRight, borderBottom] = [\n        elemStyle.borderTopWidth,\n        elemStyle.borderLeftWidth,\n        elemStyle.borderRightWidth,\n        elemStyle.borderBottomWidth,\n    ].map(v => parseInt(v, 10) || 0);\n    return {\n        top: elemRect.top + borderTop,\n        left: elemRect.left + borderLeft,\n        width: elemRect.width - borderRight - borderLeft,\n        height: Math.max(elemRect.height - borderTop - borderBottom, clippingNode === document.body ? window.innerHeight : -Infinity),\n    };\n}\nconst positionDefaults = {\n    side: 'outside-bottom',\n    align: 'start',\n    anchorOffset: 4,\n    alignmentOffset: 4,\n    allowOutOfBounds: false,\n};\nfunction getDefaultSettings(settings = {}) {\n    var _a, _b, _c, _d, _e;\n    const side = (_a = settings.side) !== null && _a !== void 0 ? _a : positionDefaults.side;\n    const align = (_b = settings.align) !== null && _b !== void 0 ? _b : positionDefaults.align;\n    return {\n        side,\n        align,\n        anchorOffset: (_c = settings.anchorOffset) !== null && _c !== void 0 ? _c : (side === 'inside-center' ? 0 : positionDefaults.anchorOffset),\n        alignmentOffset: (_d = settings.alignmentOffset) !== null && _d !== void 0 ? _d : (align !== 'center' && side.startsWith('inside') ? positionDefaults.alignmentOffset : 0),\n        allowOutOfBounds: (_e = settings.allowOutOfBounds) !== null && _e !== void 0 ? _e : positionDefaults.allowOutOfBounds,\n    };\n}\nfunction pureCalculateAnchoredPosition(viewportRect, relativePosition, floatingRect, anchorRect, { side, align, allowOutOfBounds, anchorOffset, alignmentOffset }) {\n    const relativeViewportRect = {\n        top: viewportRect.top - relativePosition.top,\n        left: viewportRect.left - relativePosition.left,\n        width: viewportRect.width,\n        height: viewportRect.height,\n    };\n    let pos = calculatePosition(floatingRect, anchorRect, side, align, anchorOffset, alignmentOffset);\n    let anchorSide = side;\n    let anchorAlign = align;\n    pos.top -= relativePosition.top;\n    pos.left -= relativePosition.left;\n    if (!allowOutOfBounds) {\n        const alternateOrder = alternateOrders[side];\n        let positionAttempt = 0;\n        if (alternateOrder) {\n            let prevSide = side;\n            while (positionAttempt < alternateOrder.length &&\n                shouldRecalculatePosition(prevSide, pos, relativeViewportRect, floatingRect)) {\n                const nextSide = alternateOrder[positionAttempt++];\n                prevSide = nextSide;\n                pos = calculatePosition(floatingRect, anchorRect, nextSide, align, anchorOffset, alignmentOffset);\n                pos.top -= relativePosition.top;\n                pos.left -= relativePosition.left;\n                anchorSide = nextSide;\n            }\n        }\n        const alternateAlignment = alternateAlignments[align];\n        let alignmentAttempt = 0;\n        if (alternateAlignment) {\n            let prevAlign = align;\n            while (alignmentAttempt < alternateAlignment.length &&\n                shouldRecalculateAlignment(prevAlign, pos, relativeViewportRect, floatingRect)) {\n                const nextAlign = alternateAlignment[alignmentAttempt++];\n                prevAlign = nextAlign;\n                pos = calculatePosition(floatingRect, anchorRect, anchorSide, nextAlign, anchorOffset, alignmentOffset);\n                pos.top -= relativePosition.top;\n                pos.left -= relativePosition.left;\n                anchorAlign = nextAlign;\n            }\n        }\n        if (pos.top < relativeViewportRect.top) {\n            pos.top = relativeViewportRect.top;\n        }\n        if (pos.left < relativeViewportRect.left) {\n            pos.left = relativeViewportRect.left;\n        }\n        if (pos.left + floatingRect.width > viewportRect.width + relativeViewportRect.left) {\n            pos.left = viewportRect.width + relativeViewportRect.left - floatingRect.width;\n        }\n        if (alternateOrder && positionAttempt < alternateOrder.length) {\n            if (pos.top + floatingRect.height > viewportRect.height + relativeViewportRect.top) {\n                pos.top = Math.max(viewportRect.height + relativeViewportRect.top - floatingRect.height, 0);\n            }\n        }\n    }\n    return Object.assign(Object.assign({}, pos), { anchorSide, anchorAlign });\n}\nfunction calculatePosition(elementDimensions, anchorPosition, side, align, anchorOffset, alignmentOffset) {\n    const anchorRight = anchorPosition.left + anchorPosition.width;\n    const anchorBottom = anchorPosition.top + anchorPosition.height;\n    let top = -1;\n    let left = -1;\n    if (side === 'outside-top') {\n        top = anchorPosition.top - anchorOffset - elementDimensions.height;\n    }\n    else if (side === 'outside-bottom') {\n        top = anchorBottom + anchorOffset;\n    }\n    else if (side === 'outside-left') {\n        left = anchorPosition.left - anchorOffset - elementDimensions.width;\n    }\n    else if (side === 'outside-right') {\n        left = anchorRight + anchorOffset;\n    }\n    if (side === 'outside-top' || side === 'outside-bottom') {\n        if (align === 'start') {\n            left = anchorPosition.left + alignmentOffset;\n        }\n        else if (align === 'center') {\n            left = anchorPosition.left - (elementDimensions.width - anchorPosition.width) / 2 + alignmentOffset;\n        }\n        else {\n            left = anchorRight - elementDimensions.width - alignmentOffset;\n        }\n    }\n    if (side === 'outside-left' || side === 'outside-right') {\n        if (align === 'start') {\n            top = anchorPosition.top + alignmentOffset;\n        }\n        else if (align === 'center') {\n            top = anchorPosition.top - (elementDimensions.height - anchorPosition.height) / 2 + alignmentOffset;\n        }\n        else {\n            top = anchorBottom - elementDimensions.height - alignmentOffset;\n        }\n    }\n    if (side === 'inside-top') {\n        top = anchorPosition.top + anchorOffset;\n    }\n    else if (side === 'inside-bottom') {\n        top = anchorBottom - anchorOffset - elementDimensions.height;\n    }\n    else if (side === 'inside-left') {\n        left = anchorPosition.left + anchorOffset;\n    }\n    else if (side === 'inside-right') {\n        left = anchorRight - anchorOffset - elementDimensions.width;\n    }\n    else if (side === 'inside-center') {\n        left = (anchorRight + anchorPosition.left) / 2 - elementDimensions.width / 2 + anchorOffset;\n    }\n    if (side === 'inside-top' || side === 'inside-bottom') {\n        if (align === 'start') {\n            left = anchorPosition.left + alignmentOffset;\n        }\n        else if (align === 'center') {\n            left = anchorPosition.left - (elementDimensions.width - anchorPosition.width) / 2 + alignmentOffset;\n        }\n        else {\n            left = anchorRight - elementDimensions.width - alignmentOffset;\n        }\n    }\n    else if (side === 'inside-left' || side === 'inside-right' || side === 'inside-center') {\n        if (align === 'start') {\n            top = anchorPosition.top + alignmentOffset;\n        }\n        else if (align === 'center') {\n            top = anchorPosition.top - (elementDimensions.height - anchorPosition.height) / 2 + alignmentOffset;\n        }\n        else {\n            top = anchorBottom - elementDimensions.height - alignmentOffset;\n        }\n    }\n    return { top, left };\n}\nfunction shouldRecalculatePosition(side, currentPos, containerDimensions, elementDimensions) {\n    if (side === 'outside-top' || side === 'outside-bottom') {\n        return (currentPos.top < containerDimensions.top ||\n            currentPos.top + elementDimensions.height > containerDimensions.height + containerDimensions.top);\n    }\n    else {\n        return (currentPos.left < containerDimensions.left ||\n            currentPos.left + elementDimensions.width > containerDimensions.width + containerDimensions.left);\n    }\n}\nfunction shouldRecalculateAlignment(align, currentPos, containerDimensions, elementDimensions) {\n    if (align === 'end') {\n        return currentPos.left < containerDimensions.left;\n    }\n    else if (align === 'start' || align === 'center') {\n        return (currentPos.left + elementDimensions.width > containerDimensions.left + containerDimensions.width ||\n            currentPos.left < containerDimensions.left);\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}