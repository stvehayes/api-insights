{"ast":null,"code":"// src/events.ts\nvar ToggleEvent = class extends Event {\n  oldState;\n  newState;\n  constructor(type, {\n    oldState = \"\",\n    newState = \"\",\n    ...init\n  } = {}) {\n    super(type, init);\n    this.oldState = String(oldState || \"\");\n    this.newState = String(newState || \"\");\n  }\n};\nvar popoverToggleTaskQueue = /* @__PURE__ */new WeakMap();\nfunction queuePopoverToggleEventTask(element, oldState, newState) {\n  popoverToggleTaskQueue.set(element, setTimeout(() => {\n    if (!popoverToggleTaskQueue.has(element)) return;\n    element.dispatchEvent(new ToggleEvent(\"toggle\", {\n      cancelable: false,\n      oldState,\n      newState\n    }));\n  }, 0));\n}\n\n// src/popover-helpers.ts\nvar ShadowRoot = globalThis.ShadowRoot || function () {};\nvar HTMLDialogElement = globalThis.HTMLDialogElement || function () {};\nvar topLayerElements = /* @__PURE__ */new WeakMap();\nvar autoPopoverList = /* @__PURE__ */new WeakMap();\nvar visibilityState = /* @__PURE__ */new WeakMap();\nfunction getPopoverVisibilityState(popover) {\n  return visibilityState.get(popover) || \"hidden\";\n}\nvar popoverInvoker = /* @__PURE__ */new WeakMap();\nfunction popoverTargetAttributeActivationBehavior(element) {\n  const popover = element.popoverTargetElement;\n  if (!popover) {\n    return;\n  }\n  const visibility = getPopoverVisibilityState(popover);\n  if (element.popoverTargetAction === \"show\" && visibility === \"showing\") {\n    return;\n  }\n  if (element.popoverTargetAction === \"hide\" && visibility === \"hidden\") return;\n  if (visibility === \"showing\") {\n    hidePopover(popover, true, true);\n  } else if (checkPopoverValidity(popover, false)) {\n    popoverInvoker.set(popover, element);\n    showPopover(popover);\n  }\n}\nfunction checkPopoverValidity(element, expectedToBeShowing) {\n  if (element.popover !== \"auto\" && element.popover !== \"manual\") {\n    return false;\n  }\n  if (!element.isConnected) return false;\n  if (expectedToBeShowing && getPopoverVisibilityState(element) !== \"showing\") {\n    return false;\n  }\n  if (!expectedToBeShowing && getPopoverVisibilityState(element) !== \"hidden\") {\n    return false;\n  }\n  if (element instanceof HTMLDialogElement && element.hasAttribute(\"open\")) {\n    return false;\n  }\n  if (document.fullscreenElement === element) return false;\n  return true;\n}\nfunction getStackPosition(popover) {\n  if (!popover) return 0;\n  return Array.from(autoPopoverList.get(popover.ownerDocument) || []).indexOf(popover) + 1;\n}\nfunction topMostClickedPopover(target) {\n  const clickedPopover = nearestInclusiveOpenPopover(target);\n  const invokerPopover = nearestInclusiveTargetPopoverForInvoker(target);\n  if (getStackPosition(clickedPopover) > getStackPosition(invokerPopover)) {\n    return clickedPopover;\n  }\n  return invokerPopover;\n}\nfunction topMostAutoPopover(document2) {\n  const documentPopovers = autoPopoverList.get(document2);\n  for (const popover of documentPopovers || []) {\n    if (!popover.isConnected) {\n      documentPopovers.delete(popover);\n    } else {\n      return popover;\n    }\n  }\n  return null;\n}\nfunction getRootNode(node) {\n  if (typeof node.getRootNode === \"function\") {\n    return node.getRootNode();\n  }\n  if (node.parentNode) return getRootNode(node.parentNode);\n  return node;\n}\nfunction nearestInclusiveOpenPopover(node) {\n  while (node) {\n    if (node instanceof HTMLElement && node.popover === \"auto\" && visibilityState.get(node) === \"showing\") {\n      return node;\n    }\n    node = node.parentElement || getRootNode(node);\n    if (node instanceof ShadowRoot) node = node.host;\n    if (node instanceof Document) return;\n  }\n}\nfunction nearestInclusiveTargetPopoverForInvoker(node) {\n  while (node) {\n    const nodePopover = node.popoverTargetElement;\n    if (nodePopover) return nodePopover;\n    node = node.parentElement || getRootNode(node);\n    if (node instanceof ShadowRoot) node = node.host;\n    if (node instanceof Document) return;\n  }\n}\nfunction topMostPopoverAncestor(newPopover) {\n  const popoverPositions = /* @__PURE__ */new Map();\n  let i = 0;\n  const document2 = newPopover.ownerDocument;\n  for (const popover of autoPopoverList.get(document2) || []) {\n    popoverPositions.set(popover, i);\n    i += 1;\n  }\n  popoverPositions.set(newPopover, i);\n  i += 1;\n  let topMostPopoverAncestor2 = null;\n  function checkAncestor(candidate) {\n    const candidateAncestor = nearestInclusiveOpenPopover(candidate);\n    if (candidateAncestor === null) return null;\n    const candidatePosition = popoverPositions.get(candidateAncestor);\n    if (topMostPopoverAncestor2 === null || popoverPositions.get(topMostPopoverAncestor2) < candidatePosition) {\n      topMostPopoverAncestor2 = candidateAncestor;\n    }\n  }\n  checkAncestor(newPopover?.parentElement);\n  return topMostPopoverAncestor2;\n}\nfunction isFocusable(focusTarget) {\n  if (focusTarget.hidden) return false;\n  if (focusTarget instanceof HTMLButtonElement || focusTarget instanceof HTMLInputElement || focusTarget instanceof HTMLSelectElement || focusTarget instanceof HTMLTextAreaElement || focusTarget instanceof HTMLOptGroupElement || focusTarget instanceof HTMLOptionElement || focusTarget instanceof HTMLFieldSetElement) {\n    if (focusTarget.disabled) return false;\n  }\n  if (focusTarget instanceof HTMLInputElement && focusTarget.type === \"hidden\") {\n    return false;\n  }\n  if (focusTarget instanceof HTMLAnchorElement && focusTarget.href === \"\") {\n    return false;\n  }\n  return focusTarget.tabIndex !== -1;\n}\nfunction focusDelegate(focusTarget) {\n  if (focusTarget.shadowRoot && focusTarget.shadowRoot.delegatesFocus !== true) {\n    return null;\n  }\n  let whereToLook = focusTarget;\n  if (whereToLook.shadowRoot) {\n    whereToLook = whereToLook.shadowRoot;\n  }\n  const autoFocusDelegate = whereToLook.querySelector(\"[autofocus]\");\n  if (autoFocusDelegate) {\n    return autoFocusDelegate;\n  }\n  const walker = focusTarget.ownerDocument.createTreeWalker(whereToLook, NodeFilter.SHOW_ELEMENT);\n  let descendant = walker.currentNode;\n  while (descendant) {\n    if (isFocusable(descendant)) {\n      return descendant;\n    }\n    descendant = walker.nextNode();\n  }\n}\nfunction popoverFocusingSteps(subject) {\n  focusDelegate(subject)?.focus();\n}\nvar previouslyFocusedElements = /* @__PURE__ */new WeakMap();\nfunction showPopover(element) {\n  if (!checkPopoverValidity(element, false)) {\n    return;\n  }\n  const document2 = element.ownerDocument;\n  if (!element.dispatchEvent(new ToggleEvent(\"beforetoggle\", {\n    cancelable: true,\n    oldState: \"closed\",\n    newState: \"open\"\n  }))) {\n    return;\n  }\n  if (!checkPopoverValidity(element, false)) {\n    return;\n  }\n  let shouldRestoreFocus = false;\n  if (element.popover === \"auto\") {\n    const originalType = element.getAttribute(\"popover\");\n    const ancestor = topMostPopoverAncestor(element) || document2;\n    hideAllPopoversUntil(ancestor, false, true);\n    if (originalType !== element.getAttribute(\"popover\") || !checkPopoverValidity(element, false)) {\n      return;\n    }\n  }\n  if (!topMostAutoPopover(document2)) {\n    shouldRestoreFocus = true;\n  }\n  previouslyFocusedElements.delete(element);\n  const originallyFocusedElement = document2.activeElement;\n  element.classList.add(\":popover-open\");\n  visibilityState.set(element, \"showing\");\n  if (!topLayerElements.has(document2)) {\n    topLayerElements.set(document2, /* @__PURE__ */new Set());\n  }\n  topLayerElements.get(document2).add(element);\n  popoverFocusingSteps(element);\n  if (element.popover === \"auto\") {\n    if (!autoPopoverList.has(document2)) {\n      autoPopoverList.set(document2, /* @__PURE__ */new Set());\n    }\n    autoPopoverList.get(document2).add(element);\n    setInvokerAriaExpanded(popoverInvoker.get(element), true);\n  }\n  if (shouldRestoreFocus && originallyFocusedElement && element.popover === \"auto\") {\n    previouslyFocusedElements.set(element, originallyFocusedElement);\n  }\n  queuePopoverToggleEventTask(element, \"closed\", \"open\");\n}\nfunction hidePopover(element, focusPreviousElement = false, fireEvents = false) {\n  if (!checkPopoverValidity(element, true)) {\n    return;\n  }\n  const document2 = element.ownerDocument;\n  if (element.popover === \"auto\") {\n    hideAllPopoversUntil(element, focusPreviousElement, fireEvents);\n    if (!checkPopoverValidity(element, true)) {\n      return;\n    }\n  }\n  setInvokerAriaExpanded(popoverInvoker.get(element), false);\n  popoverInvoker.delete(element);\n  if (fireEvents) {\n    element.dispatchEvent(new ToggleEvent(\"beforetoggle\", {\n      oldState: \"open\",\n      newState: \"closed\"\n    }));\n    if (!checkPopoverValidity(element, true)) {\n      return;\n    }\n  }\n  topLayerElements.get(document2)?.delete(element);\n  autoPopoverList.get(document2)?.delete(element);\n  element.classList.remove(\":popover-open\");\n  visibilityState.set(element, \"hidden\");\n  if (fireEvents) {\n    queuePopoverToggleEventTask(element, \"open\", \"closed\");\n  }\n  const previouslyFocusedElement = previouslyFocusedElements.get(element);\n  if (previouslyFocusedElement) {\n    previouslyFocusedElements.delete(element);\n    if (focusPreviousElement) {\n      previouslyFocusedElement.focus();\n    }\n  }\n}\nfunction closeAllOpenPopovers(document2, focusPreviousElement = false, fireEvents = false) {\n  let popover = topMostAutoPopover(document2);\n  while (popover) {\n    hidePopover(popover, focusPreviousElement, fireEvents);\n    popover = topMostAutoPopover(document2);\n  }\n}\nfunction hideAllPopoversUntil(endpoint, focusPreviousElement, fireEvents) {\n  const document2 = endpoint.ownerDocument || endpoint;\n  if (endpoint instanceof Document) {\n    return closeAllOpenPopovers(document2, focusPreviousElement, fireEvents);\n  }\n  let lastToHide = null;\n  let foundEndpoint = false;\n  for (const popover of autoPopoverList.get(document2) || []) {\n    if (popover === endpoint) {\n      foundEndpoint = true;\n    } else if (foundEndpoint) {\n      lastToHide = popover;\n      break;\n    }\n  }\n  if (!foundEndpoint) {\n    return closeAllOpenPopovers(document2, focusPreviousElement, fireEvents);\n  }\n  while (lastToHide && getPopoverVisibilityState(lastToHide) === \"showing\" && autoPopoverList.get(document2)?.size) {\n    hidePopover(lastToHide, focusPreviousElement, fireEvents);\n  }\n}\nvar popoverPointerDownTargets = /* @__PURE__ */new WeakMap();\nfunction lightDismissOpenPopovers(event) {\n  if (!event.isTrusted) return;\n  const target = event.composedPath()[0];\n  if (!target) return;\n  const document2 = target.ownerDocument;\n  const topMostPopover = topMostAutoPopover(document2);\n  if (!topMostPopover) return;\n  const ancestor = topMostClickedPopover(target);\n  if (ancestor && event.type === \"pointerdown\") {\n    popoverPointerDownTargets.set(document2, ancestor);\n  } else if (event.type === \"pointerup\") {\n    const sameTarget = popoverPointerDownTargets.get(document2) === ancestor;\n    popoverPointerDownTargets.delete(document2);\n    if (sameTarget) {\n      hideAllPopoversUntil(ancestor || document2, false, true);\n    }\n  }\n}\nvar initialAriaExpandedValue = /* @__PURE__ */new WeakMap();\nfunction setInvokerAriaExpanded(el, force = false) {\n  if (!el) return;\n  if (!initialAriaExpandedValue.has(el)) {\n    initialAriaExpandedValue.set(el, el.getAttribute(\"aria-expanded\"));\n  }\n  const popover = el.popoverTargetElement;\n  if (popover && popover.popover === \"auto\") {\n    el.setAttribute(\"aria-expanded\", String(force));\n  } else {\n    const initialValue = initialAriaExpandedValue.get(el);\n    if (!initialValue) {\n      el.removeAttribute(\"aria-expanded\");\n    } else {\n      el.setAttribute(\"aria-expanded\", initialValue);\n    }\n  }\n}\n\n// src/popover.ts\nvar ShadowRoot2 = globalThis.ShadowRoot || function () {};\nfunction isSupported() {\n  return typeof HTMLElement !== \"undefined\" && typeof HTMLElement.prototype === \"object\" && \"popover\" in HTMLElement.prototype;\n}\nfunction patchSelectorFn(object, name, mapper) {\n  const original = object[name];\n  Object.defineProperty(object, name, {\n    value(selector) {\n      return original.call(this, mapper(selector));\n    }\n  });\n}\nvar nonEscapedPopoverSelector = /(^|[^\\\\]):popover-open\\b/g;\nvar styles = `\n  [popover] {\n    position: fixed;\n    z-index: 2147483647;\n    inset: 0;\n    padding: 0.25em;\n    width: fit-content;\n    height: fit-content;\n    border-width: initial;\n    border-color: initial;\n    border-image: initial;\n    border-style: solid;\n    background-color: canvas;\n    color: canvastext;\n    overflow: auto;\n    margin: auto;\n  }\n\n  [popover]:is(dialog[open]) {\n    display: revert;\n  }\n\n  [anchor].\\\\:popover-open {\n    inset: auto;\n  }\n\n  [anchor]:is(:popover-open) {\n    inset: auto;\n  }\n\n  @supports not (background-color: canvas) {\n    [popover] {\n      background-color: white;\n      color: black;\n    }\n  }\n\n  @supports (width: -moz-fit-content) {\n    [popover] {\n      width: -moz-fit-content;\n      height: -moz-fit-content;\n    }\n  }\n\n  @supports not (inset: 0) {\n    [popover] {\n      top: 0;\n      left: 0;\n      right: 0;\n      bottom: 0;\n    }\n  }\n\n  [popover]:not(.\\\\:popover-open) {\n    display: none;\n  }\n`;\nvar popoverStyleSheet = null;\nfunction injectStyles(root) {\n  if (popoverStyleSheet === null) {\n    try {\n      popoverStyleSheet = new CSSStyleSheet();\n      popoverStyleSheet.replaceSync(styles);\n    } catch {\n      popoverStyleSheet = false;\n    }\n  }\n  if (popoverStyleSheet === false) {\n    const sheet = document.createElement(\"style\");\n    sheet.textContent = styles;\n    if (root instanceof Document) {\n      root.head.append(sheet);\n    } else {\n      root.append(sheet);\n    }\n  } else {\n    root.adoptedStyleSheets = [...root.adoptedStyleSheets, popoverStyleSheet];\n  }\n}\nfunction apply() {\n  window.ToggleEvent = window.ToggleEvent || ToggleEvent;\n  function rewriteSelector(selector) {\n    if (selector?.includes(\":popover-open\")) {\n      selector = selector.replace(nonEscapedPopoverSelector, \"$1.\\\\:popover-open\");\n    }\n    return selector;\n  }\n  patchSelectorFn(Document.prototype, \"querySelector\", rewriteSelector);\n  patchSelectorFn(Document.prototype, \"querySelectorAll\", rewriteSelector);\n  patchSelectorFn(Element.prototype, \"querySelector\", rewriteSelector);\n  patchSelectorFn(Element.prototype, \"querySelectorAll\", rewriteSelector);\n  patchSelectorFn(Element.prototype, \"matches\", rewriteSelector);\n  patchSelectorFn(Element.prototype, \"closest\", rewriteSelector);\n  patchSelectorFn(DocumentFragment.prototype, \"querySelectorAll\", rewriteSelector);\n  patchSelectorFn(DocumentFragment.prototype, \"querySelectorAll\", rewriteSelector);\n  Object.defineProperties(HTMLElement.prototype, {\n    popover: {\n      enumerable: true,\n      configurable: true,\n      get() {\n        if (!this.hasAttribute(\"popover\")) return null;\n        const value = (this.getAttribute(\"popover\") || \"\").toLowerCase();\n        if (value === \"\" || value == \"auto\") return \"auto\";\n        return \"manual\";\n      },\n      set(value) {\n        this.setAttribute(\"popover\", value);\n      }\n    },\n    showPopover: {\n      enumerable: true,\n      configurable: true,\n      value() {\n        showPopover(this);\n      }\n    },\n    hidePopover: {\n      enumerable: true,\n      configurable: true,\n      value() {\n        hidePopover(this, true, true);\n      }\n    },\n    togglePopover: {\n      enumerable: true,\n      configurable: true,\n      value(force) {\n        if (visibilityState.get(this) === \"showing\" && force === void 0 || force === false) {\n          hidePopover(this, true, true);\n        } else if (force === void 0 || force === true) {\n          showPopover(this);\n        }\n      }\n    }\n  });\n  const originalAttachShadow = Element.prototype.attachShadow;\n  if (originalAttachShadow) {\n    Object.defineProperties(Element.prototype, {\n      attachShadow: {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value(options) {\n          const shadowRoot = originalAttachShadow.call(this, options);\n          injectStyles(shadowRoot);\n          return shadowRoot;\n        }\n      }\n    });\n  }\n  const originalAttachInternals = HTMLElement.prototype.attachInternals;\n  if (originalAttachInternals) {\n    Object.defineProperties(HTMLElement.prototype, {\n      attachInternals: {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value() {\n          const internals = originalAttachInternals.call(this);\n          if (internals.shadowRoot) {\n            injectStyles(internals.shadowRoot);\n          }\n          return internals;\n        }\n      }\n    });\n  }\n  const popoverTargetAssociatedElements = /* @__PURE__ */new WeakMap();\n  function applyPopoverInvokerElementMixin(ElementClass) {\n    Object.defineProperties(ElementClass.prototype, {\n      popoverTargetElement: {\n        enumerable: true,\n        configurable: true,\n        set(targetElement) {\n          if (targetElement === null) {\n            this.removeAttribute(\"popovertarget\");\n            popoverTargetAssociatedElements.delete(this);\n          } else if (!(targetElement instanceof Element)) {\n            throw new TypeError(`popoverTargetElement must be an element or null`);\n          } else {\n            this.setAttribute(\"popovertarget\", \"\");\n            popoverTargetAssociatedElements.set(this, targetElement);\n          }\n        },\n        get() {\n          if (this.localName !== \"button\" && this.localName !== \"input\") {\n            return null;\n          }\n          if (this.localName === \"input\" && this.type !== \"reset\" && this.type !== \"image\" && this.type !== \"button\") {\n            return null;\n          }\n          if (this.disabled) {\n            return null;\n          }\n          if (this.form && this.type === \"submit\") {\n            return null;\n          }\n          const targetElement = popoverTargetAssociatedElements.get(this);\n          if (targetElement && targetElement.isConnected) {\n            return targetElement;\n          } else if (targetElement && !targetElement.isConnected) {\n            popoverTargetAssociatedElements.delete(this);\n            return null;\n          }\n          const root = getRootNode(this);\n          const idref = this.getAttribute(\"popovertarget\");\n          if ((root instanceof Document || root instanceof ShadowRoot2) && idref) {\n            return root.getElementById(idref) || null;\n          }\n          return null;\n        }\n      },\n      popoverTargetAction: {\n        enumerable: true,\n        configurable: true,\n        get() {\n          const value = (this.getAttribute(\"popovertargetaction\") || \"\").toLowerCase();\n          if (value === \"show\" || value === \"hide\") return value;\n          return \"toggle\";\n        },\n        set(value) {\n          this.setAttribute(\"popovertargetaction\", value);\n        }\n      }\n    });\n  }\n  applyPopoverInvokerElementMixin(HTMLButtonElement);\n  applyPopoverInvokerElementMixin(HTMLInputElement);\n  const handleInvokerActivation = event => {\n    if (!event.isTrusted) return;\n    const target = event.composedPath()[0];\n    if (!(target instanceof Element) || target?.shadowRoot) {\n      return;\n    }\n    const root = getRootNode(target);\n    if (!(root instanceof ShadowRoot2 || root instanceof Document)) {\n      return;\n    }\n    const invoker = target.closest(\"[popovertargetaction],[popovertarget]\");\n    if (invoker) {\n      popoverTargetAttributeActivationBehavior(invoker);\n      return;\n    }\n  };\n  const onKeydown = event => {\n    const key = event.key;\n    const target = event.target;\n    if (target && (key === \"Escape\" || key === \"Esc\")) {\n      hideAllPopoversUntil(target.ownerDocument, true, true);\n    }\n  };\n  const addEventListeners = root => {\n    root.addEventListener(\"click\", handleInvokerActivation);\n    root.addEventListener(\"keydown\", onKeydown);\n    root.addEventListener(\"pointerdown\", lightDismissOpenPopovers);\n    root.addEventListener(\"pointerup\", lightDismissOpenPopovers);\n  };\n  addEventListeners(document);\n  injectStyles(document);\n}\nexport { apply, isSupported };","map":{"version":3,"names":["ToggleEvent","Event","oldState","newState","constructor","type","init","String","popoverToggleTaskQueue","WeakMap","queuePopoverToggleEventTask","element","set","setTimeout","has","dispatchEvent","cancelable","ShadowRoot","globalThis","HTMLDialogElement","topLayerElements","autoPopoverList","visibilityState","getPopoverVisibilityState","popover","get","popoverInvoker","popoverTargetAttributeActivationBehavior","popoverTargetElement","visibility","popoverTargetAction","hidePopover","checkPopoverValidity","showPopover","expectedToBeShowing","isConnected","hasAttribute","document","fullscreenElement","getStackPosition","Array","from","ownerDocument","indexOf","topMostClickedPopover","target","clickedPopover","nearestInclusiveOpenPopover","invokerPopover","nearestInclusiveTargetPopoverForInvoker","topMostAutoPopover","document2","documentPopovers","delete","getRootNode","node","parentNode","HTMLElement","parentElement","host","Document","nodePopover","topMostPopoverAncestor","newPopover","popoverPositions","Map","i","topMostPopoverAncestor2","checkAncestor","candidate","candidateAncestor","candidatePosition","isFocusable","focusTarget","hidden","HTMLButtonElement","HTMLInputElement","HTMLSelectElement","HTMLTextAreaElement","HTMLOptGroupElement","HTMLOptionElement","HTMLFieldSetElement","disabled","HTMLAnchorElement","href","tabIndex","focusDelegate","shadowRoot","delegatesFocus","whereToLook","autoFocusDelegate","querySelector","walker","createTreeWalker","NodeFilter","SHOW_ELEMENT","descendant","currentNode","nextNode","popoverFocusingSteps","subject","focus","previouslyFocusedElements","shouldRestoreFocus","originalType","getAttribute","ancestor","hideAllPopoversUntil","originallyFocusedElement","activeElement","classList","add","Set","setInvokerAriaExpanded","focusPreviousElement","fireEvents","remove","previouslyFocusedElement","closeAllOpenPopovers","endpoint","lastToHide","foundEndpoint","size","popoverPointerDownTargets","lightDismissOpenPopovers","event","isTrusted","composedPath","topMostPopover","sameTarget","initialAriaExpandedValue","el","force","setAttribute","initialValue","removeAttribute","ShadowRoot2","isSupported","prototype","patchSelectorFn","object","name","mapper","original","Object","defineProperty","value","selector","call","nonEscapedPopoverSelector","styles","popoverStyleSheet","injectStyles","root","CSSStyleSheet","replaceSync","sheet","createElement","textContent","head","append","adoptedStyleSheets","apply","window","rewriteSelector","includes","replace","Element","DocumentFragment","defineProperties","enumerable","configurable","toLowerCase","togglePopover","originalAttachShadow","attachShadow","writable","options","originalAttachInternals","attachInternals","internals","popoverTargetAssociatedElements","applyPopoverInvokerElementMixin","ElementClass","targetElement","TypeError","localName","form","idref","getElementById","handleInvokerActivation","invoker","closest","onKeydown","key","addEventListeners","addEventListener"],"sources":["/Users/steve/Documents/repos/github/licensing-report/node_modules/@oddbird/popover-polyfill/src/events.ts","/Users/steve/Documents/repos/github/licensing-report/node_modules/@oddbird/popover-polyfill/src/popover-helpers.ts","/Users/steve/Documents/repos/github/licensing-report/node_modules/@oddbird/popover-polyfill/src/popover.ts"],"sourcesContent":["export interface ToggleInit extends EventInit {\n  oldState: string;\n  newState: string;\n}\n\nexport class ToggleEvent extends Event {\n  public oldState: string;\n  public newState: string;\n  constructor(\n    type: string,\n    { oldState = '', newState = '', ...init }: Partial<ToggleInit> = {},\n  ) {\n    super(type, init);\n    this.oldState = String(oldState || '');\n    this.newState = String(newState || '');\n  }\n}\n\nconst popoverToggleTaskQueue = new WeakMap<HTMLElement, unknown>();\nexport function queuePopoverToggleEventTask(\n  element: HTMLElement,\n  oldState: string,\n  newState: string,\n) {\n  popoverToggleTaskQueue.set(\n    element,\n    setTimeout(() => {\n      if (!popoverToggleTaskQueue.has(element)) return;\n      element.dispatchEvent(\n        new ToggleEvent('toggle', {\n          cancelable: false,\n          oldState,\n          newState,\n        }),\n      );\n    }, 0),\n  );\n}\n","import { queuePopoverToggleEventTask, ToggleEvent } from './events.js';\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nconst ShadowRoot = globalThis.ShadowRoot || function () {};\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nconst HTMLDialogElement = globalThis.HTMLDialogElement || function () {};\n\nconst topLayerElements = new WeakMap<Document, Set<HTMLElement>>();\nconst autoPopoverList = new WeakMap<Document, Set<HTMLElement>>();\nexport const visibilityState = new WeakMap<HTMLElement, 'hidden' | 'showing'>();\nfunction getPopoverVisibilityState(popover: HTMLElement): 'hidden' | 'showing' {\n  return visibilityState.get(popover) || 'hidden';\n}\n\nconst popoverInvoker = new WeakMap<\n  HTMLElement,\n  HTMLButtonElement | HTMLInputElement\n>();\n\n// https://html.spec.whatwg.org/#popover-target-attribute-activation-behavior\nexport function popoverTargetAttributeActivationBehavior(\n  element: HTMLButtonElement | HTMLInputElement,\n) {\n  const popover = element.popoverTargetElement;\n  if (!popover) {\n    return;\n  }\n  const visibility = getPopoverVisibilityState(popover);\n  if (element.popoverTargetAction === 'show' && visibility === 'showing') {\n    return;\n  }\n  if (element.popoverTargetAction === 'hide' && visibility === 'hidden') return;\n  if (visibility === 'showing') {\n    hidePopover(popover, true, true);\n  } else if (checkPopoverValidity(popover, false)) {\n    popoverInvoker.set(popover, element);\n    showPopover(popover);\n  }\n}\n\n// https://whatpr.org/html/8221/popover.html#check-popover-validity\nfunction checkPopoverValidity(\n  element: HTMLElement,\n  expectedToBeShowing: boolean,\n) {\n  if (element.popover !== 'auto' && element.popover !== 'manual') {\n    return false;\n  }\n  if (!element.isConnected) return false;\n  if (expectedToBeShowing && getPopoverVisibilityState(element) !== 'showing') {\n    return false;\n  }\n  if (!expectedToBeShowing && getPopoverVisibilityState(element) !== 'hidden') {\n    return false;\n  }\n  if (element instanceof HTMLDialogElement && element.hasAttribute('open')) {\n    return false;\n  }\n  if (document.fullscreenElement === element) return false;\n  return true;\n}\n\nfunction getStackPosition(popover?: Element) {\n  if (!popover) return 0;\n  return (\n    Array.from(autoPopoverList.get(popover.ownerDocument) || []).indexOf(\n      popover as HTMLElement,\n    ) + 1\n  );\n}\n\nfunction topMostClickedPopover(target: HTMLElement) {\n  const clickedPopover = nearestInclusiveOpenPopover(target);\n  const invokerPopover = nearestInclusiveTargetPopoverForInvoker(target);\n  if (getStackPosition(clickedPopover) > getStackPosition(invokerPopover)) {\n    return clickedPopover;\n  }\n  return invokerPopover;\n}\n\n// https://html.spec.whatwg.org/#topmost-auto-popover\nfunction topMostAutoPopover(document: Document): HTMLElement | null {\n  const documentPopovers = autoPopoverList.get(document);\n  for (const popover of documentPopovers || []) {\n    if (!popover.isConnected) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      documentPopovers!.delete(popover);\n    } else {\n      return popover;\n    }\n  }\n  return null;\n}\n\nexport function getRootNode(node: Node): Node {\n  if (typeof node.getRootNode === 'function') {\n    return node.getRootNode();\n  }\n  if (node.parentNode) return getRootNode(node.parentNode);\n  return node;\n}\n\n// https://html.spec.whatwg.org/#nearest-inclusive-open-popover\nfunction nearestInclusiveOpenPopover(\n  node: Node | null,\n): HTMLElement | undefined {\n  while (node) {\n    if (\n      node instanceof HTMLElement &&\n      node.popover === 'auto' &&\n      visibilityState.get(node) === 'showing'\n    ) {\n      return node;\n    }\n    node = node.parentElement || getRootNode(node);\n    if (node instanceof ShadowRoot) node = node.host;\n    if (node instanceof Document) return;\n  }\n}\n\n// https://html.spec.whatwg.org/#popover-light-dismiss:nearest-inclusive-target-popover-for-invoker\nfunction nearestInclusiveTargetPopoverForInvoker(\n  node: Node | null,\n): HTMLElement | undefined {\n  while (node) {\n    const nodePopover = (node as HTMLButtonElement).popoverTargetElement;\n    if (nodePopover) return nodePopover;\n    node = node.parentElement || getRootNode(node);\n    if (node instanceof ShadowRoot) node = node.host;\n    if (node instanceof Document) return;\n  }\n}\n\n// https://html.spec.whatwg.org/#topmost-popover-ancestor\nfunction topMostPopoverAncestor(newPopover: HTMLElement): HTMLElement | null {\n  const popoverPositions = new Map();\n  let i = 0;\n  const document = newPopover.ownerDocument;\n  for (const popover of autoPopoverList.get(document) || []) {\n    popoverPositions.set(popover, i);\n    i += 1;\n  }\n  popoverPositions.set(newPopover, i);\n  i += 1;\n  let topMostPopoverAncestor: HTMLElement | null = null;\n  function checkAncestor(candidate: HTMLElement | null) {\n    const candidateAncestor = nearestInclusiveOpenPopover(candidate);\n    if (candidateAncestor === null) return null;\n    const candidatePosition = popoverPositions.get(candidateAncestor);\n    if (\n      topMostPopoverAncestor === null ||\n      popoverPositions.get(topMostPopoverAncestor) < candidatePosition\n    ) {\n      topMostPopoverAncestor = candidateAncestor!;\n    }\n  }\n  checkAncestor(newPopover?.parentElement);\n  return topMostPopoverAncestor;\n}\n\nfunction isFocusable(focusTarget: HTMLElement) {\n  if (focusTarget.hidden) return false;\n  if (\n    focusTarget instanceof HTMLButtonElement ||\n    focusTarget instanceof HTMLInputElement ||\n    focusTarget instanceof HTMLSelectElement ||\n    focusTarget instanceof HTMLTextAreaElement ||\n    focusTarget instanceof HTMLOptGroupElement ||\n    focusTarget instanceof HTMLOptionElement ||\n    focusTarget instanceof HTMLFieldSetElement\n  ) {\n    if (focusTarget.disabled) return false;\n  }\n  if (\n    focusTarget instanceof HTMLInputElement &&\n    focusTarget.type === 'hidden'\n  ) {\n    return false;\n  }\n  if (focusTarget instanceof HTMLAnchorElement && focusTarget.href === '') {\n    return false;\n  }\n  return focusTarget.tabIndex !== -1;\n}\n\n// https://html.spec.whatwg.org/#focus-delegate\nfunction focusDelegate(focusTarget: HTMLElement) {\n  if (\n    focusTarget.shadowRoot &&\n    focusTarget.shadowRoot.delegatesFocus !== true\n  ) {\n    return null;\n  }\n  let whereToLook: DocumentFragment | HTMLElement = focusTarget;\n  if (whereToLook.shadowRoot) {\n    whereToLook = whereToLook.shadowRoot;\n  }\n  const autoFocusDelegate = whereToLook.querySelector('[autofocus]');\n  if (autoFocusDelegate) {\n    return autoFocusDelegate;\n  }\n  const walker = focusTarget.ownerDocument.createTreeWalker(\n    whereToLook,\n    NodeFilter.SHOW_ELEMENT,\n  );\n  let descendant: Node | null = walker.currentNode;\n  while (descendant) {\n    // TODO: this is not spec compliant\n    if (isFocusable(descendant as HTMLElement)) {\n      return descendant;\n    }\n    descendant = walker.nextNode();\n  }\n}\n\n// https://html.spec.whatwg.org/#popover-focusing-steps\nfunction popoverFocusingSteps(subject: HTMLElement) {\n  (focusDelegate(subject) as HTMLElement)?.focus();\n}\n\nconst previouslyFocusedElements = new WeakMap<HTMLElement, HTMLElement>();\n\n// https://html.spec.whatwg.org/#show-popover\nexport function showPopover(element: HTMLElement) {\n  if (!checkPopoverValidity(element, false)) {\n    return;\n  }\n  const document = element.ownerDocument;\n  if (\n    !element.dispatchEvent(\n      new ToggleEvent('beforetoggle', {\n        cancelable: true,\n        oldState: 'closed',\n        newState: 'open',\n      }),\n    )\n  ) {\n    return;\n  }\n  if (!checkPopoverValidity(element, false)) {\n    return;\n  }\n  let shouldRestoreFocus = false;\n  if (element.popover === 'auto') {\n    const originalType = element.getAttribute('popover');\n    const ancestor = topMostPopoverAncestor(element) || document;\n    hideAllPopoversUntil(ancestor, false, true);\n    if (\n      originalType !== element.getAttribute('popover') ||\n      !checkPopoverValidity(element, false)\n    ) {\n      return;\n    }\n  }\n  if (!topMostAutoPopover(document)) {\n    shouldRestoreFocus = true;\n  }\n  previouslyFocusedElements.delete(element);\n  const originallyFocusedElement = document.activeElement as HTMLElement;\n  element.classList.add(':popover-open');\n  visibilityState.set(element, 'showing');\n  if (!topLayerElements.has(document)) {\n    topLayerElements.set(document, new Set());\n  }\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  topLayerElements.get(document)!.add(element);\n  popoverFocusingSteps(element);\n  if (element.popover === 'auto') {\n    if (!autoPopoverList.has(document)) {\n      autoPopoverList.set(document, new Set());\n    }\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    autoPopoverList.get(document)!.add(element);\n    setInvokerAriaExpanded(popoverInvoker.get(element), true);\n  }\n  if (\n    shouldRestoreFocus &&\n    originallyFocusedElement &&\n    element.popover === 'auto'\n  ) {\n    previouslyFocusedElements.set(element, originallyFocusedElement);\n  }\n  queuePopoverToggleEventTask(element, 'closed', 'open');\n}\n\n// https://html.spec.whatwg.org/#hide-popover\nexport function hidePopover(\n  element: HTMLElement,\n  focusPreviousElement = false,\n  fireEvents = false,\n) {\n  // https://whatpr.org/html/8221/popover.html#hide-popover\n  if (!checkPopoverValidity(element, true)) {\n    return;\n  }\n  const document = element.ownerDocument;\n  if (element.popover === 'auto') {\n    hideAllPopoversUntil(element, focusPreviousElement, fireEvents);\n    if (!checkPopoverValidity(element, true)) {\n      return;\n    }\n  }\n  setInvokerAriaExpanded(popoverInvoker.get(element), false);\n  popoverInvoker.delete(element);\n  if (fireEvents) {\n    element.dispatchEvent(\n      new ToggleEvent('beforetoggle', {\n        oldState: 'open',\n        newState: 'closed',\n      }),\n    );\n    if (!checkPopoverValidity(element, true)) {\n      return;\n    }\n  }\n  topLayerElements.get(document)?.delete(element);\n  autoPopoverList.get(document)?.delete(element);\n  element.classList.remove(':popover-open');\n  visibilityState.set(element, 'hidden');\n  if (fireEvents) {\n    queuePopoverToggleEventTask(element, 'open', 'closed');\n  }\n  const previouslyFocusedElement = previouslyFocusedElements.get(element);\n  if (previouslyFocusedElement) {\n    previouslyFocusedElements.delete(element);\n    if (focusPreviousElement) {\n      previouslyFocusedElement.focus();\n    }\n  }\n}\n\nfunction closeAllOpenPopovers(\n  document: Document,\n  focusPreviousElement = false,\n  fireEvents = false,\n) {\n  let popover = topMostAutoPopover(document);\n  while (popover) {\n    hidePopover(popover, focusPreviousElement, fireEvents);\n    popover = topMostAutoPopover(document);\n  }\n}\n\n// https://html.spec.whatwg.org/#hide-all-popovers-until\nexport function hideAllPopoversUntil(\n  endpoint: Element | Document,\n  focusPreviousElement: boolean,\n  fireEvents: boolean,\n) {\n  const document = endpoint.ownerDocument || endpoint;\n  if (endpoint instanceof Document) {\n    return closeAllOpenPopovers(document, focusPreviousElement, fireEvents);\n  }\n  let lastToHide = null;\n  let foundEndpoint = false;\n  for (const popover of autoPopoverList.get(document) || []) {\n    if (popover === endpoint) {\n      foundEndpoint = true;\n    } else if (foundEndpoint) {\n      lastToHide = popover;\n      break;\n    }\n  }\n  if (!foundEndpoint) {\n    return closeAllOpenPopovers(document, focusPreviousElement, fireEvents);\n  }\n  while (\n    lastToHide &&\n    getPopoverVisibilityState(lastToHide) === 'showing' &&\n    autoPopoverList.get(document)?.size\n  ) {\n    hidePopover(lastToHide, focusPreviousElement, fireEvents);\n  }\n}\n\nconst popoverPointerDownTargets = new WeakMap<Document, HTMLElement>();\n// https://html.spec.whatwg.org/#topmost-clicked-popover\nexport function lightDismissOpenPopovers(event: Event) {\n  if (!event.isTrusted) return;\n  // Composed path allows us to find the target within shadowroots\n  const target = event.composedPath()[0] as HTMLElement;\n  if (!target) return;\n  const document = target.ownerDocument;\n  const topMostPopover = topMostAutoPopover(document);\n  if (!topMostPopover) return;\n  const ancestor = topMostClickedPopover(target);\n  if (ancestor && event.type === 'pointerdown') {\n    popoverPointerDownTargets.set(document, ancestor);\n  } else if (event.type === 'pointerup') {\n    const sameTarget = popoverPointerDownTargets.get(document) === ancestor;\n    popoverPointerDownTargets.delete(document);\n    if (sameTarget) {\n      hideAllPopoversUntil(ancestor || document, false, true);\n    }\n  }\n}\n\nconst initialAriaExpandedValue = new WeakMap<\n  HTMLButtonElement | HTMLInputElement,\n  null | string\n>();\n\nfunction setInvokerAriaExpanded(\n  el?: HTMLButtonElement | HTMLInputElement,\n  force = false,\n) {\n  if (!el) return;\n  if (!initialAriaExpandedValue.has(el)) {\n    initialAriaExpandedValue.set(el, el.getAttribute('aria-expanded'));\n  }\n  const popover = el.popoverTargetElement;\n  if (popover && popover.popover === 'auto') {\n    el.setAttribute('aria-expanded', String(force));\n  } else {\n    const initialValue = initialAriaExpandedValue.get(el);\n    if (!initialValue) {\n      el.removeAttribute('aria-expanded');\n    } else {\n      el.setAttribute('aria-expanded', initialValue);\n    }\n  }\n}\n","import { ToggleEvent } from './events.js';\nimport {\n  getRootNode,\n  hideAllPopoversUntil,\n  hidePopover,\n  lightDismissOpenPopovers,\n  popoverTargetAttributeActivationBehavior,\n  showPopover,\n  visibilityState,\n} from './popover-helpers.js';\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nconst ShadowRoot = globalThis.ShadowRoot || function () {};\n\nexport function isSupported() {\n  return (\n    typeof HTMLElement !== 'undefined' &&\n    typeof HTMLElement.prototype === 'object' &&\n    'popover' in HTMLElement.prototype\n  );\n}\n\nfunction patchSelectorFn<K extends string>(\n  object: Record<PropertyKey & K, unknown>,\n  name: K,\n  mapper: (selector: string) => string,\n) {\n  const original = object[name] as (selectors: string) => NodeList;\n  Object.defineProperty(object, name, {\n    value(selector: string) {\n      return original.call(this, mapper(selector));\n    },\n  });\n}\n\nconst nonEscapedPopoverSelector = /(^|[^\\\\]):popover-open\\b/g;\n\nconst styles = `\n  [popover] {\n    position: fixed;\n    z-index: 2147483647;\n    inset: 0;\n    padding: 0.25em;\n    width: fit-content;\n    height: fit-content;\n    border-width: initial;\n    border-color: initial;\n    border-image: initial;\n    border-style: solid;\n    background-color: canvas;\n    color: canvastext;\n    overflow: auto;\n    margin: auto;\n  }\n\n  [popover]:is(dialog[open]) {\n    display: revert;\n  }\n\n  [anchor].\\\\:popover-open {\n    inset: auto;\n  }\n\n  [anchor]:is(:popover-open) {\n    inset: auto;\n  }\n\n  @supports not (background-color: canvas) {\n    [popover] {\n      background-color: white;\n      color: black;\n    }\n  }\n\n  @supports (width: -moz-fit-content) {\n    [popover] {\n      width: -moz-fit-content;\n      height: -moz-fit-content;\n    }\n  }\n\n  @supports not (inset: 0) {\n    [popover] {\n      top: 0;\n      left: 0;\n      right: 0;\n      bottom: 0;\n    }\n  }\n\n  [popover]:not(.\\\\:popover-open) {\n    display: none;\n  }\n`;\nlet popoverStyleSheet: null | false | CSSStyleSheet = null;\nexport function injectStyles(root: Document | ShadowRoot) {\n  if (popoverStyleSheet === null) {\n    try {\n      popoverStyleSheet = new CSSStyleSheet();\n      popoverStyleSheet.replaceSync(styles);\n    } catch {\n      popoverStyleSheet = false;\n    }\n  }\n  if (popoverStyleSheet === false) {\n    const sheet = document.createElement('style');\n    sheet.textContent = styles;\n    if (root instanceof Document) {\n      root.head.append(sheet);\n    } else {\n      root.append(sheet);\n    }\n  } else {\n    root.adoptedStyleSheets = [...root.adoptedStyleSheets, popoverStyleSheet];\n  }\n}\n\nexport function apply() {\n  window.ToggleEvent = window.ToggleEvent || ToggleEvent;\n\n  function rewriteSelector(selector: string) {\n    if (selector?.includes(':popover-open')) {\n      selector = selector.replace(\n        nonEscapedPopoverSelector,\n        '$1.\\\\:popover-open',\n      );\n    }\n    return selector;\n  }\n\n  patchSelectorFn(Document.prototype, 'querySelector', rewriteSelector);\n  patchSelectorFn(Document.prototype, 'querySelectorAll', rewriteSelector);\n  patchSelectorFn(Element.prototype, 'querySelector', rewriteSelector);\n  patchSelectorFn(Element.prototype, 'querySelectorAll', rewriteSelector);\n  patchSelectorFn(Element.prototype, 'matches', rewriteSelector);\n  patchSelectorFn(Element.prototype, 'closest', rewriteSelector);\n  patchSelectorFn(\n    DocumentFragment.prototype,\n    'querySelectorAll',\n    rewriteSelector,\n  );\n  patchSelectorFn(\n    DocumentFragment.prototype,\n    'querySelectorAll',\n    rewriteSelector,\n  );\n\n  Object.defineProperties(HTMLElement.prototype, {\n    popover: {\n      enumerable: true,\n      configurable: true,\n      get() {\n        if (!this.hasAttribute('popover')) return null;\n        const value = (this.getAttribute('popover') || '').toLowerCase();\n        if (value === '' || value == 'auto') return 'auto';\n        return 'manual';\n      },\n      set(value) {\n        this.setAttribute('popover', value);\n      },\n    },\n\n    showPopover: {\n      enumerable: true,\n      configurable: true,\n      value() {\n        showPopover(this);\n      },\n    },\n\n    hidePopover: {\n      enumerable: true,\n      configurable: true,\n      value() {\n        hidePopover(this, true, true);\n      },\n    },\n\n    togglePopover: {\n      enumerable: true,\n      configurable: true,\n      value(force: boolean) {\n        if (\n          (visibilityState.get(this) === 'showing' && force === undefined) ||\n          force === false\n        ) {\n          hidePopover(this, true, true);\n        } else if (force === undefined || force === true) {\n          showPopover(this);\n        }\n      },\n    },\n  });\n\n  const originalAttachShadow = Element.prototype.attachShadow;\n  if (originalAttachShadow) {\n    Object.defineProperties(Element.prototype, {\n      attachShadow: {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value(options: ShadowRootInit) {\n          const shadowRoot = originalAttachShadow.call(this, options);\n          injectStyles(shadowRoot);\n          return shadowRoot;\n        },\n      },\n    });\n  }\n  const originalAttachInternals = HTMLElement.prototype.attachInternals;\n  if (originalAttachInternals) {\n    Object.defineProperties(HTMLElement.prototype, {\n      attachInternals: {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value() {\n          const internals = originalAttachInternals.call(this);\n          if (internals.shadowRoot) {\n            injectStyles(internals.shadowRoot);\n          }\n          return internals;\n        },\n      },\n    });\n  }\n\n  const popoverTargetAssociatedElements = new WeakMap<Element, Element>();\n  function applyPopoverInvokerElementMixin(ElementClass: typeof HTMLElement) {\n    Object.defineProperties(ElementClass.prototype, {\n      popoverTargetElement: {\n        enumerable: true,\n        configurable: true,\n        set(targetElement: unknown) {\n          if (targetElement === null) {\n            this.removeAttribute('popovertarget');\n            popoverTargetAssociatedElements.delete(this);\n          } else if (!(targetElement instanceof Element)) {\n            throw new TypeError(\n              `popoverTargetElement must be an element or null`,\n            );\n          } else {\n            this.setAttribute('popovertarget', '');\n            popoverTargetAssociatedElements.set(this, targetElement);\n          }\n        },\n        get() {\n          if (this.localName !== 'button' && this.localName !== 'input') {\n            return null;\n          }\n          if (\n            this.localName === 'input' &&\n            this.type !== 'reset' &&\n            this.type !== 'image' &&\n            this.type !== 'button'\n          ) {\n            return null;\n          }\n          if (this.disabled) {\n            return null;\n          }\n          if (this.form && this.type === 'submit') {\n            return null;\n          }\n          const targetElement = popoverTargetAssociatedElements.get(this);\n          if (targetElement && targetElement.isConnected) {\n            return targetElement;\n          } else if (targetElement && !targetElement.isConnected) {\n            popoverTargetAssociatedElements.delete(this);\n            return null;\n          }\n          const root = getRootNode(this);\n          const idref = this.getAttribute('popovertarget');\n          if (\n            (root instanceof Document || root instanceof ShadowRoot) &&\n            idref\n          ) {\n            return root.getElementById(idref) || null;\n          }\n          return null;\n        },\n      },\n      popoverTargetAction: {\n        enumerable: true,\n        configurable: true,\n        get() {\n          const value = (\n            this.getAttribute('popovertargetaction') || ''\n          ).toLowerCase();\n          if (value === 'show' || value === 'hide') return value;\n          return 'toggle';\n        },\n        set(value) {\n          this.setAttribute('popovertargetaction', value);\n        },\n      },\n    });\n  }\n\n  applyPopoverInvokerElementMixin(HTMLButtonElement);\n  applyPopoverInvokerElementMixin(HTMLInputElement);\n\n  const handleInvokerActivation = (event: Event) => {\n    if (!event.isTrusted) return;\n    // Composed path allows us to find the target within shadowroots\n    const target = event.composedPath()[0] as HTMLElement;\n    if (!(target instanceof Element) || target?.shadowRoot) {\n      return;\n    }\n    const root = getRootNode(target);\n    if (!(root instanceof ShadowRoot || root instanceof Document)) {\n      return;\n    }\n    const invoker = target.closest('[popovertargetaction],[popovertarget]');\n    if (invoker) {\n      popoverTargetAttributeActivationBehavior(invoker as HTMLButtonElement);\n      return;\n    }\n  };\n\n  const onKeydown = (event: Event) => {\n    const key = (event as KeyboardEvent).key;\n    const target = event.target as Element;\n    if (target && (key === 'Escape' || key === 'Esc')) {\n      hideAllPopoversUntil(target.ownerDocument, true, true);\n    }\n  };\n\n  const addEventListeners = (root: Document | ShadowRoot) => {\n    root.addEventListener('click', handleInvokerActivation);\n    root.addEventListener('keydown', onKeydown);\n    root.addEventListener('pointerdown', lightDismissOpenPopovers);\n    root.addEventListener('pointerup', lightDismissOpenPopovers);\n  };\n\n  addEventListeners(document);\n  injectStyles(document);\n}\n"],"mappings":";AAKO,IAAMA,WAAA,GAAN,cAA0BC,KAAA,CAAM;EAC9BC,QAAA;EACAC,QAAA;EACPC,YACEC,IAAA,EACA;IAAEH,QAAA,GAAW;IAAIC,QAAA,GAAW;IAAI,GAAGG;EAAK,IAAyB,CAAC,GAClE;IACA,MAAMD,IAAA,EAAMC,IAAI;IAChB,KAAKJ,QAAA,GAAWK,MAAA,CAAOL,QAAA,IAAY,EAAE;IACrC,KAAKC,QAAA,GAAWI,MAAA,CAAOJ,QAAA,IAAY,EAAE;EACvC;AACF;AAEA,IAAMK,sBAAA,GAAyB,mBAAIC,OAAA,CAA8B;AAC1D,SAASC,4BACdC,OAAA,EACAT,QAAA,EACAC,QAAA,EACA;EACAK,sBAAA,CAAuBI,GAAA,CACrBD,OAAA,EACAE,UAAA,CAAW,MAAM;IACf,IAAI,CAACL,sBAAA,CAAuBM,GAAA,CAAIH,OAAO,GAAG;IAC1CA,OAAA,CAAQI,aAAA,CACN,IAAIf,WAAA,CAAY,UAAU;MACxBgB,UAAA,EAAY;MACZd,QAAA;MACAC;IACF,CAAC,CACH;EACF,GAAG,CAAC,CACN;AACF;;;AClCA,IAAMc,UAAA,GAAaC,UAAA,CAAWD,UAAA,IAAc,YAAY,CAAC;AAGzD,IAAME,iBAAA,GAAoBD,UAAA,CAAWC,iBAAA,IAAqB,YAAY,CAAC;AAEvE,IAAMC,gBAAA,GAAmB,mBAAIX,OAAA,CAAoC;AACjE,IAAMY,eAAA,GAAkB,mBAAIZ,OAAA,CAAoC;AACzD,IAAMa,eAAA,GAAkB,mBAAIb,OAAA,CAA2C;AAC9E,SAASc,0BAA0BC,OAAA,EAA4C;EAC7E,OAAOF,eAAA,CAAgBG,GAAA,CAAID,OAAO,KAAK;AACzC;AAEA,IAAME,cAAA,GAAiB,mBAAIjB,OAAA,CAGzB;AAGK,SAASkB,yCACdhB,OAAA,EACA;EACA,MAAMa,OAAA,GAAUb,OAAA,CAAQiB,oBAAA;EACxB,IAAI,CAACJ,OAAA,EAAS;IACZ;EACF;EACA,MAAMK,UAAA,GAAaN,yBAAA,CAA0BC,OAAO;EACpD,IAAIb,OAAA,CAAQmB,mBAAA,KAAwB,UAAUD,UAAA,KAAe,WAAW;IACtE;EACF;EACA,IAAIlB,OAAA,CAAQmB,mBAAA,KAAwB,UAAUD,UAAA,KAAe,UAAU;EACvE,IAAIA,UAAA,KAAe,WAAW;IAC5BE,WAAA,CAAYP,OAAA,EAAS,MAAM,IAAI;EACjC,WAAWQ,oBAAA,CAAqBR,OAAA,EAAS,KAAK,GAAG;IAC/CE,cAAA,CAAed,GAAA,CAAIY,OAAA,EAASb,OAAO;IACnCsB,WAAA,CAAYT,OAAO;EACrB;AACF;AAGA,SAASQ,qBACPrB,OAAA,EACAuB,mBAAA,EACA;EACA,IAAIvB,OAAA,CAAQa,OAAA,KAAY,UAAUb,OAAA,CAAQa,OAAA,KAAY,UAAU;IAC9D,OAAO;EACT;EACA,IAAI,CAACb,OAAA,CAAQwB,WAAA,EAAa,OAAO;EACjC,IAAID,mBAAA,IAAuBX,yBAAA,CAA0BZ,OAAO,MAAM,WAAW;IAC3E,OAAO;EACT;EACA,IAAI,CAACuB,mBAAA,IAAuBX,yBAAA,CAA0BZ,OAAO,MAAM,UAAU;IAC3E,OAAO;EACT;EACA,IAAIA,OAAA,YAAmBQ,iBAAA,IAAqBR,OAAA,CAAQyB,YAAA,CAAa,MAAM,GAAG;IACxE,OAAO;EACT;EACA,IAAIC,QAAA,CAASC,iBAAA,KAAsB3B,OAAA,EAAS,OAAO;EACnD,OAAO;AACT;AAEA,SAAS4B,iBAAiBf,OAAA,EAAmB;EAC3C,IAAI,CAACA,OAAA,EAAS,OAAO;EACrB,OACEgB,KAAA,CAAMC,IAAA,CAAKpB,eAAA,CAAgBI,GAAA,CAAID,OAAA,CAAQkB,aAAa,KAAK,EAAE,EAAEC,OAAA,CAC3DnB,OACF,IAAI;AAER;AAEA,SAASoB,sBAAsBC,MAAA,EAAqB;EAClD,MAAMC,cAAA,GAAiBC,2BAAA,CAA4BF,MAAM;EACzD,MAAMG,cAAA,GAAiBC,uCAAA,CAAwCJ,MAAM;EACrE,IAAIN,gBAAA,CAAiBO,cAAc,IAAIP,gBAAA,CAAiBS,cAAc,GAAG;IACvE,OAAOF,cAAA;EACT;EACA,OAAOE,cAAA;AACT;AAGA,SAASE,mBAAmBC,SAAA,EAAwC;EAClE,MAAMC,gBAAA,GAAmB/B,eAAA,CAAgBI,GAAA,CAAI0B,SAAQ;EACrD,WAAW3B,OAAA,IAAW4B,gBAAA,IAAoB,EAAC,EAAG;IAC5C,IAAI,CAAC5B,OAAA,CAAQW,WAAA,EAAa;MAExBiB,gBAAA,CAAkBC,MAAA,CAAO7B,OAAO;IAClC,OAAO;MACL,OAAOA,OAAA;IACT;EACF;EACA,OAAO;AACT;AAEO,SAAS8B,YAAYC,IAAA,EAAkB;EAC5C,IAAI,OAAOA,IAAA,CAAKD,WAAA,KAAgB,YAAY;IAC1C,OAAOC,IAAA,CAAKD,WAAA,CAAY;EAC1B;EACA,IAAIC,IAAA,CAAKC,UAAA,EAAY,OAAOF,WAAA,CAAYC,IAAA,CAAKC,UAAU;EACvD,OAAOD,IAAA;AACT;AAGA,SAASR,4BACPQ,IAAA,EACyB;EACzB,OAAOA,IAAA,EAAM;IACX,IACEA,IAAA,YAAgBE,WAAA,IAChBF,IAAA,CAAK/B,OAAA,KAAY,UACjBF,eAAA,CAAgBG,GAAA,CAAI8B,IAAI,MAAM,WAC9B;MACA,OAAOA,IAAA;IACT;IACAA,IAAA,GAAOA,IAAA,CAAKG,aAAA,IAAiBJ,WAAA,CAAYC,IAAI;IAC7C,IAAIA,IAAA,YAAgBtC,UAAA,EAAYsC,IAAA,GAAOA,IAAA,CAAKI,IAAA;IAC5C,IAAIJ,IAAA,YAAgBK,QAAA,EAAU;EAChC;AACF;AAGA,SAASX,wCACPM,IAAA,EACyB;EACzB,OAAOA,IAAA,EAAM;IACX,MAAMM,WAAA,GAAeN,IAAA,CAA2B3B,oBAAA;IAChD,IAAIiC,WAAA,EAAa,OAAOA,WAAA;IACxBN,IAAA,GAAOA,IAAA,CAAKG,aAAA,IAAiBJ,WAAA,CAAYC,IAAI;IAC7C,IAAIA,IAAA,YAAgBtC,UAAA,EAAYsC,IAAA,GAAOA,IAAA,CAAKI,IAAA;IAC5C,IAAIJ,IAAA,YAAgBK,QAAA,EAAU;EAChC;AACF;AAGA,SAASE,uBAAuBC,UAAA,EAA6C;EAC3E,MAAMC,gBAAA,GAAmB,mBAAIC,GAAA,CAAI;EACjC,IAAIC,CAAA,GAAI;EACR,MAAMf,SAAA,GAAWY,UAAA,CAAWrB,aAAA;EAC5B,WAAWlB,OAAA,IAAWH,eAAA,CAAgBI,GAAA,CAAI0B,SAAQ,KAAK,EAAC,EAAG;IACzDa,gBAAA,CAAiBpD,GAAA,CAAIY,OAAA,EAAS0C,CAAC;IAC/BA,CAAA,IAAK;EACP;EACAF,gBAAA,CAAiBpD,GAAA,CAAImD,UAAA,EAAYG,CAAC;EAClCA,CAAA,IAAK;EACL,IAAIC,uBAAA,GAA6C;EACjD,SAASC,cAAcC,SAAA,EAA+B;IACpD,MAAMC,iBAAA,GAAoBvB,2BAAA,CAA4BsB,SAAS;IAC/D,IAAIC,iBAAA,KAAsB,MAAM,OAAO;IACvC,MAAMC,iBAAA,GAAoBP,gBAAA,CAAiBvC,GAAA,CAAI6C,iBAAiB;IAChE,IACEH,uBAAA,KAA2B,QAC3BH,gBAAA,CAAiBvC,GAAA,CAAI0C,uBAAsB,IAAII,iBAAA,EAC/C;MACAJ,uBAAA,GAAyBG,iBAAA;IAC3B;EACF;EACAF,aAAA,CAAcL,UAAA,EAAYL,aAAa;EACvC,OAAOS,uBAAA;AACT;AAEA,SAASK,YAAYC,WAAA,EAA0B;EAC7C,IAAIA,WAAA,CAAYC,MAAA,EAAQ,OAAO;EAC/B,IACED,WAAA,YAAuBE,iBAAA,IACvBF,WAAA,YAAuBG,gBAAA,IACvBH,WAAA,YAAuBI,iBAAA,IACvBJ,WAAA,YAAuBK,mBAAA,IACvBL,WAAA,YAAuBM,mBAAA,IACvBN,WAAA,YAAuBO,iBAAA,IACvBP,WAAA,YAAuBQ,mBAAA,EACvB;IACA,IAAIR,WAAA,CAAYS,QAAA,EAAU,OAAO;EACnC;EACA,IACET,WAAA,YAAuBG,gBAAA,IACvBH,WAAA,CAAYpE,IAAA,KAAS,UACrB;IACA,OAAO;EACT;EACA,IAAIoE,WAAA,YAAuBU,iBAAA,IAAqBV,WAAA,CAAYW,IAAA,KAAS,IAAI;IACvE,OAAO;EACT;EACA,OAAOX,WAAA,CAAYY,QAAA,KAAa;AAClC;AAGA,SAASC,cAAcb,WAAA,EAA0B;EAC/C,IACEA,WAAA,CAAYc,UAAA,IACZd,WAAA,CAAYc,UAAA,CAAWC,cAAA,KAAmB,MAC1C;IACA,OAAO;EACT;EACA,IAAIC,WAAA,GAA8ChB,WAAA;EAClD,IAAIgB,WAAA,CAAYF,UAAA,EAAY;IAC1BE,WAAA,GAAcA,WAAA,CAAYF,UAAA;EAC5B;EACA,MAAMG,iBAAA,GAAoBD,WAAA,CAAYE,aAAA,CAAc,aAAa;EACjE,IAAID,iBAAA,EAAmB;IACrB,OAAOA,iBAAA;EACT;EACA,MAAME,MAAA,GAASnB,WAAA,CAAY/B,aAAA,CAAcmD,gBAAA,CACvCJ,WAAA,EACAK,UAAA,CAAWC,YACb;EACA,IAAIC,UAAA,GAA0BJ,MAAA,CAAOK,WAAA;EACrC,OAAOD,UAAA,EAAY;IAEjB,IAAIxB,WAAA,CAAYwB,UAAyB,GAAG;MAC1C,OAAOA,UAAA;IACT;IACAA,UAAA,GAAaJ,MAAA,CAAOM,QAAA,CAAS;EAC/B;AACF;AAGA,SAASC,qBAAqBC,OAAA,EAAsB;EACjDd,aAAA,CAAcc,OAAO,GAAmBC,KAAA,CAAM;AACjD;AAEA,IAAMC,yBAAA,GAA4B,mBAAI7F,OAAA,CAAkC;AAGjE,SAASwB,YAAYtB,OAAA,EAAsB;EAChD,IAAI,CAACqB,oBAAA,CAAqBrB,OAAA,EAAS,KAAK,GAAG;IACzC;EACF;EACA,MAAMwC,SAAA,GAAWxC,OAAA,CAAQ+B,aAAA;EACzB,IACE,CAAC/B,OAAA,CAAQI,aAAA,CACP,IAAIf,WAAA,CAAY,gBAAgB;IAC9BgB,UAAA,EAAY;IACZd,QAAA,EAAU;IACVC,QAAA,EAAU;EACZ,CAAC,CACH,GACA;IACA;EACF;EACA,IAAI,CAAC6B,oBAAA,CAAqBrB,OAAA,EAAS,KAAK,GAAG;IACzC;EACF;EACA,IAAI4F,kBAAA,GAAqB;EACzB,IAAI5F,OAAA,CAAQa,OAAA,KAAY,QAAQ;IAC9B,MAAMgF,YAAA,GAAe7F,OAAA,CAAQ8F,YAAA,CAAa,SAAS;IACnD,MAAMC,QAAA,GAAW5C,sBAAA,CAAuBnD,OAAO,KAAKwC,SAAA;IACpDwD,oBAAA,CAAqBD,QAAA,EAAU,OAAO,IAAI;IAC1C,IACEF,YAAA,KAAiB7F,OAAA,CAAQ8F,YAAA,CAAa,SAAS,KAC/C,CAACzE,oBAAA,CAAqBrB,OAAA,EAAS,KAAK,GACpC;MACA;IACF;EACF;EACA,IAAI,CAACuC,kBAAA,CAAmBC,SAAQ,GAAG;IACjCoD,kBAAA,GAAqB;EACvB;EACAD,yBAAA,CAA0BjD,MAAA,CAAO1C,OAAO;EACxC,MAAMiG,wBAAA,GAA2BzD,SAAA,CAAS0D,aAAA;EAC1ClG,OAAA,CAAQmG,SAAA,CAAUC,GAAA,CAAI,eAAe;EACrCzF,eAAA,CAAgBV,GAAA,CAAID,OAAA,EAAS,SAAS;EACtC,IAAI,CAACS,gBAAA,CAAiBN,GAAA,CAAIqC,SAAQ,GAAG;IACnC/B,gBAAA,CAAiBR,GAAA,CAAIuC,SAAA,EAAU,mBAAI6D,GAAA,CAAI,CAAC;EAC1C;EAEA5F,gBAAA,CAAiBK,GAAA,CAAI0B,SAAQ,EAAG4D,GAAA,CAAIpG,OAAO;EAC3CwF,oBAAA,CAAqBxF,OAAO;EAC5B,IAAIA,OAAA,CAAQa,OAAA,KAAY,QAAQ;IAC9B,IAAI,CAACH,eAAA,CAAgBP,GAAA,CAAIqC,SAAQ,GAAG;MAClC9B,eAAA,CAAgBT,GAAA,CAAIuC,SAAA,EAAU,mBAAI6D,GAAA,CAAI,CAAC;IACzC;IAEA3F,eAAA,CAAgBI,GAAA,CAAI0B,SAAQ,EAAG4D,GAAA,CAAIpG,OAAO;IAC1CsG,sBAAA,CAAuBvF,cAAA,CAAeD,GAAA,CAAId,OAAO,GAAG,IAAI;EAC1D;EACA,IACE4F,kBAAA,IACAK,wBAAA,IACAjG,OAAA,CAAQa,OAAA,KAAY,QACpB;IACA8E,yBAAA,CAA0B1F,GAAA,CAAID,OAAA,EAASiG,wBAAwB;EACjE;EACAlG,2BAAA,CAA4BC,OAAA,EAAS,UAAU,MAAM;AACvD;AAGO,SAASoB,YACdpB,OAAA,EACAuG,oBAAA,GAAuB,OACvBC,UAAA,GAAa,OACb;EAEA,IAAI,CAACnF,oBAAA,CAAqBrB,OAAA,EAAS,IAAI,GAAG;IACxC;EACF;EACA,MAAMwC,SAAA,GAAWxC,OAAA,CAAQ+B,aAAA;EACzB,IAAI/B,OAAA,CAAQa,OAAA,KAAY,QAAQ;IAC9BmF,oBAAA,CAAqBhG,OAAA,EAASuG,oBAAA,EAAsBC,UAAU;IAC9D,IAAI,CAACnF,oBAAA,CAAqBrB,OAAA,EAAS,IAAI,GAAG;MACxC;IACF;EACF;EACAsG,sBAAA,CAAuBvF,cAAA,CAAeD,GAAA,CAAId,OAAO,GAAG,KAAK;EACzDe,cAAA,CAAe2B,MAAA,CAAO1C,OAAO;EAC7B,IAAIwG,UAAA,EAAY;IACdxG,OAAA,CAAQI,aAAA,CACN,IAAIf,WAAA,CAAY,gBAAgB;MAC9BE,QAAA,EAAU;MACVC,QAAA,EAAU;IACZ,CAAC,CACH;IACA,IAAI,CAAC6B,oBAAA,CAAqBrB,OAAA,EAAS,IAAI,GAAG;MACxC;IACF;EACF;EACAS,gBAAA,CAAiBK,GAAA,CAAI0B,SAAQ,GAAGE,MAAA,CAAO1C,OAAO;EAC9CU,eAAA,CAAgBI,GAAA,CAAI0B,SAAQ,GAAGE,MAAA,CAAO1C,OAAO;EAC7CA,OAAA,CAAQmG,SAAA,CAAUM,MAAA,CAAO,eAAe;EACxC9F,eAAA,CAAgBV,GAAA,CAAID,OAAA,EAAS,QAAQ;EACrC,IAAIwG,UAAA,EAAY;IACdzG,2BAAA,CAA4BC,OAAA,EAAS,QAAQ,QAAQ;EACvD;EACA,MAAM0G,wBAAA,GAA2Bf,yBAAA,CAA0B7E,GAAA,CAAId,OAAO;EACtE,IAAI0G,wBAAA,EAA0B;IAC5Bf,yBAAA,CAA0BjD,MAAA,CAAO1C,OAAO;IACxC,IAAIuG,oBAAA,EAAsB;MACxBG,wBAAA,CAAyBhB,KAAA,CAAM;IACjC;EACF;AACF;AAEA,SAASiB,qBACPnE,SAAA,EACA+D,oBAAA,GAAuB,OACvBC,UAAA,GAAa,OACb;EACA,IAAI3F,OAAA,GAAU0B,kBAAA,CAAmBC,SAAQ;EACzC,OAAO3B,OAAA,EAAS;IACdO,WAAA,CAAYP,OAAA,EAAS0F,oBAAA,EAAsBC,UAAU;IACrD3F,OAAA,GAAU0B,kBAAA,CAAmBC,SAAQ;EACvC;AACF;AAGO,SAASwD,qBACdY,QAAA,EACAL,oBAAA,EACAC,UAAA,EACA;EACA,MAAMhE,SAAA,GAAWoE,QAAA,CAAS7E,aAAA,IAAiB6E,QAAA;EAC3C,IAAIA,QAAA,YAAoB3D,QAAA,EAAU;IAChC,OAAO0D,oBAAA,CAAqBnE,SAAA,EAAU+D,oBAAA,EAAsBC,UAAU;EACxE;EACA,IAAIK,UAAA,GAAa;EACjB,IAAIC,aAAA,GAAgB;EACpB,WAAWjG,OAAA,IAAWH,eAAA,CAAgBI,GAAA,CAAI0B,SAAQ,KAAK,EAAC,EAAG;IACzD,IAAI3B,OAAA,KAAY+F,QAAA,EAAU;MACxBE,aAAA,GAAgB;IAClB,WAAWA,aAAA,EAAe;MACxBD,UAAA,GAAahG,OAAA;MACb;IACF;EACF;EACA,IAAI,CAACiG,aAAA,EAAe;IAClB,OAAOH,oBAAA,CAAqBnE,SAAA,EAAU+D,oBAAA,EAAsBC,UAAU;EACxE;EACA,OACEK,UAAA,IACAjG,yBAAA,CAA0BiG,UAAU,MAAM,aAC1CnG,eAAA,CAAgBI,GAAA,CAAI0B,SAAQ,GAAGuE,IAAA,EAC/B;IACA3F,WAAA,CAAYyF,UAAA,EAAYN,oBAAA,EAAsBC,UAAU;EAC1D;AACF;AAEA,IAAMQ,yBAAA,GAA4B,mBAAIlH,OAAA,CAA+B;AAE9D,SAASmH,yBAAyBC,KAAA,EAAc;EACrD,IAAI,CAACA,KAAA,CAAMC,SAAA,EAAW;EAEtB,MAAMjF,MAAA,GAASgF,KAAA,CAAME,YAAA,CAAa,EAAE,CAAC;EACrC,IAAI,CAAClF,MAAA,EAAQ;EACb,MAAMM,SAAA,GAAWN,MAAA,CAAOH,aAAA;EACxB,MAAMsF,cAAA,GAAiB9E,kBAAA,CAAmBC,SAAQ;EAClD,IAAI,CAAC6E,cAAA,EAAgB;EACrB,MAAMtB,QAAA,GAAW9D,qBAAA,CAAsBC,MAAM;EAC7C,IAAI6D,QAAA,IAAYmB,KAAA,CAAMxH,IAAA,KAAS,eAAe;IAC5CsH,yBAAA,CAA0B/G,GAAA,CAAIuC,SAAA,EAAUuD,QAAQ;EAClD,WAAWmB,KAAA,CAAMxH,IAAA,KAAS,aAAa;IACrC,MAAM4H,UAAA,GAAaN,yBAAA,CAA0BlG,GAAA,CAAI0B,SAAQ,MAAMuD,QAAA;IAC/DiB,yBAAA,CAA0BtE,MAAA,CAAOF,SAAQ;IACzC,IAAI8E,UAAA,EAAY;MACdtB,oBAAA,CAAqBD,QAAA,IAAYvD,SAAA,EAAU,OAAO,IAAI;IACxD;EACF;AACF;AAEA,IAAM+E,wBAAA,GAA2B,mBAAIzH,OAAA,CAGnC;AAEF,SAASwG,uBACPkB,EAAA,EACAC,KAAA,GAAQ,OACR;EACA,IAAI,CAACD,EAAA,EAAI;EACT,IAAI,CAACD,wBAAA,CAAyBpH,GAAA,CAAIqH,EAAE,GAAG;IACrCD,wBAAA,CAAyBtH,GAAA,CAAIuH,EAAA,EAAIA,EAAA,CAAG1B,YAAA,CAAa,eAAe,CAAC;EACnE;EACA,MAAMjF,OAAA,GAAU2G,EAAA,CAAGvG,oBAAA;EACnB,IAAIJ,OAAA,IAAWA,OAAA,CAAQA,OAAA,KAAY,QAAQ;IACzC2G,EAAA,CAAGE,YAAA,CAAa,iBAAiB9H,MAAA,CAAO6H,KAAK,CAAC;EAChD,OAAO;IACL,MAAME,YAAA,GAAeJ,wBAAA,CAAyBzG,GAAA,CAAI0G,EAAE;IACpD,IAAI,CAACG,YAAA,EAAc;MACjBH,EAAA,CAAGI,eAAA,CAAgB,eAAe;IACpC,OAAO;MACLJ,EAAA,CAAGE,YAAA,CAAa,iBAAiBC,YAAY;IAC/C;EACF;AACF;;;AC1ZA,IAAME,WAAA,GAAatH,UAAA,CAAWD,UAAA,IAAc,YAAY,CAAC;AAElD,SAASwH,YAAA,EAAc;EAC5B,OACE,OAAOhF,WAAA,KAAgB,eACvB,OAAOA,WAAA,CAAYiF,SAAA,KAAc,YACjC,aAAajF,WAAA,CAAYiF,SAAA;AAE7B;AAEA,SAASC,gBACPC,MAAA,EACAC,IAAA,EACAC,MAAA,EACA;EACA,MAAMC,QAAA,GAAWH,MAAA,CAAOC,IAAI;EAC5BG,MAAA,CAAOC,cAAA,CAAeL,MAAA,EAAQC,IAAA,EAAM;IAClCK,MAAMC,QAAA,EAAkB;MACtB,OAAOJ,QAAA,CAASK,IAAA,CAAK,MAAMN,MAAA,CAAOK,QAAQ,CAAC;IAC7C;EACF,CAAC;AACH;AAEA,IAAME,yBAAA,GAA4B;AAElC,IAAMC,MAAA,GAAS;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAyDf,IAAIC,iBAAA,GAAkD;AAC/C,SAASC,aAAaC,IAAA,EAA6B;EACxD,IAAIF,iBAAA,KAAsB,MAAM;IAC9B,IAAI;MACFA,iBAAA,GAAoB,IAAIG,aAAA,CAAc;MACtCH,iBAAA,CAAkBI,WAAA,CAAYL,MAAM;IACtC,QAAQ;MACNC,iBAAA,GAAoB;IACtB;EACF;EACA,IAAIA,iBAAA,KAAsB,OAAO;IAC/B,MAAMK,KAAA,GAAQvH,QAAA,CAASwH,aAAA,CAAc,OAAO;IAC5CD,KAAA,CAAME,WAAA,GAAcR,MAAA;IACpB,IAAIG,IAAA,YAAgB7F,QAAA,EAAU;MAC5B6F,IAAA,CAAKM,IAAA,CAAKC,MAAA,CAAOJ,KAAK;IACxB,OAAO;MACLH,IAAA,CAAKO,MAAA,CAAOJ,KAAK;IACnB;EACF,OAAO;IACLH,IAAA,CAAKQ,kBAAA,GAAqB,CAAC,GAAGR,IAAA,CAAKQ,kBAAA,EAAoBV,iBAAiB;EAC1E;AACF;AAEO,SAASW,MAAA,EAAQ;EACtBC,MAAA,CAAOnK,WAAA,GAAcmK,MAAA,CAAOnK,WAAA,IAAeA,WAAA;EAE3C,SAASoK,gBAAgBjB,QAAA,EAAkB;IACzC,IAAIA,QAAA,EAAUkB,QAAA,CAAS,eAAe,GAAG;MACvClB,QAAA,GAAWA,QAAA,CAASmB,OAAA,CAClBjB,yBAAA,EACA,oBACF;IACF;IACA,OAAOF,QAAA;EACT;EAEAR,eAAA,CAAgB/E,QAAA,CAAS8E,SAAA,EAAW,iBAAiB0B,eAAe;EACpEzB,eAAA,CAAgB/E,QAAA,CAAS8E,SAAA,EAAW,oBAAoB0B,eAAe;EACvEzB,eAAA,CAAgB4B,OAAA,CAAQ7B,SAAA,EAAW,iBAAiB0B,eAAe;EACnEzB,eAAA,CAAgB4B,OAAA,CAAQ7B,SAAA,EAAW,oBAAoB0B,eAAe;EACtEzB,eAAA,CAAgB4B,OAAA,CAAQ7B,SAAA,EAAW,WAAW0B,eAAe;EAC7DzB,eAAA,CAAgB4B,OAAA,CAAQ7B,SAAA,EAAW,WAAW0B,eAAe;EAC7DzB,eAAA,CACE6B,gBAAA,CAAiB9B,SAAA,EACjB,oBACA0B,eACF;EACAzB,eAAA,CACE6B,gBAAA,CAAiB9B,SAAA,EACjB,oBACA0B,eACF;EAEApB,MAAA,CAAOyB,gBAAA,CAAiBhH,WAAA,CAAYiF,SAAA,EAAW;IAC7ClH,OAAA,EAAS;MACPkJ,UAAA,EAAY;MACZC,YAAA,EAAc;MACdlJ,IAAA,EAAM;QACJ,IAAI,CAAC,KAAKW,YAAA,CAAa,SAAS,GAAG,OAAO;QAC1C,MAAM8G,KAAA,IAAS,KAAKzC,YAAA,CAAa,SAAS,KAAK,IAAImE,WAAA,CAAY;QAC/D,IAAI1B,KAAA,KAAU,MAAMA,KAAA,IAAS,QAAQ,OAAO;QAC5C,OAAO;MACT;MACAtI,IAAIsI,KAAA,EAAO;QACT,KAAKb,YAAA,CAAa,WAAWa,KAAK;MACpC;IACF;IAEAjH,WAAA,EAAa;MACXyI,UAAA,EAAY;MACZC,YAAA,EAAc;MACdzB,MAAA,EAAQ;QACNjH,WAAA,CAAY,IAAI;MAClB;IACF;IAEAF,WAAA,EAAa;MACX2I,UAAA,EAAY;MACZC,YAAA,EAAc;MACdzB,MAAA,EAAQ;QACNnH,WAAA,CAAY,MAAM,MAAM,IAAI;MAC9B;IACF;IAEA8I,aAAA,EAAe;MACbH,UAAA,EAAY;MACZC,YAAA,EAAc;MACdzB,MAAMd,KAAA,EAAgB;QACpB,IACG9G,eAAA,CAAgBG,GAAA,CAAI,IAAI,MAAM,aAAa2G,KAAA,KAAU,UACtDA,KAAA,KAAU,OACV;UACArG,WAAA,CAAY,MAAM,MAAM,IAAI;QAC9B,WAAWqG,KAAA,KAAU,UAAaA,KAAA,KAAU,MAAM;UAChDnG,WAAA,CAAY,IAAI;QAClB;MACF;IACF;EACF,CAAC;EAED,MAAM6I,oBAAA,GAAuBP,OAAA,CAAQ7B,SAAA,CAAUqC,YAAA;EAC/C,IAAID,oBAAA,EAAsB;IACxB9B,MAAA,CAAOyB,gBAAA,CAAiBF,OAAA,CAAQ7B,SAAA,EAAW;MACzCqC,YAAA,EAAc;QACZL,UAAA,EAAY;QACZC,YAAA,EAAc;QACdK,QAAA,EAAU;QACV9B,MAAM+B,OAAA,EAAyB;UAC7B,MAAM1F,UAAA,GAAauF,oBAAA,CAAqB1B,IAAA,CAAK,MAAM6B,OAAO;UAC1DzB,YAAA,CAAajE,UAAU;UACvB,OAAOA,UAAA;QACT;MACF;IACF,CAAC;EACH;EACA,MAAM2F,uBAAA,GAA0BzH,WAAA,CAAYiF,SAAA,CAAUyC,eAAA;EACtD,IAAID,uBAAA,EAAyB;IAC3BlC,MAAA,CAAOyB,gBAAA,CAAiBhH,WAAA,CAAYiF,SAAA,EAAW;MAC7CyC,eAAA,EAAiB;QACfT,UAAA,EAAY;QACZC,YAAA,EAAc;QACdK,QAAA,EAAU;QACV9B,MAAA,EAAQ;UACN,MAAMkC,SAAA,GAAYF,uBAAA,CAAwB9B,IAAA,CAAK,IAAI;UACnD,IAAIgC,SAAA,CAAU7F,UAAA,EAAY;YACxBiE,YAAA,CAAa4B,SAAA,CAAU7F,UAAU;UACnC;UACA,OAAO6F,SAAA;QACT;MACF;IACF,CAAC;EACH;EAEA,MAAMC,+BAAA,GAAkC,mBAAI5K,OAAA,CAA0B;EACtE,SAAS6K,gCAAgCC,YAAA,EAAkC;IACzEvC,MAAA,CAAOyB,gBAAA,CAAiBc,YAAA,CAAa7C,SAAA,EAAW;MAC9C9G,oBAAA,EAAsB;QACpB8I,UAAA,EAAY;QACZC,YAAA,EAAc;QACd/J,IAAI4K,aAAA,EAAwB;UAC1B,IAAIA,aAAA,KAAkB,MAAM;YAC1B,KAAKjD,eAAA,CAAgB,eAAe;YACpC8C,+BAAA,CAAgChI,MAAA,CAAO,IAAI;UAC7C,WAAW,EAAEmI,aAAA,YAAyBjB,OAAA,GAAU;YAC9C,MAAM,IAAIkB,SAAA,CACR,iDACF;UACF,OAAO;YACL,KAAKpD,YAAA,CAAa,iBAAiB,EAAE;YACrCgD,+BAAA,CAAgCzK,GAAA,CAAI,MAAM4K,aAAa;UACzD;QACF;QACA/J,IAAA,EAAM;UACJ,IAAI,KAAKiK,SAAA,KAAc,YAAY,KAAKA,SAAA,KAAc,SAAS;YAC7D,OAAO;UACT;UACA,IACE,KAAKA,SAAA,KAAc,WACnB,KAAKrL,IAAA,KAAS,WACd,KAAKA,IAAA,KAAS,WACd,KAAKA,IAAA,KAAS,UACd;YACA,OAAO;UACT;UACA,IAAI,KAAK6E,QAAA,EAAU;YACjB,OAAO;UACT;UACA,IAAI,KAAKyG,IAAA,IAAQ,KAAKtL,IAAA,KAAS,UAAU;YACvC,OAAO;UACT;UACA,MAAMmL,aAAA,GAAgBH,+BAAA,CAAgC5J,GAAA,CAAI,IAAI;UAC9D,IAAI+J,aAAA,IAAiBA,aAAA,CAAcrJ,WAAA,EAAa;YAC9C,OAAOqJ,aAAA;UACT,WAAWA,aAAA,IAAiB,CAACA,aAAA,CAAcrJ,WAAA,EAAa;YACtDkJ,+BAAA,CAAgChI,MAAA,CAAO,IAAI;YAC3C,OAAO;UACT;UACA,MAAMoG,IAAA,GAAOnG,WAAA,CAAY,IAAI;UAC7B,MAAMsI,KAAA,GAAQ,KAAKnF,YAAA,CAAa,eAAe;UAC/C,KACGgD,IAAA,YAAgB7F,QAAA,IAAY6F,IAAA,YAAgBjB,WAAA,KAC7CoD,KAAA,EACA;YACA,OAAOnC,IAAA,CAAKoC,cAAA,CAAeD,KAAK,KAAK;UACvC;UACA,OAAO;QACT;MACF;MACA9J,mBAAA,EAAqB;QACnB4I,UAAA,EAAY;QACZC,YAAA,EAAc;QACdlJ,IAAA,EAAM;UACJ,MAAMyH,KAAA,IACJ,KAAKzC,YAAA,CAAa,qBAAqB,KAAK,IAC5CmE,WAAA,CAAY;UACd,IAAI1B,KAAA,KAAU,UAAUA,KAAA,KAAU,QAAQ,OAAOA,KAAA;UACjD,OAAO;QACT;QACAtI,IAAIsI,KAAA,EAAO;UACT,KAAKb,YAAA,CAAa,uBAAuBa,KAAK;QAChD;MACF;IACF,CAAC;EACH;EAEAoC,+BAAA,CAAgC3G,iBAAiB;EACjD2G,+BAAA,CAAgC1G,gBAAgB;EAEhD,MAAMkH,uBAAA,GAA2BjE,KAAA,IAAiB;IAChD,IAAI,CAACA,KAAA,CAAMC,SAAA,EAAW;IAEtB,MAAMjF,MAAA,GAASgF,KAAA,CAAME,YAAA,CAAa,EAAE,CAAC;IACrC,IAAI,EAAElF,MAAA,YAAkB0H,OAAA,KAAY1H,MAAA,EAAQ0C,UAAA,EAAY;MACtD;IACF;IACA,MAAMkE,IAAA,GAAOnG,WAAA,CAAYT,MAAM;IAC/B,IAAI,EAAE4G,IAAA,YAAgBjB,WAAA,IAAciB,IAAA,YAAgB7F,QAAA,GAAW;MAC7D;IACF;IACA,MAAMmI,OAAA,GAAUlJ,MAAA,CAAOmJ,OAAA,CAAQ,uCAAuC;IACtE,IAAID,OAAA,EAAS;MACXpK,wCAAA,CAAyCoK,OAA4B;MACrE;IACF;EACF;EAEA,MAAME,SAAA,GAAapE,KAAA,IAAiB;IAClC,MAAMqE,GAAA,GAAOrE,KAAA,CAAwBqE,GAAA;IACrC,MAAMrJ,MAAA,GAASgF,KAAA,CAAMhF,MAAA;IACrB,IAAIA,MAAA,KAAWqJ,GAAA,KAAQ,YAAYA,GAAA,KAAQ,QAAQ;MACjDvF,oBAAA,CAAqB9D,MAAA,CAAOH,aAAA,EAAe,MAAM,IAAI;IACvD;EACF;EAEA,MAAMyJ,iBAAA,GAAqB1C,IAAA,IAAgC;IACzDA,IAAA,CAAK2C,gBAAA,CAAiB,SAASN,uBAAuB;IACtDrC,IAAA,CAAK2C,gBAAA,CAAiB,WAAWH,SAAS;IAC1CxC,IAAA,CAAK2C,gBAAA,CAAiB,eAAexE,wBAAwB;IAC7D6B,IAAA,CAAK2C,gBAAA,CAAiB,aAAaxE,wBAAwB;EAC7D;EAEAuE,iBAAA,CAAkB9J,QAAQ;EAC1BmH,YAAA,CAAanH,QAAQ;AACvB"},"metadata":{},"sourceType":"module","externalDependencies":[]}