{"ast":null,"code":"import { useCallback } from 'react';\nimport { getSelectedLineRange } from './utils.js';\nconst calculateNextListItemStarter = ({\n  leadingWhitespace = '',\n  delimeter,\n  taskBox,\n  text\n}) => {\n  if (!text) return null; // Delete the current list item if the user presses enter without typing anything\n\n  const updatedDelimeter = typeof delimeter === 'number' ? `${delimeter + 1}.` : delimeter;\n  const maybeEmptyTaskBox = taskBox ? ' [ ]' : '';\n  return `\\n${leadingWhitespace}${updatedDelimeter}${maybeEmptyTaskBox} `;\n};\n\n/**\n * Adapted from: https://github.com/github/github/blob/ef649172de6802a699638e22798396ca78d61dc8/app/assets/modules/github/behaviors/task-list.ts#L404\n *\n * Groups:\n *  0. Leading whitespace\n *  1. Delimeter\n *  2. Item number (optional)\n *     - Note that we don't have item letter - we don't do autocomplete for lettered lists like (a, b, c) or (i, ii, iii) because it's too complex\n *  3. Task box (optional)\n *  4. Everything following\n */\nconst listItemRegex = /^(\\s*)([*-]|(\\d+)\\.)(\\s{1,4})(?:(\\[[\\sx]\\])\\s)?(.*)/i;\nconst isNumericListItem = item => typeof (item === null || item === void 0 ? void 0 : item.delimeter) === 'number';\nconst parseListItem = line => {\n  const result = listItemRegex.exec(line);\n  if (!result) return null;\n  const [, leadingWhitespace = '', fullDelimeter, itemNumberStr = '', middleWhitespace, taskBox = null, text] = result;\n  const itemNumber = Number.parseInt(itemNumberStr, 10);\n  const delimeter = Number.isNaN(itemNumber) ? fullDelimeter : itemNumber;\n  return {\n    leadingWhitespace,\n    text,\n    delimeter,\n    middleWhitespace,\n    taskBox: taskBox\n  };\n};\nconst listItemToString = item => typeof item.delimeter === 'number' ? `${item.leadingWhitespace}${`${item.delimeter}.`}${item.middleWhitespace}${item.text}` : `${item.leadingWhitespace}${item.delimeter}${item.middleWhitespace}${item.taskBox || ''} ${item.text}`;\n\n/**\n * Provides support for list editing in the Markdown editor. This includes inserting new\n * list items and auto-incrementing numeric lists.\n */\nconst useListEditing = ({\n  emitChange\n}) => {\n  const incrementFollowingNumericLines = useCallback(textarea => {\n    // this must be recalculated instead of passed because we are on a new line now\n    const [currentLineStart, currentLineEnd] = getSelectedLineRange(textarea);\n    const currentLineText = textarea.value.slice(currentLineStart, currentLineEnd);\n    const currentLineItem = parseListItem(currentLineText);\n    if (!isNumericListItem(currentLineItem)) return;\n\n    // Strip off the leading newline by adding 1\n    const followingText = textarea.value.slice(currentLineEnd + 1);\n    const followingLines = followingText.split(/\\r?\\n/);\n    const followingNumericListItems = [];\n    let prevItemNumber = currentLineItem.delimeter;\n    for (const line of followingLines) {\n      const listItem = parseListItem(line);\n      if (!isNumericListItem(listItem) || listItem.delimeter !== prevItemNumber) break;\n      followingNumericListItems.push(listItem);\n      prevItemNumber++;\n    }\n    if (followingNumericListItems.length === 0) return;\n\n    // don't forget to re-add the leading newline stripped off earlier\n    const updatedItems = `\\n${followingNumericListItems.map(item => listItemToString({\n      ...item,\n      delimeter: item.delimeter + 1\n    })).join('\\n')}`;\n    emitChange(updatedItems, [currentLineEnd, currentLineEnd + updatedItems.length + 1], textarea.selectionStart);\n  }, [emitChange]);\n  const onKeyDown = useCallback(event => {\n    if (event.key === 'Enter' && !event.shiftKey && !event.defaultPrevented) {\n      const textarea = event.currentTarget;\n      const [activeLineStart, activeLineEnd] = getSelectedLineRange(textarea);\n\n      // current line text without any of the selected text\n      const activeLineValue = textarea.value.slice(activeLineStart, textarea.selectionStart) + textarea.value.slice(textarea.selectionEnd, activeLineEnd);\n      const listItem = parseListItem(activeLineValue);\n      if (!listItem) return; // not currently editing a list - let the browser handle the event\n\n      event.preventDefault();\n      const nextItemStarter = calculateNextListItemStarter(listItem);\n      if (nextItemStarter === null) {\n        emitChange('', [activeLineStart, textarea.selectionEnd]);\n      } else {\n        emitChange(nextItemStarter);\n        // increment following lines as a separate event so the user can separately undo the change\n        incrementFollowingNumericLines(textarea);\n      }\n    }\n  }, [emitChange, incrementFollowingNumericLines]);\n  return {\n    onKeyDown\n  };\n};\nexport { listItemRegex, listItemToString, parseListItem, useListEditing };","map":{"version":3,"names":["useCallback","getSelectedLineRange","calculateNextListItemStarter","leadingWhitespace","delimeter","taskBox","text","updatedDelimeter","maybeEmptyTaskBox","listItemRegex","isNumericListItem","item","parseListItem","line","result","exec","fullDelimeter","itemNumberStr","middleWhitespace","itemNumber","Number","parseInt","isNaN","listItemToString","useListEditing","emitChange","incrementFollowingNumericLines","textarea","currentLineStart","currentLineEnd","currentLineText","value","slice","currentLineItem","followingText","followingLines","split","followingNumericListItems","prevItemNumber","listItem","push","length","updatedItems","map","join","selectionStart","onKeyDown","event","key","shiftKey","defaultPrevented","currentTarget","activeLineStart","activeLineEnd","activeLineValue","selectionEnd","preventDefault","nextItemStarter"],"sources":["/Users/steve/Documents/repos/github/api-insights/node_modules/@primer/react/lib-esm/drafts/MarkdownEditor/_useListEditing.js"],"sourcesContent":["import { useCallback } from 'react';\nimport { getSelectedLineRange } from './utils.js';\n\nconst calculateNextListItemStarter = ({\n  leadingWhitespace = '',\n  delimeter,\n  taskBox,\n  text\n}) => {\n  if (!text) return null; // Delete the current list item if the user presses enter without typing anything\n\n  const updatedDelimeter = typeof delimeter === 'number' ? `${delimeter + 1}.` : delimeter;\n  const maybeEmptyTaskBox = taskBox ? ' [ ]' : '';\n  return `\\n${leadingWhitespace}${updatedDelimeter}${maybeEmptyTaskBox} `;\n};\n\n/**\n * Adapted from: https://github.com/github/github/blob/ef649172de6802a699638e22798396ca78d61dc8/app/assets/modules/github/behaviors/task-list.ts#L404\n *\n * Groups:\n *  0. Leading whitespace\n *  1. Delimeter\n *  2. Item number (optional)\n *     - Note that we don't have item letter - we don't do autocomplete for lettered lists like (a, b, c) or (i, ii, iii) because it's too complex\n *  3. Task box (optional)\n *  4. Everything following\n */\nconst listItemRegex = /^(\\s*)([*-]|(\\d+)\\.)(\\s{1,4})(?:(\\[[\\sx]\\])\\s)?(.*)/i;\nconst isNumericListItem = item => typeof (item === null || item === void 0 ? void 0 : item.delimeter) === 'number';\nconst parseListItem = line => {\n  const result = listItemRegex.exec(line);\n  if (!result) return null;\n  const [, leadingWhitespace = '', fullDelimeter, itemNumberStr = '', middleWhitespace, taskBox = null, text] = result;\n  const itemNumber = Number.parseInt(itemNumberStr, 10);\n  const delimeter = Number.isNaN(itemNumber) ? fullDelimeter : itemNumber;\n  return {\n    leadingWhitespace,\n    text,\n    delimeter,\n    middleWhitespace,\n    taskBox: taskBox\n  };\n};\nconst listItemToString = item => typeof item.delimeter === 'number' ? `${item.leadingWhitespace}${`${item.delimeter}.`}${item.middleWhitespace}${item.text}` : `${item.leadingWhitespace}${item.delimeter}${item.middleWhitespace}${item.taskBox || ''} ${item.text}`;\n\n/**\n * Provides support for list editing in the Markdown editor. This includes inserting new\n * list items and auto-incrementing numeric lists.\n */\nconst useListEditing = ({\n  emitChange\n}) => {\n  const incrementFollowingNumericLines = useCallback(textarea => {\n    // this must be recalculated instead of passed because we are on a new line now\n    const [currentLineStart, currentLineEnd] = getSelectedLineRange(textarea);\n    const currentLineText = textarea.value.slice(currentLineStart, currentLineEnd);\n    const currentLineItem = parseListItem(currentLineText);\n    if (!isNumericListItem(currentLineItem)) return;\n\n    // Strip off the leading newline by adding 1\n    const followingText = textarea.value.slice(currentLineEnd + 1);\n    const followingLines = followingText.split(/\\r?\\n/);\n    const followingNumericListItems = [];\n    let prevItemNumber = currentLineItem.delimeter;\n    for (const line of followingLines) {\n      const listItem = parseListItem(line);\n      if (!isNumericListItem(listItem) || listItem.delimeter !== prevItemNumber) break;\n      followingNumericListItems.push(listItem);\n      prevItemNumber++;\n    }\n    if (followingNumericListItems.length === 0) return;\n\n    // don't forget to re-add the leading newline stripped off earlier\n    const updatedItems = `\\n${followingNumericListItems.map(item => listItemToString({\n      ...item,\n      delimeter: item.delimeter + 1\n    })).join('\\n')}`;\n    emitChange(updatedItems, [currentLineEnd, currentLineEnd + updatedItems.length + 1], textarea.selectionStart);\n  }, [emitChange]);\n  const onKeyDown = useCallback(event => {\n    if (event.key === 'Enter' && !event.shiftKey && !event.defaultPrevented) {\n      const textarea = event.currentTarget;\n      const [activeLineStart, activeLineEnd] = getSelectedLineRange(textarea);\n\n      // current line text without any of the selected text\n      const activeLineValue = textarea.value.slice(activeLineStart, textarea.selectionStart) + textarea.value.slice(textarea.selectionEnd, activeLineEnd);\n      const listItem = parseListItem(activeLineValue);\n      if (!listItem) return; // not currently editing a list - let the browser handle the event\n\n      event.preventDefault();\n      const nextItemStarter = calculateNextListItemStarter(listItem);\n      if (nextItemStarter === null) {\n        emitChange('', [activeLineStart, textarea.selectionEnd]);\n      } else {\n        emitChange(nextItemStarter);\n        // increment following lines as a separate event so the user can separately undo the change\n        incrementFollowingNumericLines(textarea);\n      }\n    }\n  }, [emitChange, incrementFollowingNumericLines]);\n  return {\n    onKeyDown\n  };\n};\n\nexport { listItemRegex, listItemToString, parseListItem, useListEditing };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}