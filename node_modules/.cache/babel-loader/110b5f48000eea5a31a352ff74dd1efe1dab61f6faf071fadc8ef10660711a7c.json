{"ast":null,"code":"import { useFocusZone } from '../hooks/useFocusZone.js';\nimport { getScrollContainer } from '../utils/scroll.js';\nimport { FocusKeys } from '@primer/behaviors';\nfunction useRovingTabIndex({\n  containerRef,\n  mouseDownRef\n}) {\n  // TODO: Initialize focus to the aria-current item if it exists\n  useFocusZone({\n    containerRef,\n    bindKeys: FocusKeys.ArrowVertical | FocusKeys.ArrowHorizontal | FocusKeys.HomeAndEnd | FocusKeys.Backspace | FocusKeys.PageUpDown,\n    preventScroll: true,\n    getNextFocusable: (direction, from, event) => {\n      var _getNextFocusableElem;\n      if (!(from instanceof HTMLElement)) return;\n\n      // Skip elements within a modal dialog\n      // This need to be in a try/catch to avoid errors in\n      // non-supported browsers\n      try {\n        if (from.closest('dialog:modal')) {\n          return;\n        }\n      } catch {\n        // Don't return\n      }\n      return (_getNextFocusableElem = getNextFocusableElement(from, event)) !== null && _getNextFocusableElem !== void 0 ? _getNextFocusableElem : from;\n    },\n    focusInStrategy: () => {\n      var _containerRef$current, _containerRef$current2, _containerRef$current3;\n      // Don't try to execute the focusInStrategy if focus is coming from a click.\n      // The clicked row will receive focus correctly by default.\n      // If a chevron is clicked, setting the focus through the focuszone will prevent its toggle.\n      if (mouseDownRef.current) {\n        return undefined;\n      }\n      const currentItem = (_containerRef$current = containerRef.current) === null || _containerRef$current === void 0 ? void 0 : _containerRef$current.querySelector('[aria-current]');\n      const firstItem = (_containerRef$current2 = containerRef.current) === null || _containerRef$current2 === void 0 ? void 0 : _containerRef$current2.querySelector('[role=\"treeitem\"]');\n\n      // Focus the aria-current item if it exists\n      if (currentItem instanceof HTMLElement) {\n        return currentItem;\n      }\n\n      // Otherwise, focus the activeElement if it's a treeitem\n      if (document.activeElement instanceof HTMLElement && (_containerRef$current3 = containerRef.current) !== null && _containerRef$current3 !== void 0 && _containerRef$current3.contains(document.activeElement)) {\n        return document.activeElement;\n      }\n\n      // Otherwise, focus the first treeitem\n      return firstItem instanceof HTMLElement ? firstItem : undefined;\n    }\n  });\n}\n\n// DOM utilities used for focus management\n\nfunction getNextFocusableElement(activeElement, event) {\n  const elementState = getElementState(activeElement);\n\n  // Reference: https://www.w3.org/WAI/ARIA/apg/patterns/treeview/#keyboard-interaction-24\n  switch (`${elementState} ${event.key}`) {\n    case 'open ArrowRight':\n      // Focus first child node\n      return getFirstChildElement(activeElement);\n    case 'open ArrowLeft':\n      // Close node; don't change focus\n      return;\n    case 'closed ArrowRight':\n      // Open node; don't change focus\n      return;\n    case 'closed ArrowLeft':\n      // Focus parent element\n      return getParentElement(activeElement);\n    case 'end ArrowRight':\n      // Do nothing\n      return;\n    case 'end ArrowLeft':\n      // Focus parent element\n      return getParentElement(activeElement);\n  }\n\n  // ArrowUp, ArrowDown, Home, and End behavior are the same regarless of element state\n  switch (event.key) {\n    case 'ArrowUp':\n      // Focus previous visible element\n      return getVisibleElement(activeElement, 'previous');\n    case 'ArrowDown':\n      // Focus next visible element\n      return getVisibleElement(activeElement, 'next');\n    case 'Backspace':\n      return getParentElement(activeElement);\n    case 'Home':\n      // Focus first visible element\n      return getFirstElement(activeElement);\n    case 'End':\n      // Focus last visible element\n      return getLastElement(activeElement);\n    case 'PageUp':\n      return getPreviousPageElement(activeElement);\n    case 'PageDown':\n      return getNextPageElement(activeElement);\n  }\n}\nfunction getElementState(element) {\n  if (element.getAttribute('role') !== 'treeitem') {\n    throw new Error('Element is not a treeitem');\n  }\n  switch (element.getAttribute('aria-expanded')) {\n    case 'true':\n      return 'open';\n    case 'false':\n      return 'closed';\n    default:\n      return 'end';\n  }\n}\nfunction getVisibleElement(element, direction) {\n  const root = element.closest('[role=tree]');\n  if (!root) return;\n  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, node => {\n    if (!(node instanceof HTMLElement)) return NodeFilter.FILTER_SKIP;\n    return node.getAttribute('role') === 'treeitem' ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n  });\n  let current = walker.firstChild();\n  while (current !== element) {\n    current = walker.nextNode();\n  }\n  let next = direction === 'next' ? walker.nextNode() : walker.previousNode();\n\n  // If next element is nested inside a collapsed subtree, continue iterating\n  while (next instanceof HTMLElement && (_next$parentElement = next.parentElement) !== null && _next$parentElement !== void 0 && _next$parentElement.closest('[role=treeitem][aria-expanded=false]')) {\n    var _next$parentElement;\n    next = direction === 'next' ? walker.nextNode() : walker.previousNode();\n  }\n  return next instanceof HTMLElement ? next : undefined;\n}\nfunction getFirstChildElement(element) {\n  const firstChild = element.querySelector('[role=treeitem]');\n  return firstChild instanceof HTMLElement ? firstChild : undefined;\n}\nfunction getParentElement(element) {\n  const group = element.closest('[role=group]');\n  const parent = group === null || group === void 0 ? void 0 : group.closest('[role=treeitem]');\n  return parent instanceof HTMLElement ? parent : undefined;\n}\nfunction getFirstElement(element) {\n  const root = element.closest('[role=tree]');\n  const first = root === null || root === void 0 ? void 0 : root.querySelector('[role=treeitem]');\n  return first instanceof HTMLElement ? first : undefined;\n}\nfunction getLastElement(element) {\n  const root = element.closest('[role=tree]');\n  const items = Array.from((root === null || root === void 0 ? void 0 : root.querySelectorAll('[role=treeitem]')) || []);\n\n  // If there are no items, return undefined\n  if (items.length === 0) return;\n  let index = items.length - 1;\n  let last = items[index];\n\n  // If last element is nested inside a collapsed subtree, continue iterating\n  while (index > 0 && last instanceof HTMLElement && (_last$parentElement = last.parentElement) !== null && _last$parentElement !== void 0 && _last$parentElement.closest('[role=treeitem][aria-expanded=false]')) {\n    var _last$parentElement;\n    index -= 1;\n    last = items[index];\n  }\n  return last instanceof HTMLElement ? last : undefined;\n}\nconst defaultSize = {\n  height: 32\n};\n\n/**\n * Determine the page size for the given tree based on an item in the tree. We\n * estimate this size by trying to see how many items will fit in the given\n * tree. If the tree is within a scroll container, we will use the height of\n * that container. Otherwise, we'll use the current window height\n */\nfunction getPageSize(root, item) {\n  var _item$getBoundingClie, _scrollContainer$clie;\n  const scrollContainer = getScrollContainer(root);\n  const {\n    height: itemHeight\n  } = (_item$getBoundingClie = item === null || item === void 0 ? void 0 : item.getBoundingClientRect()) !== null && _item$getBoundingClie !== void 0 ? _item$getBoundingClie : defaultSize;\n  const availableHeight = (_scrollContainer$clie = scrollContainer === null || scrollContainer === void 0 ? void 0 : scrollContainer.clientHeight) !== null && _scrollContainer$clie !== void 0 ? _scrollContainer$clie : window.innerHeight;\n  return Math.floor(availableHeight / itemHeight);\n}\nfunction getNextPageElement(element) {\n  const root = element.closest('[role=\"tree\"]');\n  if (!root) {\n    return;\n  }\n  const items = Array.from(root.querySelectorAll('[role=\"treeitem\"]'));\n  if (items.length === 0) {\n    return;\n  }\n  const itemLabel = items[0].firstElementChild;\n  const pageSize = getPageSize(root, itemLabel);\n  const page = Math.floor(items.indexOf(element) / pageSize);\n  const offset = items.indexOf(element) - pageSize * page;\n  return items[Math.min(items.length - 1, (page + 1) * pageSize + offset)];\n}\nfunction getPreviousPageElement(element) {\n  const root = element.closest('[role=\"tree\"]');\n  if (!root) {\n    return;\n  }\n  const items = Array.from(root.querySelectorAll('[role=\"treeitem\"]'));\n  if (items.length === 0) {\n    return;\n  }\n  const itemLabel = items[0].firstElementChild;\n  const pageSize = getPageSize(root, itemLabel);\n  const page = Math.floor(items.indexOf(element) / pageSize);\n  const offset = items.indexOf(element) - pageSize * page;\n  return items[Math.max(0, (page - 1) * pageSize + offset)];\n}\nexport { getElementState, getFirstChildElement, getFirstElement, getLastElement, getNextFocusableElement, getParentElement, getVisibleElement, useRovingTabIndex };","map":{"version":3,"names":["useFocusZone","getScrollContainer","FocusKeys","useRovingTabIndex","containerRef","mouseDownRef","bindKeys","ArrowVertical","ArrowHorizontal","HomeAndEnd","Backspace","PageUpDown","preventScroll","getNextFocusable","direction","from","event","_getNextFocusableElem","HTMLElement","closest","getNextFocusableElement","focusInStrategy","_containerRef$current","_containerRef$current2","_containerRef$current3","current","undefined","currentItem","querySelector","firstItem","document","activeElement","contains","elementState","getElementState","key","getFirstChildElement","getParentElement","getVisibleElement","getFirstElement","getLastElement","getPreviousPageElement","getNextPageElement","element","getAttribute","Error","root","walker","createTreeWalker","NodeFilter","SHOW_ELEMENT","node","FILTER_SKIP","FILTER_ACCEPT","firstChild","nextNode","next","previousNode","_next$parentElement","parentElement","group","parent","first","items","Array","querySelectorAll","length","index","last","_last$parentElement","defaultSize","height","getPageSize","item","_item$getBoundingClie","_scrollContainer$clie","scrollContainer","itemHeight","getBoundingClientRect","availableHeight","clientHeight","window","innerHeight","Math","floor","itemLabel","firstElementChild","pageSize","page","indexOf","offset","min","max"],"sources":["/Users/steve/Documents/repos/github/licensing-report/node_modules/@primer/react/lib-esm/TreeView/useRovingTabIndex.js"],"sourcesContent":["import { useFocusZone } from '../hooks/useFocusZone.js';\nimport { getScrollContainer } from '../utils/scroll.js';\nimport { FocusKeys } from '@primer/behaviors';\n\nfunction useRovingTabIndex({\n  containerRef,\n  mouseDownRef\n}) {\n  // TODO: Initialize focus to the aria-current item if it exists\n  useFocusZone({\n    containerRef,\n    bindKeys: FocusKeys.ArrowVertical | FocusKeys.ArrowHorizontal | FocusKeys.HomeAndEnd | FocusKeys.Backspace | FocusKeys.PageUpDown,\n    preventScroll: true,\n    getNextFocusable: (direction, from, event) => {\n      var _getNextFocusableElem;\n      if (!(from instanceof HTMLElement)) return;\n\n      // Skip elements within a modal dialog\n      // This need to be in a try/catch to avoid errors in\n      // non-supported browsers\n      try {\n        if (from.closest('dialog:modal')) {\n          return;\n        }\n      } catch {\n        // Don't return\n      }\n      return (_getNextFocusableElem = getNextFocusableElement(from, event)) !== null && _getNextFocusableElem !== void 0 ? _getNextFocusableElem : from;\n    },\n    focusInStrategy: () => {\n      var _containerRef$current, _containerRef$current2, _containerRef$current3;\n      // Don't try to execute the focusInStrategy if focus is coming from a click.\n      // The clicked row will receive focus correctly by default.\n      // If a chevron is clicked, setting the focus through the focuszone will prevent its toggle.\n      if (mouseDownRef.current) {\n        return undefined;\n      }\n      const currentItem = (_containerRef$current = containerRef.current) === null || _containerRef$current === void 0 ? void 0 : _containerRef$current.querySelector('[aria-current]');\n      const firstItem = (_containerRef$current2 = containerRef.current) === null || _containerRef$current2 === void 0 ? void 0 : _containerRef$current2.querySelector('[role=\"treeitem\"]');\n\n      // Focus the aria-current item if it exists\n      if (currentItem instanceof HTMLElement) {\n        return currentItem;\n      }\n\n      // Otherwise, focus the activeElement if it's a treeitem\n      if (document.activeElement instanceof HTMLElement && (_containerRef$current3 = containerRef.current) !== null && _containerRef$current3 !== void 0 && _containerRef$current3.contains(document.activeElement)) {\n        return document.activeElement;\n      }\n\n      // Otherwise, focus the first treeitem\n      return firstItem instanceof HTMLElement ? firstItem : undefined;\n    }\n  });\n}\n\n// DOM utilities used for focus management\n\nfunction getNextFocusableElement(activeElement, event) {\n  const elementState = getElementState(activeElement);\n\n  // Reference: https://www.w3.org/WAI/ARIA/apg/patterns/treeview/#keyboard-interaction-24\n  switch (`${elementState} ${event.key}`) {\n    case 'open ArrowRight':\n      // Focus first child node\n      return getFirstChildElement(activeElement);\n    case 'open ArrowLeft':\n      // Close node; don't change focus\n      return;\n    case 'closed ArrowRight':\n      // Open node; don't change focus\n      return;\n    case 'closed ArrowLeft':\n      // Focus parent element\n      return getParentElement(activeElement);\n    case 'end ArrowRight':\n      // Do nothing\n      return;\n    case 'end ArrowLeft':\n      // Focus parent element\n      return getParentElement(activeElement);\n  }\n\n  // ArrowUp, ArrowDown, Home, and End behavior are the same regarless of element state\n  switch (event.key) {\n    case 'ArrowUp':\n      // Focus previous visible element\n      return getVisibleElement(activeElement, 'previous');\n    case 'ArrowDown':\n      // Focus next visible element\n      return getVisibleElement(activeElement, 'next');\n    case 'Backspace':\n      return getParentElement(activeElement);\n    case 'Home':\n      // Focus first visible element\n      return getFirstElement(activeElement);\n    case 'End':\n      // Focus last visible element\n      return getLastElement(activeElement);\n    case 'PageUp':\n      return getPreviousPageElement(activeElement);\n    case 'PageDown':\n      return getNextPageElement(activeElement);\n  }\n}\nfunction getElementState(element) {\n  if (element.getAttribute('role') !== 'treeitem') {\n    throw new Error('Element is not a treeitem');\n  }\n  switch (element.getAttribute('aria-expanded')) {\n    case 'true':\n      return 'open';\n    case 'false':\n      return 'closed';\n    default:\n      return 'end';\n  }\n}\nfunction getVisibleElement(element, direction) {\n  const root = element.closest('[role=tree]');\n  if (!root) return;\n  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, node => {\n    if (!(node instanceof HTMLElement)) return NodeFilter.FILTER_SKIP;\n    return node.getAttribute('role') === 'treeitem' ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n  });\n  let current = walker.firstChild();\n  while (current !== element) {\n    current = walker.nextNode();\n  }\n  let next = direction === 'next' ? walker.nextNode() : walker.previousNode();\n\n  // If next element is nested inside a collapsed subtree, continue iterating\n  while (next instanceof HTMLElement && (_next$parentElement = next.parentElement) !== null && _next$parentElement !== void 0 && _next$parentElement.closest('[role=treeitem][aria-expanded=false]')) {\n    var _next$parentElement;\n    next = direction === 'next' ? walker.nextNode() : walker.previousNode();\n  }\n  return next instanceof HTMLElement ? next : undefined;\n}\nfunction getFirstChildElement(element) {\n  const firstChild = element.querySelector('[role=treeitem]');\n  return firstChild instanceof HTMLElement ? firstChild : undefined;\n}\nfunction getParentElement(element) {\n  const group = element.closest('[role=group]');\n  const parent = group === null || group === void 0 ? void 0 : group.closest('[role=treeitem]');\n  return parent instanceof HTMLElement ? parent : undefined;\n}\nfunction getFirstElement(element) {\n  const root = element.closest('[role=tree]');\n  const first = root === null || root === void 0 ? void 0 : root.querySelector('[role=treeitem]');\n  return first instanceof HTMLElement ? first : undefined;\n}\nfunction getLastElement(element) {\n  const root = element.closest('[role=tree]');\n  const items = Array.from((root === null || root === void 0 ? void 0 : root.querySelectorAll('[role=treeitem]')) || []);\n\n  // If there are no items, return undefined\n  if (items.length === 0) return;\n  let index = items.length - 1;\n  let last = items[index];\n\n  // If last element is nested inside a collapsed subtree, continue iterating\n  while (index > 0 && last instanceof HTMLElement && (_last$parentElement = last.parentElement) !== null && _last$parentElement !== void 0 && _last$parentElement.closest('[role=treeitem][aria-expanded=false]')) {\n    var _last$parentElement;\n    index -= 1;\n    last = items[index];\n  }\n  return last instanceof HTMLElement ? last : undefined;\n}\nconst defaultSize = {\n  height: 32\n};\n\n/**\n * Determine the page size for the given tree based on an item in the tree. We\n * estimate this size by trying to see how many items will fit in the given\n * tree. If the tree is within a scroll container, we will use the height of\n * that container. Otherwise, we'll use the current window height\n */\nfunction getPageSize(root, item) {\n  var _item$getBoundingClie, _scrollContainer$clie;\n  const scrollContainer = getScrollContainer(root);\n  const {\n    height: itemHeight\n  } = (_item$getBoundingClie = item === null || item === void 0 ? void 0 : item.getBoundingClientRect()) !== null && _item$getBoundingClie !== void 0 ? _item$getBoundingClie : defaultSize;\n  const availableHeight = (_scrollContainer$clie = scrollContainer === null || scrollContainer === void 0 ? void 0 : scrollContainer.clientHeight) !== null && _scrollContainer$clie !== void 0 ? _scrollContainer$clie : window.innerHeight;\n  return Math.floor(availableHeight / itemHeight);\n}\nfunction getNextPageElement(element) {\n  const root = element.closest('[role=\"tree\"]');\n  if (!root) {\n    return;\n  }\n  const items = Array.from(root.querySelectorAll('[role=\"treeitem\"]'));\n  if (items.length === 0) {\n    return;\n  }\n  const itemLabel = items[0].firstElementChild;\n  const pageSize = getPageSize(root, itemLabel);\n  const page = Math.floor(items.indexOf(element) / pageSize);\n  const offset = items.indexOf(element) - pageSize * page;\n  return items[Math.min(items.length - 1, (page + 1) * pageSize + offset)];\n}\nfunction getPreviousPageElement(element) {\n  const root = element.closest('[role=\"tree\"]');\n  if (!root) {\n    return;\n  }\n  const items = Array.from(root.querySelectorAll('[role=\"treeitem\"]'));\n  if (items.length === 0) {\n    return;\n  }\n  const itemLabel = items[0].firstElementChild;\n  const pageSize = getPageSize(root, itemLabel);\n  const page = Math.floor(items.indexOf(element) / pageSize);\n  const offset = items.indexOf(element) - pageSize * page;\n  return items[Math.max(0, (page - 1) * pageSize + offset)];\n}\n\nexport { getElementState, getFirstChildElement, getFirstElement, getLastElement, getNextFocusableElement, getParentElement, getVisibleElement, useRovingTabIndex };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}