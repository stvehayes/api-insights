{"ast":null,"code":"// The directions in which a column can be sorted\n// Note: if a table is sorted, one column _must_ have a direction other than\n// NONE\n\n// A mapping of names to SortDirection\nconst SortDirection = {\n  ASC: 'ASC',\n  DESC: 'DESC',\n  NONE: 'NONE'\n};\n\n// The default sort direction for a column going from NONE to sorted\nconst DEFAULT_SORT_DIRECTION = SortDirection.ASC;\n\n// Transition the given sort direction to the next direction\n// Note: we can only cycle between ASC <-> DESC, NONE is not supported\nfunction transition(direction) {\n  if (direction === SortDirection.ASC) {\n    return SortDirection.DESC;\n  }\n  return SortDirection.ASC;\n}\n\n// ----------------------------------------------------------------------------\n// Sort strategies\n// ----------------------------------------------------------------------------\n\n/**\n * A sort strategy for comparing any two values\n */\nfunction basic(a, b) {\n  return a === b ? 0 : a < b ? -1 : 1;\n}\n\n/**\n * A sort strategy for comparing two `Date` values. Also includes support for\n * values from `Date.now()`\n */\nfunction datetime(a, b) {\n  const timeA = a instanceof Date ? a.getTime() : a;\n  const timeB = b instanceof Date ? b.getTime() : b;\n  return timeA > timeB ? 1 : timeA < timeB ? -1 : 0;\n}\n\n/**\n * Compare two numbers using alphanumeric, or natural order, sorting. This\n * sorting function breaks up the inputs into groups of text and numbers and\n * compares the different sub-groups of each to determine the order of a set of\n * strings\n *\n * @see https://en.wikipedia.org/wiki/Natural_sort_order\n */\nfunction alphanumeric(inputA, inputB) {\n  const groupsA = getAlphaNumericGroups(inputA);\n  const groupsB = getAlphaNumericGroups(inputB);\n  while (groupsA.length !== 0 && groupsB.length !== 0) {\n    const a = groupsA.shift();\n    const b = groupsB.shift();\n\n    // If the two groups are equal, move on to the next set of groups\n    if (a === b) {\n      continue;\n    } else if (typeof a === 'string' && typeof b === 'string') {\n      // If both groups are strings, compare them using the current locale\n      return a.localeCompare(b);\n    } else if (typeof a === 'number' && typeof b === 'number') {\n      // If both groups are numbers, compare them numerically\n      return a > b ? 1 : -1;\n    } else if (typeof a === 'number' && typeof b === 'string') {\n      // Sort numbers before strings\n      return -1;\n    } else if (typeof a === 'string' && typeof b === 'number') {\n      // Sort numbers before strings\n      return 1;\n    } else if (a === undefined || b === undefined) {\n      // If either group is undefined, break out of the loop. The input with the\n      // fewest number of groups will be ordered first\n      break;\n    }\n  }\n\n  // If all else is equal, the string with the fewest number of \"groups\" is\n  // ordered before the other string\n  return groupsA.length > groupsB.length ? 1 : -1;\n}\n\n/**\n * Break up the given input string into groups of text and numbers\n */\nfunction getAlphaNumericGroups(input) {\n  const groups = [];\n  let i = 0;\n  while (i < input.length) {\n    let group = input[i];\n    if (isNumeric(group)) {\n      while (i + 1 < input.length && isNumeric(input[i + 1])) {\n        group = group + input[i + 1];\n        i++;\n      }\n      groups.push(parseInt(group, 10));\n    } else {\n      while (i + 1 < input.length && !isNumeric(input[i + 1])) {\n        group = group + input[i + 1];\n        i++;\n      }\n      groups.push(group);\n    }\n    i++;\n  }\n  return groups;\n}\n\n/**\n * Determine if the given value is a number\n */\nfunction isNumeric(value) {\n  return !Number.isNaN(parseInt(value, 10));\n}\nconst strategies = {\n  alphanumeric,\n  basic,\n  datetime\n};\nexport { DEFAULT_SORT_DIRECTION, SortDirection, alphanumeric, basic, datetime, strategies, transition };","map":{"version":3,"names":["SortDirection","ASC","DESC","NONE","DEFAULT_SORT_DIRECTION","transition","direction","basic","a","b","datetime","timeA","Date","getTime","timeB","alphanumeric","inputA","inputB","groupsA","getAlphaNumericGroups","groupsB","length","shift","localeCompare","undefined","input","groups","i","group","isNumeric","push","parseInt","value","Number","isNaN","strategies"],"sources":["/Users/steve/Documents/repos/github/api-insights/node_modules/@primer/react/lib-esm/DataTable/sorting.js"],"sourcesContent":["// The directions in which a column can be sorted\n// Note: if a table is sorted, one column _must_ have a direction other than\n// NONE\n\n// A mapping of names to SortDirection\nconst SortDirection = {\n  ASC: 'ASC',\n  DESC: 'DESC',\n  NONE: 'NONE'\n};\n\n// The default sort direction for a column going from NONE to sorted\nconst DEFAULT_SORT_DIRECTION = SortDirection.ASC;\n\n// Transition the given sort direction to the next direction\n// Note: we can only cycle between ASC <-> DESC, NONE is not supported\nfunction transition(direction) {\n  if (direction === SortDirection.ASC) {\n    return SortDirection.DESC;\n  }\n  return SortDirection.ASC;\n}\n\n// ----------------------------------------------------------------------------\n// Sort strategies\n// ----------------------------------------------------------------------------\n\n/**\n * A sort strategy for comparing any two values\n */\nfunction basic(a, b) {\n  return a === b ? 0 : a < b ? -1 : 1;\n}\n\n/**\n * A sort strategy for comparing two `Date` values. Also includes support for\n * values from `Date.now()`\n */\nfunction datetime(a, b) {\n  const timeA = a instanceof Date ? a.getTime() : a;\n  const timeB = b instanceof Date ? b.getTime() : b;\n  return timeA > timeB ? 1 : timeA < timeB ? -1 : 0;\n}\n\n/**\n * Compare two numbers using alphanumeric, or natural order, sorting. This\n * sorting function breaks up the inputs into groups of text and numbers and\n * compares the different sub-groups of each to determine the order of a set of\n * strings\n *\n * @see https://en.wikipedia.org/wiki/Natural_sort_order\n */\nfunction alphanumeric(inputA, inputB) {\n  const groupsA = getAlphaNumericGroups(inputA);\n  const groupsB = getAlphaNumericGroups(inputB);\n  while (groupsA.length !== 0 && groupsB.length !== 0) {\n    const a = groupsA.shift();\n    const b = groupsB.shift();\n\n    // If the two groups are equal, move on to the next set of groups\n    if (a === b) {\n      continue;\n    } else if (typeof a === 'string' && typeof b === 'string') {\n      // If both groups are strings, compare them using the current locale\n      return a.localeCompare(b);\n    } else if (typeof a === 'number' && typeof b === 'number') {\n      // If both groups are numbers, compare them numerically\n      return a > b ? 1 : -1;\n    } else if (typeof a === 'number' && typeof b === 'string') {\n      // Sort numbers before strings\n      return -1;\n    } else if (typeof a === 'string' && typeof b === 'number') {\n      // Sort numbers before strings\n      return 1;\n    } else if (a === undefined || b === undefined) {\n      // If either group is undefined, break out of the loop. The input with the\n      // fewest number of groups will be ordered first\n      break;\n    }\n  }\n\n  // If all else is equal, the string with the fewest number of \"groups\" is\n  // ordered before the other string\n  return groupsA.length > groupsB.length ? 1 : -1;\n}\n\n/**\n * Break up the given input string into groups of text and numbers\n */\nfunction getAlphaNumericGroups(input) {\n  const groups = [];\n  let i = 0;\n  while (i < input.length) {\n    let group = input[i];\n    if (isNumeric(group)) {\n      while (i + 1 < input.length && isNumeric(input[i + 1])) {\n        group = group + input[i + 1];\n        i++;\n      }\n      groups.push(parseInt(group, 10));\n    } else {\n      while (i + 1 < input.length && !isNumeric(input[i + 1])) {\n        group = group + input[i + 1];\n        i++;\n      }\n      groups.push(group);\n    }\n    i++;\n  }\n  return groups;\n}\n\n/**\n * Determine if the given value is a number\n */\nfunction isNumeric(value) {\n  return !Number.isNaN(parseInt(value, 10));\n}\nconst strategies = {\n  alphanumeric,\n  basic,\n  datetime\n};\n\nexport { DEFAULT_SORT_DIRECTION, SortDirection, alphanumeric, basic, datetime, strategies, transition };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}