{"ast":null,"code":"import { FocusKeys } from '@primer/behaviors';\nimport { isFocusable } from '@primer/behaviors/utils';\nimport { omit } from '@styled-system/props';\nimport React, { useRef, useState } from 'react';\nimport { isValidElementType } from 'react-is';\nimport Box from '../Box/Box.js';\nimport { useRefObjectAsForwardedRef } from '../hooks/useRefObjectAsForwardedRef.js';\nimport { useFocusZone } from '../hooks/useFocusZone.js';\nimport Text from '../Text/Text.js';\nimport Token from '../Token/Token.js';\nimport TextInputWrapper, { textInputHorizPadding } from '../internal/components/TextInputWrapper.js';\nimport UnstyledTextInput from '../internal/components/UnstyledTextInput.js';\nimport TextInputInnerVisualSlot from '../internal/components/TextInputInnerVisualSlot.js';\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n// NOTE: if these props or their JSDoc comments are updated, be sure to also update\n// the prop table in docs/content/TextInputTokens.mdx\n\nconst overflowCountFontSizeMap = {\n  small: 0,\n  medium: 1,\n  large: 1,\n  xlarge: 2\n};\n\n// using forwardRef is important so that other components (ex. Autocomplete) can use the ref\nfunction TextInputWithTokensInnerComponent({\n  icon: IconComponent,\n  leadingVisual: LeadingVisual,\n  trailingVisual: TrailingVisual,\n  loading,\n  loaderPosition = 'auto',\n  contrast,\n  className,\n  block,\n  disabled,\n  sx: sxProp,\n  tokens,\n  onTokenRemove,\n  tokenComponent: TokenComponent = Token,\n  preventTokenWrapping = false,\n  size = 'xlarge',\n  hideTokenRemoveButtons = false,\n  maxHeight,\n  width: widthProp,\n  minWidth: minWidthProp,\n  maxWidth: maxWidthProp,\n  validationStatus,\n  variant: variantProp,\n  // deprecated. use `size` instead\n  visibleTokenCount,\n  ...rest\n}, forwardedRef) {\n  const {\n    onBlur,\n    onFocus,\n    onKeyDown,\n    ...inputPropsRest\n  } = omit(rest);\n  const ref = useRef(null);\n  useRefObjectAsForwardedRef(forwardedRef, ref);\n  const [selectedTokenIndex, setSelectedTokenIndex] = useState();\n  const [tokensAreTruncated, setTokensAreTruncated] = useState(Boolean(visibleTokenCount));\n  const {\n    containerRef\n  } = useFocusZone({\n    focusOutBehavior: 'wrap',\n    bindKeys: FocusKeys.ArrowHorizontal | FocusKeys.HomeAndEnd,\n    focusableElementFilter: element => {\n      return !element.getAttributeNames().includes('aria-hidden');\n    },\n    getNextFocusable: direction => {\n      var _containerRef$current;\n      if (!selectedTokenIndex && selectedTokenIndex !== 0) {\n        return undefined;\n      }\n      let nextIndex = selectedTokenIndex + 1; // \"+ 1\" accounts for the first element: the text input\n\n      if (direction === 'next') {\n        nextIndex += 1;\n      }\n      if (direction === 'previous') {\n        nextIndex -= 1;\n      }\n      if (nextIndex > tokens.length || nextIndex < 1) {\n        return ref.current || undefined;\n      }\n      return (_containerRef$current = containerRef.current) === null || _containerRef$current === void 0 ? void 0 : _containerRef$current.children[nextIndex];\n    }\n  }, [selectedTokenIndex]);\n  const handleTokenRemove = tokenId => {\n    onTokenRemove(tokenId);\n\n    // HACK: wait a tick for the token node to be removed from the DOM\n    setTimeout(() => {\n      var _containerRef$current2, _containerRef$current3;\n      const nextElementToFocus = (_containerRef$current2 = containerRef.current) === null || _containerRef$current2 === void 0 ? void 0 : _containerRef$current2.children[selectedTokenIndex || 0];\n\n      // when removing the first token by keying \"Backspace\" or \"Delete\",\n      // `nextFocusableElement` is the div that wraps the input\n      const firstFocusable = nextElementToFocus && isFocusable(nextElementToFocus) ? nextElementToFocus : Array.from(((_containerRef$current3 = containerRef.current) === null || _containerRef$current3 === void 0 ? void 0 : _containerRef$current3.children) || []).find(el => isFocusable(el));\n      if (firstFocusable) {\n        firstFocusable.focus();\n      } else {\n        var _ref$current;\n        // if there are no tokens left, focus the input\n        (_ref$current = ref.current) === null || _ref$current === void 0 ? void 0 : _ref$current.focus();\n      }\n    }, 0);\n  };\n  const handleTokenFocus = tokenIndex => () => {\n    if (!disabled) setSelectedTokenIndex(tokenIndex);\n  };\n  const handleTokenBlur = () => {\n    setSelectedTokenIndex(undefined);\n\n    // HACK: wait a tick and check the focused element before hiding truncated tokens\n    // this prevents the tokens from hiding when the user is moving focus between tokens,\n    // but still hides the tokens when the user blurs the token by tabbing out or clicking somewhere else on the page\n    setTimeout(() => {\n      var _containerRef$current4;\n      if (!((_containerRef$current4 = containerRef.current) !== null && _containerRef$current4 !== void 0 && _containerRef$current4.contains(document.activeElement)) && visibleTokenCount) {\n        setTokensAreTruncated(true);\n      }\n    }, 0);\n  };\n  const handleTokenKeyUp = event => {\n    if (event.key === 'Escape') {\n      var _ref$current2;\n      (_ref$current2 = ref.current) === null || _ref$current2 === void 0 ? void 0 : _ref$current2.focus();\n    }\n  };\n  const handleInputFocus = event => {\n    onFocus && onFocus(event);\n    setSelectedTokenIndex(undefined);\n    visibleTokenCount && setTokensAreTruncated(false);\n  };\n  const handleInputBlur = event => {\n    onBlur && onBlur(event);\n\n    // HACK: wait a tick and check the focused element before hiding truncated tokens\n    // this prevents the tokens from hiding when the user is moving focus from the input to a token,\n    // but still hides the tokens when the user blurs the input by tabbing out or clicking somewhere else on the page\n    setTimeout(() => {\n      var _containerRef$current5;\n      if (!((_containerRef$current5 = containerRef.current) !== null && _containerRef$current5 !== void 0 && _containerRef$current5.contains(document.activeElement)) && visibleTokenCount) {\n        setTokensAreTruncated(true);\n      }\n    }, 0);\n  };\n  const handleInputKeyDown = e => {\n    var _ref$current3;\n    if (onKeyDown) {\n      onKeyDown(e);\n    }\n    if ((_ref$current3 = ref.current) !== null && _ref$current3 !== void 0 && _ref$current3.value) {\n      return;\n    }\n    const lastToken = tokens[tokens.length - 1];\n    if (e.key === 'Backspace' && lastToken) {\n      handleTokenRemove(lastToken.id);\n      if (ref.current) {\n        // TODO: eliminate the first hack by making changes to the Autocomplete component\n        //\n        // HACKS:\n        // 1. Directly setting `ref.current.value` instead of updating state because the autocomplete\n        //    highlight behavior doesn't work correctly if we update the value with a setState action in onChange\n        // 2. Adding an extra space so that when I backspace, it doesn't delete the last letter\n        ref.current.value = `${lastToken.text} `;\n      }\n\n      // HACK: for some reason we need to wait a tick for `.select()` to work\n      setTimeout(() => {\n        var _ref$current4;\n        (_ref$current4 = ref.current) === null || _ref$current4 === void 0 ? void 0 : _ref$current4.select();\n      }, 0);\n    }\n  };\n  const focusInput = () => {\n    var _ref$current5;\n    (_ref$current5 = ref.current) === null || _ref$current5 === void 0 ? void 0 : _ref$current5.focus();\n  };\n  const preventTokenClickPropagation = event => {\n    event.stopPropagation();\n  };\n  const visibleTokens = tokensAreTruncated ? tokens.slice(0, visibleTokenCount) : tokens;\n  const inputSizeMap = {\n    small: 'small',\n    medium: 'small',\n    large: 'medium',\n    xlarge: 'medium'\n  };\n  const showLeadingLoadingIndicator = loading && (loaderPosition === 'leading' || Boolean(LeadingVisual && loaderPosition !== 'trailing'));\n  const showTrailingLoadingIndicator = loading && (loaderPosition === 'trailing' || loaderPosition === 'auto' && !LeadingVisual);\n  return /*#__PURE__*/React.createElement(TextInputWrapper, {\n    block: block,\n    className: className,\n    contrast: contrast,\n    disabled: disabled,\n    hasLeadingVisual: Boolean(LeadingVisual || showLeadingLoadingIndicator),\n    hasTrailingVisual: Boolean(TrailingVisual || showTrailingLoadingIndicator),\n    width: widthProp,\n    minWidth: minWidthProp,\n    maxWidth: maxWidthProp,\n    size: inputSizeMap[size],\n    validationStatus: validationStatus,\n    variant: variantProp // deprecated. use `size` prop instead\n    ,\n\n    onClick: focusInput,\n    sx: {\n      paddingLeft: textInputHorizPadding,\n      py: `calc(${textInputHorizPadding} / 2)`,\n      ...(block ? {\n        display: 'flex',\n        width: '100%'\n      } : {}),\n      ...(maxHeight ? {\n        maxHeight,\n        overflow: 'auto'\n      } : {}),\n      ...(preventTokenWrapping ? {\n        overflow: 'auto'\n      } : {}),\n      ...sxProp\n    }\n  }, IconComponent && !LeadingVisual && /*#__PURE__*/React.createElement(IconComponent, {\n    className: \"TextInput-icon\"\n  }), /*#__PURE__*/React.createElement(TextInputInnerVisualSlot, {\n    hasLoadingIndicator: typeof loading === 'boolean',\n    visualPosition: \"leading\",\n    showLoadingIndicator: showLeadingLoadingIndicator\n  }, typeof LeadingVisual !== 'string' && isValidElementType(LeadingVisual) ? /*#__PURE__*/React.createElement(LeadingVisual, null) : LeadingVisual), /*#__PURE__*/React.createElement(Box, {\n    ref: containerRef,\n    display: \"flex\",\n    sx: {\n      alignItems: 'center',\n      flexWrap: preventTokenWrapping ? 'nowrap' : 'wrap',\n      marginLeft: '-0.25rem',\n      marginBottom: '-0.25rem',\n      flexGrow: 1,\n      '> *': {\n        flexShrink: 0,\n        marginLeft: '0.25rem',\n        marginBottom: '0.25rem'\n      }\n    }\n  }, /*#__PURE__*/React.createElement(Box, {\n    sx: {\n      order: 1,\n      flexGrow: 1\n    }\n  }, /*#__PURE__*/React.createElement(UnstyledTextInput, _extends({\n    ref: ref,\n    disabled: disabled,\n    onFocus: handleInputFocus,\n    onBlur: handleInputBlur,\n    onKeyDown: handleInputKeyDown,\n    type: \"text\",\n    sx: {\n      height: '100%'\n    },\n    \"aria-invalid\": validationStatus === 'error' ? 'true' : 'false'\n  }, inputPropsRest))), visibleTokens.map(({\n    id,\n    ...tokenRest\n  }, i) => /*#__PURE__*/React.createElement(TokenComponent, _extends({\n    disabled: disabled,\n    key: id,\n    onFocus: handleTokenFocus(i),\n    onBlur: handleTokenBlur,\n    onKeyUp: handleTokenKeyUp,\n    onClick: preventTokenClickPropagation,\n    isSelected: selectedTokenIndex === i,\n    onRemove: () => {\n      handleTokenRemove(id);\n    },\n    hideRemoveButton: disabled || hideTokenRemoveButtons,\n    size: size,\n    tabIndex: 0\n  }, tokenRest))), tokensAreTruncated && tokens.length - visibleTokens.length ? /*#__PURE__*/React.createElement(Text, {\n    color: \"fg.muted\",\n    fontSize: overflowCountFontSizeMap[size]\n  }, \"+\", tokens.length - visibleTokens.length) : null), /*#__PURE__*/React.createElement(TextInputInnerVisualSlot, {\n    hasLoadingIndicator: typeof loading === 'boolean',\n    visualPosition: \"trailing\",\n    showLoadingIndicator: showTrailingLoadingIndicator\n  }, typeof TrailingVisual !== 'string' && isValidElementType(TrailingVisual) ? /*#__PURE__*/React.createElement(TrailingVisual, null) : TrailingVisual));\n}\nTextInputWithTokensInnerComponent.displayName = \"TextInputWithTokensInnerComponent\";\nconst TextInputWithTokens = /*#__PURE__*/React.forwardRef(TextInputWithTokensInnerComponent);\nTextInputWithTokens.displayName = 'TextInputWithTokens';\nexport { TextInputWithTokens as default };","map":{"version":3,"names":["FocusKeys","isFocusable","omit","React","useRef","useState","isValidElementType","Box","useRefObjectAsForwardedRef","useFocusZone","Text","Token","TextInputWrapper","textInputHorizPadding","UnstyledTextInput","TextInputInnerVisualSlot","_extends","Object","assign","bind","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","overflowCountFontSizeMap","small","medium","large","xlarge","TextInputWithTokensInnerComponent","icon","IconComponent","leadingVisual","LeadingVisual","trailingVisual","TrailingVisual","loading","loaderPosition","contrast","className","block","disabled","sx","sxProp","tokens","onTokenRemove","tokenComponent","TokenComponent","preventTokenWrapping","size","hideTokenRemoveButtons","maxHeight","width","widthProp","minWidth","minWidthProp","maxWidth","maxWidthProp","validationStatus","variant","variantProp","visibleTokenCount","rest","forwardedRef","onBlur","onFocus","onKeyDown","inputPropsRest","ref","selectedTokenIndex","setSelectedTokenIndex","tokensAreTruncated","setTokensAreTruncated","Boolean","containerRef","focusOutBehavior","bindKeys","ArrowHorizontal","HomeAndEnd","focusableElementFilter","element","getAttributeNames","includes","getNextFocusable","direction","_containerRef$current","undefined","nextIndex","current","children","handleTokenRemove","tokenId","setTimeout","_containerRef$current2","_containerRef$current3","nextElementToFocus","firstFocusable","Array","from","find","el","focus","_ref$current","handleTokenFocus","tokenIndex","handleTokenBlur","_containerRef$current4","contains","document","activeElement","handleTokenKeyUp","event","_ref$current2","handleInputFocus","handleInputBlur","_containerRef$current5","handleInputKeyDown","e","_ref$current3","value","lastToken","id","text","_ref$current4","select","focusInput","_ref$current5","preventTokenClickPropagation","stopPropagation","visibleTokens","slice","inputSizeMap","showLeadingLoadingIndicator","showTrailingLoadingIndicator","createElement","hasLeadingVisual","hasTrailingVisual","onClick","paddingLeft","py","display","overflow","hasLoadingIndicator","visualPosition","showLoadingIndicator","alignItems","flexWrap","marginLeft","marginBottom","flexGrow","flexShrink","order","type","height","map","tokenRest","onKeyUp","isSelected","onRemove","hideRemoveButton","tabIndex","color","fontSize","displayName","TextInputWithTokens","forwardRef","default"],"sources":["/Users/steve/Documents/repos/github/licensing-report/node_modules/@primer/react/lib-esm/TextInputWithTokens/TextInputWithTokens.js"],"sourcesContent":["import { FocusKeys } from '@primer/behaviors';\nimport { isFocusable } from '@primer/behaviors/utils';\nimport { omit } from '@styled-system/props';\nimport React, { useRef, useState } from 'react';\nimport { isValidElementType } from 'react-is';\nimport Box from '../Box/Box.js';\nimport { useRefObjectAsForwardedRef } from '../hooks/useRefObjectAsForwardedRef.js';\nimport { useFocusZone } from '../hooks/useFocusZone.js';\nimport Text from '../Text/Text.js';\nimport Token from '../Token/Token.js';\nimport TextInputWrapper, { textInputHorizPadding } from '../internal/components/TextInputWrapper.js';\nimport UnstyledTextInput from '../internal/components/UnstyledTextInput.js';\nimport TextInputInnerVisualSlot from '../internal/components/TextInputInnerVisualSlot.js';\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n// NOTE: if these props or their JSDoc comments are updated, be sure to also update\n// the prop table in docs/content/TextInputTokens.mdx\n\nconst overflowCountFontSizeMap = {\n  small: 0,\n  medium: 1,\n  large: 1,\n  xlarge: 2\n};\n\n// using forwardRef is important so that other components (ex. Autocomplete) can use the ref\nfunction TextInputWithTokensInnerComponent({\n  icon: IconComponent,\n  leadingVisual: LeadingVisual,\n  trailingVisual: TrailingVisual,\n  loading,\n  loaderPosition = 'auto',\n  contrast,\n  className,\n  block,\n  disabled,\n  sx: sxProp,\n  tokens,\n  onTokenRemove,\n  tokenComponent: TokenComponent = Token,\n  preventTokenWrapping = false,\n  size = 'xlarge',\n  hideTokenRemoveButtons = false,\n  maxHeight,\n  width: widthProp,\n  minWidth: minWidthProp,\n  maxWidth: maxWidthProp,\n  validationStatus,\n  variant: variantProp,\n  // deprecated. use `size` instead\n  visibleTokenCount,\n  ...rest\n}, forwardedRef) {\n  const {\n    onBlur,\n    onFocus,\n    onKeyDown,\n    ...inputPropsRest\n  } = omit(rest);\n  const ref = useRef(null);\n  useRefObjectAsForwardedRef(forwardedRef, ref);\n  const [selectedTokenIndex, setSelectedTokenIndex] = useState();\n  const [tokensAreTruncated, setTokensAreTruncated] = useState(Boolean(visibleTokenCount));\n  const {\n    containerRef\n  } = useFocusZone({\n    focusOutBehavior: 'wrap',\n    bindKeys: FocusKeys.ArrowHorizontal | FocusKeys.HomeAndEnd,\n    focusableElementFilter: element => {\n      return !element.getAttributeNames().includes('aria-hidden');\n    },\n    getNextFocusable: direction => {\n      var _containerRef$current;\n      if (!selectedTokenIndex && selectedTokenIndex !== 0) {\n        return undefined;\n      }\n      let nextIndex = selectedTokenIndex + 1; // \"+ 1\" accounts for the first element: the text input\n\n      if (direction === 'next') {\n        nextIndex += 1;\n      }\n      if (direction === 'previous') {\n        nextIndex -= 1;\n      }\n      if (nextIndex > tokens.length || nextIndex < 1) {\n        return ref.current || undefined;\n      }\n      return (_containerRef$current = containerRef.current) === null || _containerRef$current === void 0 ? void 0 : _containerRef$current.children[nextIndex];\n    }\n  }, [selectedTokenIndex]);\n  const handleTokenRemove = tokenId => {\n    onTokenRemove(tokenId);\n\n    // HACK: wait a tick for the token node to be removed from the DOM\n    setTimeout(() => {\n      var _containerRef$current2, _containerRef$current3;\n      const nextElementToFocus = (_containerRef$current2 = containerRef.current) === null || _containerRef$current2 === void 0 ? void 0 : _containerRef$current2.children[selectedTokenIndex || 0];\n\n      // when removing the first token by keying \"Backspace\" or \"Delete\",\n      // `nextFocusableElement` is the div that wraps the input\n      const firstFocusable = nextElementToFocus && isFocusable(nextElementToFocus) ? nextElementToFocus : Array.from(((_containerRef$current3 = containerRef.current) === null || _containerRef$current3 === void 0 ? void 0 : _containerRef$current3.children) || []).find(el => isFocusable(el));\n      if (firstFocusable) {\n        firstFocusable.focus();\n      } else {\n        var _ref$current;\n        // if there are no tokens left, focus the input\n        (_ref$current = ref.current) === null || _ref$current === void 0 ? void 0 : _ref$current.focus();\n      }\n    }, 0);\n  };\n  const handleTokenFocus = tokenIndex => () => {\n    if (!disabled) setSelectedTokenIndex(tokenIndex);\n  };\n  const handleTokenBlur = () => {\n    setSelectedTokenIndex(undefined);\n\n    // HACK: wait a tick and check the focused element before hiding truncated tokens\n    // this prevents the tokens from hiding when the user is moving focus between tokens,\n    // but still hides the tokens when the user blurs the token by tabbing out or clicking somewhere else on the page\n    setTimeout(() => {\n      var _containerRef$current4;\n      if (!((_containerRef$current4 = containerRef.current) !== null && _containerRef$current4 !== void 0 && _containerRef$current4.contains(document.activeElement)) && visibleTokenCount) {\n        setTokensAreTruncated(true);\n      }\n    }, 0);\n  };\n  const handleTokenKeyUp = event => {\n    if (event.key === 'Escape') {\n      var _ref$current2;\n      (_ref$current2 = ref.current) === null || _ref$current2 === void 0 ? void 0 : _ref$current2.focus();\n    }\n  };\n  const handleInputFocus = event => {\n    onFocus && onFocus(event);\n    setSelectedTokenIndex(undefined);\n    visibleTokenCount && setTokensAreTruncated(false);\n  };\n  const handleInputBlur = event => {\n    onBlur && onBlur(event);\n\n    // HACK: wait a tick and check the focused element before hiding truncated tokens\n    // this prevents the tokens from hiding when the user is moving focus from the input to a token,\n    // but still hides the tokens when the user blurs the input by tabbing out or clicking somewhere else on the page\n    setTimeout(() => {\n      var _containerRef$current5;\n      if (!((_containerRef$current5 = containerRef.current) !== null && _containerRef$current5 !== void 0 && _containerRef$current5.contains(document.activeElement)) && visibleTokenCount) {\n        setTokensAreTruncated(true);\n      }\n    }, 0);\n  };\n  const handleInputKeyDown = e => {\n    var _ref$current3;\n    if (onKeyDown) {\n      onKeyDown(e);\n    }\n    if ((_ref$current3 = ref.current) !== null && _ref$current3 !== void 0 && _ref$current3.value) {\n      return;\n    }\n    const lastToken = tokens[tokens.length - 1];\n    if (e.key === 'Backspace' && lastToken) {\n      handleTokenRemove(lastToken.id);\n      if (ref.current) {\n        // TODO: eliminate the first hack by making changes to the Autocomplete component\n        //\n        // HACKS:\n        // 1. Directly setting `ref.current.value` instead of updating state because the autocomplete\n        //    highlight behavior doesn't work correctly if we update the value with a setState action in onChange\n        // 2. Adding an extra space so that when I backspace, it doesn't delete the last letter\n        ref.current.value = `${lastToken.text} `;\n      }\n\n      // HACK: for some reason we need to wait a tick for `.select()` to work\n      setTimeout(() => {\n        var _ref$current4;\n        (_ref$current4 = ref.current) === null || _ref$current4 === void 0 ? void 0 : _ref$current4.select();\n      }, 0);\n    }\n  };\n  const focusInput = () => {\n    var _ref$current5;\n    (_ref$current5 = ref.current) === null || _ref$current5 === void 0 ? void 0 : _ref$current5.focus();\n  };\n  const preventTokenClickPropagation = event => {\n    event.stopPropagation();\n  };\n  const visibleTokens = tokensAreTruncated ? tokens.slice(0, visibleTokenCount) : tokens;\n  const inputSizeMap = {\n    small: 'small',\n    medium: 'small',\n    large: 'medium',\n    xlarge: 'medium'\n  };\n  const showLeadingLoadingIndicator = loading && (loaderPosition === 'leading' || Boolean(LeadingVisual && loaderPosition !== 'trailing'));\n  const showTrailingLoadingIndicator = loading && (loaderPosition === 'trailing' || loaderPosition === 'auto' && !LeadingVisual);\n  return /*#__PURE__*/React.createElement(TextInputWrapper, {\n    block: block,\n    className: className,\n    contrast: contrast,\n    disabled: disabled,\n    hasLeadingVisual: Boolean(LeadingVisual || showLeadingLoadingIndicator),\n    hasTrailingVisual: Boolean(TrailingVisual || showTrailingLoadingIndicator),\n    width: widthProp,\n    minWidth: minWidthProp,\n    maxWidth: maxWidthProp,\n    size: inputSizeMap[size],\n    validationStatus: validationStatus,\n    variant: variantProp // deprecated. use `size` prop instead\n    ,\n    onClick: focusInput,\n    sx: {\n      paddingLeft: textInputHorizPadding,\n      py: `calc(${textInputHorizPadding} / 2)`,\n      ...(block ? {\n        display: 'flex',\n        width: '100%'\n      } : {}),\n      ...(maxHeight ? {\n        maxHeight,\n        overflow: 'auto'\n      } : {}),\n      ...(preventTokenWrapping ? {\n        overflow: 'auto'\n      } : {}),\n      ...sxProp\n    }\n  }, IconComponent && !LeadingVisual && /*#__PURE__*/React.createElement(IconComponent, {\n    className: \"TextInput-icon\"\n  }), /*#__PURE__*/React.createElement(TextInputInnerVisualSlot, {\n    hasLoadingIndicator: typeof loading === 'boolean',\n    visualPosition: \"leading\",\n    showLoadingIndicator: showLeadingLoadingIndicator\n  }, typeof LeadingVisual !== 'string' && isValidElementType(LeadingVisual) ? /*#__PURE__*/React.createElement(LeadingVisual, null) : LeadingVisual), /*#__PURE__*/React.createElement(Box, {\n    ref: containerRef,\n    display: \"flex\",\n    sx: {\n      alignItems: 'center',\n      flexWrap: preventTokenWrapping ? 'nowrap' : 'wrap',\n      marginLeft: '-0.25rem',\n      marginBottom: '-0.25rem',\n      flexGrow: 1,\n      '> *': {\n        flexShrink: 0,\n        marginLeft: '0.25rem',\n        marginBottom: '0.25rem'\n      }\n    }\n  }, /*#__PURE__*/React.createElement(Box, {\n    sx: {\n      order: 1,\n      flexGrow: 1\n    }\n  }, /*#__PURE__*/React.createElement(UnstyledTextInput, _extends({\n    ref: ref,\n    disabled: disabled,\n    onFocus: handleInputFocus,\n    onBlur: handleInputBlur,\n    onKeyDown: handleInputKeyDown,\n    type: \"text\",\n    sx: {\n      height: '100%'\n    },\n    \"aria-invalid\": validationStatus === 'error' ? 'true' : 'false'\n  }, inputPropsRest))), visibleTokens.map(({\n    id,\n    ...tokenRest\n  }, i) => /*#__PURE__*/React.createElement(TokenComponent, _extends({\n    disabled: disabled,\n    key: id,\n    onFocus: handleTokenFocus(i),\n    onBlur: handleTokenBlur,\n    onKeyUp: handleTokenKeyUp,\n    onClick: preventTokenClickPropagation,\n    isSelected: selectedTokenIndex === i,\n    onRemove: () => {\n      handleTokenRemove(id);\n    },\n    hideRemoveButton: disabled || hideTokenRemoveButtons,\n    size: size,\n    tabIndex: 0\n  }, tokenRest))), tokensAreTruncated && tokens.length - visibleTokens.length ? /*#__PURE__*/React.createElement(Text, {\n    color: \"fg.muted\",\n    fontSize: overflowCountFontSizeMap[size]\n  }, \"+\", tokens.length - visibleTokens.length) : null), /*#__PURE__*/React.createElement(TextInputInnerVisualSlot, {\n    hasLoadingIndicator: typeof loading === 'boolean',\n    visualPosition: \"trailing\",\n    showLoadingIndicator: showTrailingLoadingIndicator\n  }, typeof TrailingVisual !== 'string' && isValidElementType(TrailingVisual) ? /*#__PURE__*/React.createElement(TrailingVisual, null) : TrailingVisual));\n}\nTextInputWithTokensInnerComponent.displayName = \"TextInputWithTokensInnerComponent\";\nconst TextInputWithTokens = /*#__PURE__*/React.forwardRef(TextInputWithTokensInnerComponent);\nTextInputWithTokens.displayName = 'TextInputWithTokens';\n\nexport { TextInputWithTokens as default };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}