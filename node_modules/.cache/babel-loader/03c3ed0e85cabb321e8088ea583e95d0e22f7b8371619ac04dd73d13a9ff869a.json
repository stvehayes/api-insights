{"ast":null,"code":"export function* iterateFocusableElements(container, options = {}) {\n  var _a, _b;\n  const strict = (_a = options.strict) !== null && _a !== void 0 ? _a : false;\n  const acceptFn = ((_b = options.onlyTabbable) !== null && _b !== void 0 ? _b : false) ? isTabbable : isFocusable;\n  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: node => node instanceof HTMLElement && acceptFn(node, strict) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP\n  });\n  let nextNode = null;\n  if (!options.reverse && acceptFn(container, strict)) {\n    yield container;\n  }\n  if (options.reverse) {\n    let lastChild = walker.lastChild();\n    while (lastChild) {\n      nextNode = lastChild;\n      lastChild = walker.lastChild();\n    }\n  } else {\n    nextNode = walker.firstChild();\n  }\n  while (nextNode instanceof HTMLElement) {\n    yield nextNode;\n    nextNode = options.reverse ? walker.previousNode() : walker.nextNode();\n  }\n  if (options.reverse && acceptFn(container, strict)) {\n    yield container;\n  }\n  return undefined;\n}\nexport function getFocusableChild(container, lastChild = false) {\n  return iterateFocusableElements(container, {\n    reverse: lastChild,\n    strict: true,\n    onlyTabbable: true\n  }).next().value;\n}\nexport function isFocusable(elem, strict = false) {\n  const disabledAttrInert = ['BUTTON', 'INPUT', 'SELECT', 'TEXTAREA', 'OPTGROUP', 'OPTION', 'FIELDSET'].includes(elem.tagName) && elem.disabled;\n  const hiddenInert = elem.hidden;\n  const hiddenInputInert = elem instanceof HTMLInputElement && elem.type === 'hidden';\n  const sentinelInert = elem.classList.contains('sentinel');\n  if (disabledAttrInert || hiddenInert || hiddenInputInert || sentinelInert) {\n    return false;\n  }\n  if (strict) {\n    const style = getComputedStyle(elem);\n    const sizeInert = elem.offsetWidth === 0 || elem.offsetHeight === 0;\n    const visibilityInert = ['hidden', 'collapse'].includes(style.visibility);\n    const displayInert = style.display === 'none' || !elem.offsetParent;\n    const clientRectsInert = elem.getClientRects().length === 0;\n    if (sizeInert || visibilityInert || clientRectsInert || displayInert) {\n      return false;\n    }\n  }\n  if (elem.getAttribute('tabindex') != null) {\n    return true;\n  }\n  if (elem.getAttribute('contenteditable') === 'true' || elem.getAttribute('contenteditable') === 'plaintext-only') {\n    return true;\n  }\n  if (elem instanceof HTMLAnchorElement && elem.getAttribute('href') == null) {\n    return false;\n  }\n  return elem.tabIndex !== -1;\n}\nexport function isTabbable(elem, strict = false) {\n  return isFocusable(elem, strict) && elem.getAttribute('tabindex') !== '-1';\n}","map":{"version":3,"names":["iterateFocusableElements","container","options","_a","_b","strict","acceptFn","onlyTabbable","isTabbable","isFocusable","walker","document","createTreeWalker","NodeFilter","SHOW_ELEMENT","acceptNode","node","HTMLElement","FILTER_ACCEPT","FILTER_SKIP","nextNode","reverse","lastChild","firstChild","previousNode","undefined","getFocusableChild","next","value","elem","disabledAttrInert","includes","tagName","disabled","hiddenInert","hidden","hiddenInputInert","HTMLInputElement","type","sentinelInert","classList","contains","style","getComputedStyle","sizeInert","offsetWidth","offsetHeight","visibilityInert","visibility","displayInert","display","offsetParent","clientRectsInert","getClientRects","length","getAttribute","HTMLAnchorElement","tabIndex"],"sources":["/Users/steve/Documents/repos/github/licensing-report/node_modules/@primer/behaviors/dist/esm/utils/iterate-focusable-elements.js"],"sourcesContent":["export function* iterateFocusableElements(container, options = {}) {\n    var _a, _b;\n    const strict = (_a = options.strict) !== null && _a !== void 0 ? _a : false;\n    const acceptFn = ((_b = options.onlyTabbable) !== null && _b !== void 0 ? _b : false) ? isTabbable : isFocusable;\n    const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {\n        acceptNode: node => node instanceof HTMLElement && acceptFn(node, strict) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP,\n    });\n    let nextNode = null;\n    if (!options.reverse && acceptFn(container, strict)) {\n        yield container;\n    }\n    if (options.reverse) {\n        let lastChild = walker.lastChild();\n        while (lastChild) {\n            nextNode = lastChild;\n            lastChild = walker.lastChild();\n        }\n    }\n    else {\n        nextNode = walker.firstChild();\n    }\n    while (nextNode instanceof HTMLElement) {\n        yield nextNode;\n        nextNode = options.reverse ? walker.previousNode() : walker.nextNode();\n    }\n    if (options.reverse && acceptFn(container, strict)) {\n        yield container;\n    }\n    return undefined;\n}\nexport function getFocusableChild(container, lastChild = false) {\n    return iterateFocusableElements(container, { reverse: lastChild, strict: true, onlyTabbable: true }).next().value;\n}\nexport function isFocusable(elem, strict = false) {\n    const disabledAttrInert = ['BUTTON', 'INPUT', 'SELECT', 'TEXTAREA', 'OPTGROUP', 'OPTION', 'FIELDSET'].includes(elem.tagName) &&\n        elem.disabled;\n    const hiddenInert = elem.hidden;\n    const hiddenInputInert = elem instanceof HTMLInputElement && elem.type === 'hidden';\n    const sentinelInert = elem.classList.contains('sentinel');\n    if (disabledAttrInert || hiddenInert || hiddenInputInert || sentinelInert) {\n        return false;\n    }\n    if (strict) {\n        const style = getComputedStyle(elem);\n        const sizeInert = elem.offsetWidth === 0 || elem.offsetHeight === 0;\n        const visibilityInert = ['hidden', 'collapse'].includes(style.visibility);\n        const displayInert = style.display === 'none' || !elem.offsetParent;\n        const clientRectsInert = elem.getClientRects().length === 0;\n        if (sizeInert || visibilityInert || clientRectsInert || displayInert) {\n            return false;\n        }\n    }\n    if (elem.getAttribute('tabindex') != null) {\n        return true;\n    }\n    if (elem.getAttribute('contenteditable') === 'true' || elem.getAttribute('contenteditable') === 'plaintext-only') {\n        return true;\n    }\n    if (elem instanceof HTMLAnchorElement && elem.getAttribute('href') == null) {\n        return false;\n    }\n    return elem.tabIndex !== -1;\n}\nexport function isTabbable(elem, strict = false) {\n    return isFocusable(elem, strict) && elem.getAttribute('tabindex') !== '-1';\n}\n"],"mappings":"AAAA,OAAO,UAAUA,wBAAwBA,CAACC,SAAS,EAAEC,OAAO,GAAG,CAAC,CAAC,EAAE;EAC/D,IAAIC,EAAE,EAAEC,EAAE;EACV,MAAMC,MAAM,GAAG,CAACF,EAAE,GAAGD,OAAO,CAACG,MAAM,MAAM,IAAI,IAAIF,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAG,KAAK;EAC3E,MAAMG,QAAQ,GAAG,CAAC,CAACF,EAAE,GAAGF,OAAO,CAACK,YAAY,MAAM,IAAI,IAAIH,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAG,KAAK,IAAII,UAAU,GAAGC,WAAW;EAChH,MAAMC,MAAM,GAAGC,QAAQ,CAACC,gBAAgB,CAACX,SAAS,EAAEY,UAAU,CAACC,YAAY,EAAE;IACzEC,UAAU,EAAEC,IAAI,IAAIA,IAAI,YAAYC,WAAW,IAAIX,QAAQ,CAACU,IAAI,EAAEX,MAAM,CAAC,GAAGQ,UAAU,CAACK,aAAa,GAAGL,UAAU,CAACM;EACtH,CAAC,CAAC;EACF,IAAIC,QAAQ,GAAG,IAAI;EACnB,IAAI,CAAClB,OAAO,CAACmB,OAAO,IAAIf,QAAQ,CAACL,SAAS,EAAEI,MAAM,CAAC,EAAE;IACjD,MAAMJ,SAAS;EACnB;EACA,IAAIC,OAAO,CAACmB,OAAO,EAAE;IACjB,IAAIC,SAAS,GAAGZ,MAAM,CAACY,SAAS,CAAC,CAAC;IAClC,OAAOA,SAAS,EAAE;MACdF,QAAQ,GAAGE,SAAS;MACpBA,SAAS,GAAGZ,MAAM,CAACY,SAAS,CAAC,CAAC;IAClC;EACJ,CAAC,MACI;IACDF,QAAQ,GAAGV,MAAM,CAACa,UAAU,CAAC,CAAC;EAClC;EACA,OAAOH,QAAQ,YAAYH,WAAW,EAAE;IACpC,MAAMG,QAAQ;IACdA,QAAQ,GAAGlB,OAAO,CAACmB,OAAO,GAAGX,MAAM,CAACc,YAAY,CAAC,CAAC,GAAGd,MAAM,CAACU,QAAQ,CAAC,CAAC;EAC1E;EACA,IAAIlB,OAAO,CAACmB,OAAO,IAAIf,QAAQ,CAACL,SAAS,EAAEI,MAAM,CAAC,EAAE;IAChD,MAAMJ,SAAS;EACnB;EACA,OAAOwB,SAAS;AACpB;AACA,OAAO,SAASC,iBAAiBA,CAACzB,SAAS,EAAEqB,SAAS,GAAG,KAAK,EAAE;EAC5D,OAAOtB,wBAAwB,CAACC,SAAS,EAAE;IAAEoB,OAAO,EAAEC,SAAS;IAAEjB,MAAM,EAAE,IAAI;IAAEE,YAAY,EAAE;EAAK,CAAC,CAAC,CAACoB,IAAI,CAAC,CAAC,CAACC,KAAK;AACrH;AACA,OAAO,SAASnB,WAAWA,CAACoB,IAAI,EAAExB,MAAM,GAAG,KAAK,EAAE;EAC9C,MAAMyB,iBAAiB,GAAG,CAAC,QAAQ,EAAE,OAAO,EAAE,QAAQ,EAAE,UAAU,EAAE,UAAU,EAAE,QAAQ,EAAE,UAAU,CAAC,CAACC,QAAQ,CAACF,IAAI,CAACG,OAAO,CAAC,IACxHH,IAAI,CAACI,QAAQ;EACjB,MAAMC,WAAW,GAAGL,IAAI,CAACM,MAAM;EAC/B,MAAMC,gBAAgB,GAAGP,IAAI,YAAYQ,gBAAgB,IAAIR,IAAI,CAACS,IAAI,KAAK,QAAQ;EACnF,MAAMC,aAAa,GAAGV,IAAI,CAACW,SAAS,CAACC,QAAQ,CAAC,UAAU,CAAC;EACzD,IAAIX,iBAAiB,IAAII,WAAW,IAAIE,gBAAgB,IAAIG,aAAa,EAAE;IACvE,OAAO,KAAK;EAChB;EACA,IAAIlC,MAAM,EAAE;IACR,MAAMqC,KAAK,GAAGC,gBAAgB,CAACd,IAAI,CAAC;IACpC,MAAMe,SAAS,GAAGf,IAAI,CAACgB,WAAW,KAAK,CAAC,IAAIhB,IAAI,CAACiB,YAAY,KAAK,CAAC;IACnE,MAAMC,eAAe,GAAG,CAAC,QAAQ,EAAE,UAAU,CAAC,CAAChB,QAAQ,CAACW,KAAK,CAACM,UAAU,CAAC;IACzE,MAAMC,YAAY,GAAGP,KAAK,CAACQ,OAAO,KAAK,MAAM,IAAI,CAACrB,IAAI,CAACsB,YAAY;IACnE,MAAMC,gBAAgB,GAAGvB,IAAI,CAACwB,cAAc,CAAC,CAAC,CAACC,MAAM,KAAK,CAAC;IAC3D,IAAIV,SAAS,IAAIG,eAAe,IAAIK,gBAAgB,IAAIH,YAAY,EAAE;MAClE,OAAO,KAAK;IAChB;EACJ;EACA,IAAIpB,IAAI,CAAC0B,YAAY,CAAC,UAAU,CAAC,IAAI,IAAI,EAAE;IACvC,OAAO,IAAI;EACf;EACA,IAAI1B,IAAI,CAAC0B,YAAY,CAAC,iBAAiB,CAAC,KAAK,MAAM,IAAI1B,IAAI,CAAC0B,YAAY,CAAC,iBAAiB,CAAC,KAAK,gBAAgB,EAAE;IAC9G,OAAO,IAAI;EACf;EACA,IAAI1B,IAAI,YAAY2B,iBAAiB,IAAI3B,IAAI,CAAC0B,YAAY,CAAC,MAAM,CAAC,IAAI,IAAI,EAAE;IACxE,OAAO,KAAK;EAChB;EACA,OAAO1B,IAAI,CAAC4B,QAAQ,KAAK,CAAC,CAAC;AAC/B;AACA,OAAO,SAASjD,UAAUA,CAACqB,IAAI,EAAExB,MAAM,GAAG,KAAK,EAAE;EAC7C,OAAOI,WAAW,CAACoB,IAAI,EAAExB,MAAM,CAAC,IAAIwB,IAAI,CAAC0B,YAAY,CAAC,UAAU,CAAC,KAAK,IAAI;AAC9E"},"metadata":{},"sourceType":"module","externalDependencies":[]}