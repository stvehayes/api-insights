{"ast":null,"code":"import { useState, useCallback, useEffect } from 'react';\nimport { getCharacterCoordinates } from '../utils/character-coordinates.js';\nimport useIsomorphicLayoutEffect from '../../utils/useIsomorphicLayoutEffect.js';\n\n/**\n * Calculates the optimal height of the textarea according to its content, automatically\n * resizing it as the user types. If the user manually resizes the textarea, their setting\n * will be respected.\n *\n * Returns an object to spread to the component's `sx` prop. If you are using `Textarea`,\n * apply this to the child `textarea` element: `<Textarea sx={{'& textarea': resultOfThisHook}} />`.\n *\n * NOTE: for the most accurate results, be sure that the `lineHeight` of the element is\n * explicitly set in CSS.\n *\n * @deprecated Will be removed in v37 (https://github.com/primer/react/issues/3604)\n */\nconst useDynamicTextareaHeight = ({\n  disabled,\n  minHeightLines,\n  maxHeightLines,\n  elementRef,\n  value\n}) => {\n  const [height, setHeight] = useState(undefined);\n  const [minHeight, setMinHeight] = useState(undefined);\n  const [maxHeight, setMaxHeight] = useState(undefined);\n  const refreshHeight = useCallback(() => {\n    if (disabled) return;\n    const element = elementRef.current;\n    if (!element) return;\n    const computedStyles = getComputedStyle(element);\n    const pt = computedStyles.paddingTop;\n\n    // The calculator gives us the distance from the top border to the bottom of the caret, including\n    // any top padding, so we need to delete the top padding to accurately get the height\n    // We could also parse and subtract the top padding, but this is more reliable (no chance of NaN)\n    element.style.paddingTop = '0';\n    const lastCharacterCoords = getCharacterCoordinates(element, element.value.length);\n\n    // Somehow we come up 1 pixel too short and the scrollbar appears, so just add one\n    setHeight(`${lastCharacterCoords.top + lastCharacterCoords.height + 1}px`);\n    element.style.paddingTop = pt;\n    const lineHeight = computedStyles.lineHeight === 'normal' ? `1.2 * ${computedStyles.fontSize}` : computedStyles.lineHeight;\n    // Using CSS calculations is fast and prevents us from having to parse anything\n    if (minHeightLines !== undefined) setMinHeight(`calc(${minHeightLines} * ${lineHeight})`);\n    if (maxHeightLines !== undefined) setMaxHeight(`calc(${maxHeightLines} * ${lineHeight})`);\n    // `value` is an unnecessary dependency but it enables us to recalculate as the user types\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [minHeightLines, maxHeightLines, value, elementRef, disabled]);\n  useIsomorphicLayoutEffect(refreshHeight, [refreshHeight]);\n\n  // With Slots, initial render of the component is delayed and so the initial layout effect can occur\n  // before the target element has actually been calculated in the DOM. But if we only use regular effects,\n  // there will be a visible flash on initial render when not using slots\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  useEffect(refreshHeight, []);\n  if (disabled) return {};\n  return {\n    height,\n    minHeight,\n    maxHeight,\n    boxSizing: 'content-box'\n  };\n};\nexport { useDynamicTextareaHeight };","map":{"version":3,"names":["useState","useCallback","useEffect","getCharacterCoordinates","useIsomorphicLayoutEffect","useDynamicTextareaHeight","disabled","minHeightLines","maxHeightLines","elementRef","value","height","setHeight","undefined","minHeight","setMinHeight","maxHeight","setMaxHeight","refreshHeight","element","current","computedStyles","getComputedStyle","pt","paddingTop","style","lastCharacterCoords","length","top","lineHeight","fontSize","boxSizing"],"sources":["/Users/steve/Documents/repos/github/api-insights/node_modules/@primer/react/lib-esm/drafts/hooks/useDynamicTextareaHeight.js"],"sourcesContent":["import { useState, useCallback, useEffect } from 'react';\nimport { getCharacterCoordinates } from '../utils/character-coordinates.js';\nimport useIsomorphicLayoutEffect from '../../utils/useIsomorphicLayoutEffect.js';\n\n/**\n * Calculates the optimal height of the textarea according to its content, automatically\n * resizing it as the user types. If the user manually resizes the textarea, their setting\n * will be respected.\n *\n * Returns an object to spread to the component's `sx` prop. If you are using `Textarea`,\n * apply this to the child `textarea` element: `<Textarea sx={{'& textarea': resultOfThisHook}} />`.\n *\n * NOTE: for the most accurate results, be sure that the `lineHeight` of the element is\n * explicitly set in CSS.\n *\n * @deprecated Will be removed in v37 (https://github.com/primer/react/issues/3604)\n */\nconst useDynamicTextareaHeight = ({\n  disabled,\n  minHeightLines,\n  maxHeightLines,\n  elementRef,\n  value\n}) => {\n  const [height, setHeight] = useState(undefined);\n  const [minHeight, setMinHeight] = useState(undefined);\n  const [maxHeight, setMaxHeight] = useState(undefined);\n  const refreshHeight = useCallback(() => {\n    if (disabled) return;\n    const element = elementRef.current;\n    if (!element) return;\n    const computedStyles = getComputedStyle(element);\n    const pt = computedStyles.paddingTop;\n\n    // The calculator gives us the distance from the top border to the bottom of the caret, including\n    // any top padding, so we need to delete the top padding to accurately get the height\n    // We could also parse and subtract the top padding, but this is more reliable (no chance of NaN)\n    element.style.paddingTop = '0';\n    const lastCharacterCoords = getCharacterCoordinates(element, element.value.length);\n\n    // Somehow we come up 1 pixel too short and the scrollbar appears, so just add one\n    setHeight(`${lastCharacterCoords.top + lastCharacterCoords.height + 1}px`);\n    element.style.paddingTop = pt;\n    const lineHeight = computedStyles.lineHeight === 'normal' ? `1.2 * ${computedStyles.fontSize}` : computedStyles.lineHeight;\n    // Using CSS calculations is fast and prevents us from having to parse anything\n    if (minHeightLines !== undefined) setMinHeight(`calc(${minHeightLines} * ${lineHeight})`);\n    if (maxHeightLines !== undefined) setMaxHeight(`calc(${maxHeightLines} * ${lineHeight})`);\n    // `value` is an unnecessary dependency but it enables us to recalculate as the user types\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [minHeightLines, maxHeightLines, value, elementRef, disabled]);\n  useIsomorphicLayoutEffect(refreshHeight, [refreshHeight]);\n\n  // With Slots, initial render of the component is delayed and so the initial layout effect can occur\n  // before the target element has actually been calculated in the DOM. But if we only use regular effects,\n  // there will be a visible flash on initial render when not using slots\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  useEffect(refreshHeight, []);\n  if (disabled) return {};\n  return {\n    height,\n    minHeight,\n    maxHeight,\n    boxSizing: 'content-box'\n  };\n};\n\nexport { useDynamicTextareaHeight };\n"],"mappings":"AAAA,SAASA,QAAQ,EAAEC,WAAW,EAAEC,SAAS,QAAQ,OAAO;AACxD,SAASC,uBAAuB,QAAQ,mCAAmC;AAC3E,OAAOC,yBAAyB,MAAM,0CAA0C;;AAEhF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,wBAAwB,GAAGA,CAAC;EAChCC,QAAQ;EACRC,cAAc;EACdC,cAAc;EACdC,UAAU;EACVC;AACF,CAAC,KAAK;EACJ,MAAM,CAACC,MAAM,EAAEC,SAAS,CAAC,GAAGZ,QAAQ,CAACa,SAAS,CAAC;EAC/C,MAAM,CAACC,SAAS,EAAEC,YAAY,CAAC,GAAGf,QAAQ,CAACa,SAAS,CAAC;EACrD,MAAM,CAACG,SAAS,EAAEC,YAAY,CAAC,GAAGjB,QAAQ,CAACa,SAAS,CAAC;EACrD,MAAMK,aAAa,GAAGjB,WAAW,CAAC,MAAM;IACtC,IAAIK,QAAQ,EAAE;IACd,MAAMa,OAAO,GAAGV,UAAU,CAACW,OAAO;IAClC,IAAI,CAACD,OAAO,EAAE;IACd,MAAME,cAAc,GAAGC,gBAAgB,CAACH,OAAO,CAAC;IAChD,MAAMI,EAAE,GAAGF,cAAc,CAACG,UAAU;;IAEpC;IACA;IACA;IACAL,OAAO,CAACM,KAAK,CAACD,UAAU,GAAG,GAAG;IAC9B,MAAME,mBAAmB,GAAGvB,uBAAuB,CAACgB,OAAO,EAAEA,OAAO,CAACT,KAAK,CAACiB,MAAM,CAAC;;IAElF;IACAf,SAAS,CAAE,GAAEc,mBAAmB,CAACE,GAAG,GAAGF,mBAAmB,CAACf,MAAM,GAAG,CAAE,IAAG,CAAC;IAC1EQ,OAAO,CAACM,KAAK,CAACD,UAAU,GAAGD,EAAE;IAC7B,MAAMM,UAAU,GAAGR,cAAc,CAACQ,UAAU,KAAK,QAAQ,GAAI,SAAQR,cAAc,CAACS,QAAS,EAAC,GAAGT,cAAc,CAACQ,UAAU;IAC1H;IACA,IAAItB,cAAc,KAAKM,SAAS,EAAEE,YAAY,CAAE,QAAOR,cAAe,MAAKsB,UAAW,GAAE,CAAC;IACzF,IAAIrB,cAAc,KAAKK,SAAS,EAAEI,YAAY,CAAE,QAAOT,cAAe,MAAKqB,UAAW,GAAE,CAAC;IACzF;IACA;EACF,CAAC,EAAE,CAACtB,cAAc,EAAEC,cAAc,EAAEE,KAAK,EAAED,UAAU,EAAEH,QAAQ,CAAC,CAAC;EACjEF,yBAAyB,CAACc,aAAa,EAAE,CAACA,aAAa,CAAC,CAAC;;EAEzD;EACA;EACA;EACA;EACAhB,SAAS,CAACgB,aAAa,EAAE,EAAE,CAAC;EAC5B,IAAIZ,QAAQ,EAAE,OAAO,CAAC,CAAC;EACvB,OAAO;IACLK,MAAM;IACNG,SAAS;IACTE,SAAS;IACTe,SAAS,EAAE;EACb,CAAC;AACH,CAAC;AAED,SAAS1B,wBAAwB"},"metadata":{},"sourceType":"module","externalDependencies":[]}