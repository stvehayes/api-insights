{"ast":null,"code":"import { polyfill as eventListenerSignalPolyfill } from './polyfills/event-listener-signal.js';\nimport { isMacOS } from './utils/user-agent.js';\nimport { iterateFocusableElements } from './utils/iterate-focusable-elements.js';\nimport { uniqueId } from './utils/unique-id.js';\neventListenerSignalPolyfill();\nexport var FocusKeys;\n(function (FocusKeys) {\n  FocusKeys[FocusKeys[\"ArrowHorizontal\"] = 1] = \"ArrowHorizontal\";\n  FocusKeys[FocusKeys[\"ArrowVertical\"] = 2] = \"ArrowVertical\";\n  FocusKeys[FocusKeys[\"JK\"] = 4] = \"JK\";\n  FocusKeys[FocusKeys[\"HL\"] = 8] = \"HL\";\n  FocusKeys[FocusKeys[\"HomeAndEnd\"] = 16] = \"HomeAndEnd\";\n  FocusKeys[FocusKeys[\"PageUpDown\"] = 256] = \"PageUpDown\";\n  FocusKeys[FocusKeys[\"WS\"] = 32] = \"WS\";\n  FocusKeys[FocusKeys[\"AD\"] = 64] = \"AD\";\n  FocusKeys[FocusKeys[\"Tab\"] = 128] = \"Tab\";\n  FocusKeys[FocusKeys[\"Backspace\"] = 512] = \"Backspace\";\n  FocusKeys[FocusKeys[\"ArrowAll\"] = 3] = \"ArrowAll\";\n  FocusKeys[FocusKeys[\"HJKL\"] = 12] = \"HJKL\";\n  FocusKeys[FocusKeys[\"WASD\"] = 96] = \"WASD\";\n  FocusKeys[FocusKeys[\"All\"] = 511] = \"All\";\n})(FocusKeys || (FocusKeys = {}));\nconst KEY_TO_BIT = {\n  ArrowLeft: FocusKeys.ArrowHorizontal,\n  ArrowDown: FocusKeys.ArrowVertical,\n  ArrowUp: FocusKeys.ArrowVertical,\n  ArrowRight: FocusKeys.ArrowHorizontal,\n  h: FocusKeys.HL,\n  j: FocusKeys.JK,\n  k: FocusKeys.JK,\n  l: FocusKeys.HL,\n  a: FocusKeys.AD,\n  s: FocusKeys.WS,\n  w: FocusKeys.WS,\n  d: FocusKeys.AD,\n  Tab: FocusKeys.Tab,\n  Home: FocusKeys.HomeAndEnd,\n  End: FocusKeys.HomeAndEnd,\n  PageUp: FocusKeys.PageUpDown,\n  PageDown: FocusKeys.PageUpDown,\n  Backspace: FocusKeys.Backspace\n};\nconst KEY_TO_DIRECTION = {\n  ArrowLeft: 'previous',\n  ArrowDown: 'next',\n  ArrowUp: 'previous',\n  ArrowRight: 'next',\n  h: 'previous',\n  j: 'next',\n  k: 'previous',\n  l: 'next',\n  a: 'previous',\n  s: 'next',\n  w: 'previous',\n  d: 'next',\n  Tab: 'next',\n  Home: 'start',\n  End: 'end',\n  PageUp: 'start',\n  PageDown: 'end',\n  Backspace: 'previous'\n};\nfunction getDirection(keyboardEvent) {\n  const direction = KEY_TO_DIRECTION[keyboardEvent.key];\n  if (keyboardEvent.key === 'Tab' && keyboardEvent.shiftKey) {\n    return 'previous';\n  }\n  const isMac = isMacOS();\n  if (isMac && keyboardEvent.metaKey || !isMac && keyboardEvent.ctrlKey) {\n    if (keyboardEvent.key === 'ArrowLeft' || keyboardEvent.key === 'ArrowUp') {\n      return 'start';\n    } else if (keyboardEvent.key === 'ArrowRight' || keyboardEvent.key === 'ArrowDown') {\n      return 'end';\n    }\n  }\n  return direction;\n}\nfunction shouldIgnoreFocusHandling(keyboardEvent, activeElement) {\n  const key = keyboardEvent.key;\n  const keyLength = [...key].length;\n  const isTextInput = activeElement instanceof HTMLInputElement && activeElement.type === 'text' || activeElement instanceof HTMLTextAreaElement;\n  if (isTextInput && (keyLength === 1 || key === 'Home' || key === 'End')) {\n    return true;\n  }\n  if (activeElement instanceof HTMLSelectElement) {\n    if (keyLength === 1) {\n      return true;\n    }\n    if (key === 'ArrowDown' && isMacOS() && !keyboardEvent.metaKey) {\n      return true;\n    }\n    if (key === 'ArrowDown' && !isMacOS() && keyboardEvent.altKey) {\n      return true;\n    }\n  }\n  if (activeElement instanceof HTMLTextAreaElement && (key === 'PageUp' || key === 'PageDown')) {\n    return true;\n  }\n  if (isTextInput) {\n    const textInput = activeElement;\n    const cursorAtStart = textInput.selectionStart === 0 && textInput.selectionEnd === 0;\n    const cursorAtEnd = textInput.selectionStart === textInput.value.length && textInput.selectionEnd === textInput.value.length;\n    if (key === 'ArrowLeft' && !cursorAtStart) {\n      return true;\n    }\n    if (key === 'ArrowRight' && !cursorAtEnd) {\n      return true;\n    }\n    if (textInput instanceof HTMLTextAreaElement) {\n      if (key === 'ArrowUp' && !cursorAtStart) {\n        return true;\n      }\n      if (key === 'ArrowDown' && !cursorAtEnd) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\nexport const isActiveDescendantAttribute = 'data-is-active-descendant';\nexport const activeDescendantActivatedDirectly = 'activated-directly';\nexport const activeDescendantActivatedIndirectly = 'activated-indirectly';\nexport const hasActiveDescendantAttribute = 'data-has-active-descendant';\nexport function focusZone(container, settings) {\n  var _a, _b, _c, _d, _e;\n  const focusableElements = [];\n  const savedTabIndex = new WeakMap();\n  const bindKeys = (_a = settings === null || settings === void 0 ? void 0 : settings.bindKeys) !== null && _a !== void 0 ? _a : ((settings === null || settings === void 0 ? void 0 : settings.getNextFocusable) ? FocusKeys.ArrowAll : FocusKeys.ArrowVertical) | FocusKeys.HomeAndEnd;\n  const focusOutBehavior = (_b = settings === null || settings === void 0 ? void 0 : settings.focusOutBehavior) !== null && _b !== void 0 ? _b : 'stop';\n  const focusInStrategy = (_c = settings === null || settings === void 0 ? void 0 : settings.focusInStrategy) !== null && _c !== void 0 ? _c : 'previous';\n  const activeDescendantControl = settings === null || settings === void 0 ? void 0 : settings.activeDescendantControl;\n  const activeDescendantCallback = settings === null || settings === void 0 ? void 0 : settings.onActiveDescendantChanged;\n  let currentFocusedElement;\n  const preventScroll = (_d = settings === null || settings === void 0 ? void 0 : settings.preventScroll) !== null && _d !== void 0 ? _d : false;\n  function getFirstFocusableElement() {\n    return focusableElements[0];\n  }\n  function isActiveDescendantInputFocused() {\n    return document.activeElement === activeDescendantControl;\n  }\n  function updateFocusedElement(to, directlyActivated = false) {\n    const from = currentFocusedElement;\n    currentFocusedElement = to;\n    if (activeDescendantControl) {\n      if (to && isActiveDescendantInputFocused()) {\n        setActiveDescendant(from, to, directlyActivated);\n      } else {\n        clearActiveDescendant();\n      }\n      return;\n    }\n    if (from && from !== to && savedTabIndex.has(from)) {\n      from.setAttribute('tabindex', '-1');\n    }\n    to === null || to === void 0 ? void 0 : to.setAttribute('tabindex', '0');\n  }\n  function setActiveDescendant(from, to, directlyActivated = false) {\n    if (!to.id) {\n      to.setAttribute('id', uniqueId());\n    }\n    if (from && from !== to) {\n      from.removeAttribute(isActiveDescendantAttribute);\n    }\n    if (!activeDescendantControl || !directlyActivated && activeDescendantControl.getAttribute('aria-activedescendant') === to.id) {\n      return;\n    }\n    activeDescendantControl.setAttribute('aria-activedescendant', to.id);\n    container.setAttribute(hasActiveDescendantAttribute, to.id);\n    to.setAttribute(isActiveDescendantAttribute, directlyActivated ? activeDescendantActivatedDirectly : activeDescendantActivatedIndirectly);\n    activeDescendantCallback === null || activeDescendantCallback === void 0 ? void 0 : activeDescendantCallback(to, from, directlyActivated);\n  }\n  function clearActiveDescendant(previouslyActiveElement = currentFocusedElement) {\n    if (focusInStrategy === 'first') {\n      currentFocusedElement = undefined;\n    }\n    activeDescendantControl === null || activeDescendantControl === void 0 ? void 0 : activeDescendantControl.removeAttribute('aria-activedescendant');\n    container.removeAttribute(hasActiveDescendantAttribute);\n    previouslyActiveElement === null || previouslyActiveElement === void 0 ? void 0 : previouslyActiveElement.removeAttribute(isActiveDescendantAttribute);\n    activeDescendantCallback === null || activeDescendantCallback === void 0 ? void 0 : activeDescendantCallback(undefined, previouslyActiveElement, false);\n  }\n  function beginFocusManagement(...elements) {\n    const filteredElements = elements.filter(e => {\n      var _a, _b;\n      return (_b = (_a = settings === null || settings === void 0 ? void 0 : settings.focusableElementFilter) === null || _a === void 0 ? void 0 : _a.call(settings, e)) !== null && _b !== void 0 ? _b : true;\n    });\n    if (filteredElements.length === 0) {\n      return;\n    }\n    focusableElements.splice(findInsertionIndex(filteredElements), 0, ...filteredElements);\n    for (const element of filteredElements) {\n      if (!savedTabIndex.has(element)) {\n        savedTabIndex.set(element, element.getAttribute('tabindex'));\n      }\n      element.setAttribute('tabindex', '-1');\n    }\n    if (!currentFocusedElement) {\n      updateFocusedElement(getFirstFocusableElement());\n    }\n  }\n  function findInsertionIndex(elementsToInsert) {\n    const firstElementToInsert = elementsToInsert[0];\n    if (focusableElements.length === 0) return 0;\n    let iMin = 0;\n    let iMax = focusableElements.length - 1;\n    while (iMin <= iMax) {\n      const i = Math.floor((iMin + iMax) / 2);\n      const element = focusableElements[i];\n      if (followsInDocument(firstElementToInsert, element)) {\n        iMax = i - 1;\n      } else {\n        iMin = i + 1;\n      }\n    }\n    return iMin;\n  }\n  function followsInDocument(first, second) {\n    return (second.compareDocumentPosition(first) & Node.DOCUMENT_POSITION_PRECEDING) > 0;\n  }\n  function endFocusManagement(...elements) {\n    for (const element of elements) {\n      const focusableElementIndex = focusableElements.indexOf(element);\n      if (focusableElementIndex >= 0) {\n        focusableElements.splice(focusableElementIndex, 1);\n      }\n      const savedIndex = savedTabIndex.get(element);\n      if (savedIndex !== undefined) {\n        if (savedIndex === null) {\n          element.removeAttribute('tabindex');\n        } else {\n          element.setAttribute('tabindex', savedIndex);\n        }\n        savedTabIndex.delete(element);\n      }\n      if (element === currentFocusedElement) {\n        const nextElementToFocus = getFirstFocusableElement();\n        updateFocusedElement(nextElementToFocus);\n      }\n    }\n  }\n  const iterateFocusableElementsOptions = {\n    reverse: settings === null || settings === void 0 ? void 0 : settings.reverse,\n    strict: settings === null || settings === void 0 ? void 0 : settings.strict,\n    onlyTabbable: settings === null || settings === void 0 ? void 0 : settings.onlyTabbable\n  };\n  beginFocusManagement(...iterateFocusableElements(container, iterateFocusableElementsOptions));\n  const initialElement = typeof focusInStrategy === 'function' ? focusInStrategy(document.body) : getFirstFocusableElement();\n  updateFocusedElement(initialElement);\n  const observer = new MutationObserver(mutations => {\n    for (const mutation of mutations) {\n      for (const removedNode of mutation.removedNodes) {\n        if (removedNode instanceof HTMLElement) {\n          endFocusManagement(...iterateFocusableElements(removedNode, iterateFocusableElementsOptions));\n        }\n      }\n    }\n    for (const mutation of mutations) {\n      for (const addedNode of mutation.addedNodes) {\n        if (addedNode instanceof HTMLElement) {\n          beginFocusManagement(...iterateFocusableElements(addedNode, iterateFocusableElementsOptions));\n        }\n      }\n    }\n  });\n  observer.observe(container, {\n    subtree: true,\n    childList: true\n  });\n  const controller = new AbortController();\n  const signal = (_e = settings === null || settings === void 0 ? void 0 : settings.abortSignal) !== null && _e !== void 0 ? _e : controller.signal;\n  signal.addEventListener('abort', () => {\n    endFocusManagement(...focusableElements);\n  });\n  let elementIndexFocusedByClick = undefined;\n  container.addEventListener('mousedown', event => {\n    if (event.target instanceof HTMLElement && event.target !== document.activeElement) {\n      elementIndexFocusedByClick = focusableElements.indexOf(event.target);\n    }\n  }, {\n    signal\n  });\n  if (activeDescendantControl) {\n    container.addEventListener('focusin', event => {\n      if (event.target instanceof HTMLElement && focusableElements.includes(event.target)) {\n        activeDescendantControl.focus({\n          preventScroll\n        });\n        updateFocusedElement(event.target);\n      }\n    });\n    container.addEventListener('mousemove', ({\n      target\n    }) => {\n      if (!(target instanceof Node)) {\n        return;\n      }\n      const focusableElement = focusableElements.find(element => element.contains(target));\n      if (focusableElement) {\n        updateFocusedElement(focusableElement);\n      }\n    }, {\n      signal,\n      capture: true\n    });\n    activeDescendantControl.addEventListener('focusin', () => {\n      if (!currentFocusedElement) {\n        updateFocusedElement(getFirstFocusableElement());\n      } else {\n        setActiveDescendant(undefined, currentFocusedElement);\n      }\n    });\n    activeDescendantControl.addEventListener('focusout', () => {\n      clearActiveDescendant();\n    });\n  } else {\n    container.addEventListener('focusin', event => {\n      if (event.target instanceof HTMLElement) {\n        if (elementIndexFocusedByClick !== undefined) {\n          if (elementIndexFocusedByClick >= 0) {\n            if (focusableElements[elementIndexFocusedByClick] !== currentFocusedElement) {\n              updateFocusedElement(focusableElements[elementIndexFocusedByClick]);\n            }\n          }\n          elementIndexFocusedByClick = undefined;\n        } else {\n          if (focusInStrategy === 'previous') {\n            updateFocusedElement(event.target);\n          } else if (focusInStrategy === 'closest' || focusInStrategy === 'first') {\n            if (event.relatedTarget instanceof Element && !container.contains(event.relatedTarget)) {\n              const targetElementIndex = lastKeyboardFocusDirection === 'previous' ? focusableElements.length - 1 : 0;\n              const targetElement = focusableElements[targetElementIndex];\n              targetElement === null || targetElement === void 0 ? void 0 : targetElement.focus({\n                preventScroll\n              });\n              return;\n            } else {\n              updateFocusedElement(event.target);\n            }\n          } else if (typeof focusInStrategy === 'function') {\n            if (event.relatedTarget instanceof Element && !container.contains(event.relatedTarget)) {\n              const elementToFocus = focusInStrategy(event.relatedTarget);\n              const requestedFocusElementIndex = elementToFocus ? focusableElements.indexOf(elementToFocus) : -1;\n              if (requestedFocusElementIndex >= 0 && elementToFocus instanceof HTMLElement) {\n                elementToFocus.focus({\n                  preventScroll\n                });\n                return;\n              } else {\n                console.warn('Element requested is not a known focusable element.');\n              }\n            } else {\n              updateFocusedElement(event.target);\n            }\n          }\n        }\n      }\n      lastKeyboardFocusDirection = undefined;\n    }, {\n      signal\n    });\n  }\n  const keyboardEventRecipient = activeDescendantControl !== null && activeDescendantControl !== void 0 ? activeDescendantControl : container;\n  let lastKeyboardFocusDirection = undefined;\n  if (focusInStrategy === 'closest') {\n    document.addEventListener('keydown', event => {\n      if (event.key === 'Tab') {\n        lastKeyboardFocusDirection = getDirection(event);\n      }\n    }, {\n      signal,\n      capture: true\n    });\n  }\n  function getCurrentFocusedIndex() {\n    if (!currentFocusedElement) {\n      return 0;\n    }\n    const focusedIndex = focusableElements.indexOf(currentFocusedElement);\n    const fallbackIndex = currentFocusedElement === container ? -1 : 0;\n    return focusedIndex !== -1 ? focusedIndex : fallbackIndex;\n  }\n  keyboardEventRecipient.addEventListener('keydown', event => {\n    var _a;\n    if (event.key in KEY_TO_DIRECTION) {\n      const keyBit = KEY_TO_BIT[event.key];\n      if (!event.defaultPrevented && (keyBit & bindKeys) > 0 && !shouldIgnoreFocusHandling(event, document.activeElement)) {\n        const direction = getDirection(event);\n        let nextElementToFocus = undefined;\n        if (settings === null || settings === void 0 ? void 0 : settings.getNextFocusable) {\n          nextElementToFocus = settings.getNextFocusable(direction, (_a = document.activeElement) !== null && _a !== void 0 ? _a : undefined, event);\n        }\n        if (!nextElementToFocus) {\n          const lastFocusedIndex = getCurrentFocusedIndex();\n          let nextFocusedIndex = lastFocusedIndex;\n          if (direction === 'previous') {\n            nextFocusedIndex -= 1;\n          } else if (direction === 'start') {\n            nextFocusedIndex = 0;\n          } else if (direction === 'next') {\n            nextFocusedIndex += 1;\n          } else {\n            nextFocusedIndex = focusableElements.length - 1;\n          }\n          if (nextFocusedIndex < 0) {\n            if (focusOutBehavior === 'wrap' && event.key !== 'Tab') {\n              nextFocusedIndex = focusableElements.length - 1;\n            } else {\n              nextFocusedIndex = 0;\n            }\n          }\n          if (nextFocusedIndex >= focusableElements.length) {\n            if (focusOutBehavior === 'wrap' && event.key !== 'Tab') {\n              nextFocusedIndex = 0;\n            } else {\n              nextFocusedIndex = focusableElements.length - 1;\n            }\n          }\n          if (lastFocusedIndex !== nextFocusedIndex) {\n            nextElementToFocus = focusableElements[nextFocusedIndex];\n          }\n        }\n        if (activeDescendantControl) {\n          updateFocusedElement(nextElementToFocus || currentFocusedElement, true);\n        } else if (nextElementToFocus) {\n          lastKeyboardFocusDirection = direction;\n          nextElementToFocus.focus({\n            preventScroll\n          });\n        }\n        if (event.key !== 'Tab' || nextElementToFocus) {\n          event.preventDefault();\n        }\n      }\n    }\n  }, {\n    signal\n  });\n  return controller;\n}","map":{"version":3,"names":["polyfill","eventListenerSignalPolyfill","isMacOS","iterateFocusableElements","uniqueId","FocusKeys","KEY_TO_BIT","ArrowLeft","ArrowHorizontal","ArrowDown","ArrowVertical","ArrowUp","ArrowRight","h","HL","j","JK","k","l","a","AD","s","WS","w","d","Tab","Home","HomeAndEnd","End","PageUp","PageUpDown","PageDown","Backspace","KEY_TO_DIRECTION","getDirection","keyboardEvent","direction","key","shiftKey","isMac","metaKey","ctrlKey","shouldIgnoreFocusHandling","activeElement","keyLength","length","isTextInput","HTMLInputElement","type","HTMLTextAreaElement","HTMLSelectElement","altKey","textInput","cursorAtStart","selectionStart","selectionEnd","cursorAtEnd","value","isActiveDescendantAttribute","activeDescendantActivatedDirectly","activeDescendantActivatedIndirectly","hasActiveDescendantAttribute","focusZone","container","settings","_a","_b","_c","_d","_e","focusableElements","savedTabIndex","WeakMap","bindKeys","getNextFocusable","ArrowAll","focusOutBehavior","focusInStrategy","activeDescendantControl","activeDescendantCallback","onActiveDescendantChanged","currentFocusedElement","preventScroll","getFirstFocusableElement","isActiveDescendantInputFocused","document","updateFocusedElement","to","directlyActivated","from","setActiveDescendant","clearActiveDescendant","has","setAttribute","id","removeAttribute","getAttribute","previouslyActiveElement","undefined","beginFocusManagement","elements","filteredElements","filter","e","focusableElementFilter","call","splice","findInsertionIndex","element","set","elementsToInsert","firstElementToInsert","iMin","iMax","i","Math","floor","followsInDocument","first","second","compareDocumentPosition","Node","DOCUMENT_POSITION_PRECEDING","endFocusManagement","focusableElementIndex","indexOf","savedIndex","get","delete","nextElementToFocus","iterateFocusableElementsOptions","reverse","strict","onlyTabbable","initialElement","body","observer","MutationObserver","mutations","mutation","removedNode","removedNodes","HTMLElement","addedNode","addedNodes","observe","subtree","childList","controller","AbortController","signal","abortSignal","addEventListener","elementIndexFocusedByClick","event","target","includes","focus","focusableElement","find","contains","capture","relatedTarget","Element","targetElementIndex","lastKeyboardFocusDirection","targetElement","elementToFocus","requestedFocusElementIndex","console","warn","keyboardEventRecipient","getCurrentFocusedIndex","focusedIndex","fallbackIndex","keyBit","defaultPrevented","lastFocusedIndex","nextFocusedIndex","preventDefault"],"sources":["/Users/steve/Documents/repos/github/api-insights/node_modules/@primer/behaviors/dist/esm/focus-zone.js"],"sourcesContent":["import { polyfill as eventListenerSignalPolyfill } from './polyfills/event-listener-signal.js';\nimport { isMacOS } from './utils/user-agent.js';\nimport { iterateFocusableElements } from './utils/iterate-focusable-elements.js';\nimport { uniqueId } from './utils/unique-id.js';\neventListenerSignalPolyfill();\nexport var FocusKeys;\n(function (FocusKeys) {\n    FocusKeys[FocusKeys[\"ArrowHorizontal\"] = 1] = \"ArrowHorizontal\";\n    FocusKeys[FocusKeys[\"ArrowVertical\"] = 2] = \"ArrowVertical\";\n    FocusKeys[FocusKeys[\"JK\"] = 4] = \"JK\";\n    FocusKeys[FocusKeys[\"HL\"] = 8] = \"HL\";\n    FocusKeys[FocusKeys[\"HomeAndEnd\"] = 16] = \"HomeAndEnd\";\n    FocusKeys[FocusKeys[\"PageUpDown\"] = 256] = \"PageUpDown\";\n    FocusKeys[FocusKeys[\"WS\"] = 32] = \"WS\";\n    FocusKeys[FocusKeys[\"AD\"] = 64] = \"AD\";\n    FocusKeys[FocusKeys[\"Tab\"] = 128] = \"Tab\";\n    FocusKeys[FocusKeys[\"Backspace\"] = 512] = \"Backspace\";\n    FocusKeys[FocusKeys[\"ArrowAll\"] = 3] = \"ArrowAll\";\n    FocusKeys[FocusKeys[\"HJKL\"] = 12] = \"HJKL\";\n    FocusKeys[FocusKeys[\"WASD\"] = 96] = \"WASD\";\n    FocusKeys[FocusKeys[\"All\"] = 511] = \"All\";\n})(FocusKeys || (FocusKeys = {}));\nconst KEY_TO_BIT = {\n    ArrowLeft: FocusKeys.ArrowHorizontal,\n    ArrowDown: FocusKeys.ArrowVertical,\n    ArrowUp: FocusKeys.ArrowVertical,\n    ArrowRight: FocusKeys.ArrowHorizontal,\n    h: FocusKeys.HL,\n    j: FocusKeys.JK,\n    k: FocusKeys.JK,\n    l: FocusKeys.HL,\n    a: FocusKeys.AD,\n    s: FocusKeys.WS,\n    w: FocusKeys.WS,\n    d: FocusKeys.AD,\n    Tab: FocusKeys.Tab,\n    Home: FocusKeys.HomeAndEnd,\n    End: FocusKeys.HomeAndEnd,\n    PageUp: FocusKeys.PageUpDown,\n    PageDown: FocusKeys.PageUpDown,\n    Backspace: FocusKeys.Backspace,\n};\nconst KEY_TO_DIRECTION = {\n    ArrowLeft: 'previous',\n    ArrowDown: 'next',\n    ArrowUp: 'previous',\n    ArrowRight: 'next',\n    h: 'previous',\n    j: 'next',\n    k: 'previous',\n    l: 'next',\n    a: 'previous',\n    s: 'next',\n    w: 'previous',\n    d: 'next',\n    Tab: 'next',\n    Home: 'start',\n    End: 'end',\n    PageUp: 'start',\n    PageDown: 'end',\n    Backspace: 'previous',\n};\nfunction getDirection(keyboardEvent) {\n    const direction = KEY_TO_DIRECTION[keyboardEvent.key];\n    if (keyboardEvent.key === 'Tab' && keyboardEvent.shiftKey) {\n        return 'previous';\n    }\n    const isMac = isMacOS();\n    if ((isMac && keyboardEvent.metaKey) || (!isMac && keyboardEvent.ctrlKey)) {\n        if (keyboardEvent.key === 'ArrowLeft' || keyboardEvent.key === 'ArrowUp') {\n            return 'start';\n        }\n        else if (keyboardEvent.key === 'ArrowRight' || keyboardEvent.key === 'ArrowDown') {\n            return 'end';\n        }\n    }\n    return direction;\n}\nfunction shouldIgnoreFocusHandling(keyboardEvent, activeElement) {\n    const key = keyboardEvent.key;\n    const keyLength = [...key].length;\n    const isTextInput = (activeElement instanceof HTMLInputElement && activeElement.type === 'text') ||\n        activeElement instanceof HTMLTextAreaElement;\n    if (isTextInput && (keyLength === 1 || key === 'Home' || key === 'End')) {\n        return true;\n    }\n    if (activeElement instanceof HTMLSelectElement) {\n        if (keyLength === 1) {\n            return true;\n        }\n        if (key === 'ArrowDown' && isMacOS() && !keyboardEvent.metaKey) {\n            return true;\n        }\n        if (key === 'ArrowDown' && !isMacOS() && keyboardEvent.altKey) {\n            return true;\n        }\n    }\n    if (activeElement instanceof HTMLTextAreaElement && (key === 'PageUp' || key === 'PageDown')) {\n        return true;\n    }\n    if (isTextInput) {\n        const textInput = activeElement;\n        const cursorAtStart = textInput.selectionStart === 0 && textInput.selectionEnd === 0;\n        const cursorAtEnd = textInput.selectionStart === textInput.value.length && textInput.selectionEnd === textInput.value.length;\n        if (key === 'ArrowLeft' && !cursorAtStart) {\n            return true;\n        }\n        if (key === 'ArrowRight' && !cursorAtEnd) {\n            return true;\n        }\n        if (textInput instanceof HTMLTextAreaElement) {\n            if (key === 'ArrowUp' && !cursorAtStart) {\n                return true;\n            }\n            if (key === 'ArrowDown' && !cursorAtEnd) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nexport const isActiveDescendantAttribute = 'data-is-active-descendant';\nexport const activeDescendantActivatedDirectly = 'activated-directly';\nexport const activeDescendantActivatedIndirectly = 'activated-indirectly';\nexport const hasActiveDescendantAttribute = 'data-has-active-descendant';\nexport function focusZone(container, settings) {\n    var _a, _b, _c, _d, _e;\n    const focusableElements = [];\n    const savedTabIndex = new WeakMap();\n    const bindKeys = (_a = settings === null || settings === void 0 ? void 0 : settings.bindKeys) !== null && _a !== void 0 ? _a : ((settings === null || settings === void 0 ? void 0 : settings.getNextFocusable) ? FocusKeys.ArrowAll : FocusKeys.ArrowVertical) | FocusKeys.HomeAndEnd;\n    const focusOutBehavior = (_b = settings === null || settings === void 0 ? void 0 : settings.focusOutBehavior) !== null && _b !== void 0 ? _b : 'stop';\n    const focusInStrategy = (_c = settings === null || settings === void 0 ? void 0 : settings.focusInStrategy) !== null && _c !== void 0 ? _c : 'previous';\n    const activeDescendantControl = settings === null || settings === void 0 ? void 0 : settings.activeDescendantControl;\n    const activeDescendantCallback = settings === null || settings === void 0 ? void 0 : settings.onActiveDescendantChanged;\n    let currentFocusedElement;\n    const preventScroll = (_d = settings === null || settings === void 0 ? void 0 : settings.preventScroll) !== null && _d !== void 0 ? _d : false;\n    function getFirstFocusableElement() {\n        return focusableElements[0];\n    }\n    function isActiveDescendantInputFocused() {\n        return document.activeElement === activeDescendantControl;\n    }\n    function updateFocusedElement(to, directlyActivated = false) {\n        const from = currentFocusedElement;\n        currentFocusedElement = to;\n        if (activeDescendantControl) {\n            if (to && isActiveDescendantInputFocused()) {\n                setActiveDescendant(from, to, directlyActivated);\n            }\n            else {\n                clearActiveDescendant();\n            }\n            return;\n        }\n        if (from && from !== to && savedTabIndex.has(from)) {\n            from.setAttribute('tabindex', '-1');\n        }\n        to === null || to === void 0 ? void 0 : to.setAttribute('tabindex', '0');\n    }\n    function setActiveDescendant(from, to, directlyActivated = false) {\n        if (!to.id) {\n            to.setAttribute('id', uniqueId());\n        }\n        if (from && from !== to) {\n            from.removeAttribute(isActiveDescendantAttribute);\n        }\n        if (!activeDescendantControl ||\n            (!directlyActivated && activeDescendantControl.getAttribute('aria-activedescendant') === to.id)) {\n            return;\n        }\n        activeDescendantControl.setAttribute('aria-activedescendant', to.id);\n        container.setAttribute(hasActiveDescendantAttribute, to.id);\n        to.setAttribute(isActiveDescendantAttribute, directlyActivated ? activeDescendantActivatedDirectly : activeDescendantActivatedIndirectly);\n        activeDescendantCallback === null || activeDescendantCallback === void 0 ? void 0 : activeDescendantCallback(to, from, directlyActivated);\n    }\n    function clearActiveDescendant(previouslyActiveElement = currentFocusedElement) {\n        if (focusInStrategy === 'first') {\n            currentFocusedElement = undefined;\n        }\n        activeDescendantControl === null || activeDescendantControl === void 0 ? void 0 : activeDescendantControl.removeAttribute('aria-activedescendant');\n        container.removeAttribute(hasActiveDescendantAttribute);\n        previouslyActiveElement === null || previouslyActiveElement === void 0 ? void 0 : previouslyActiveElement.removeAttribute(isActiveDescendantAttribute);\n        activeDescendantCallback === null || activeDescendantCallback === void 0 ? void 0 : activeDescendantCallback(undefined, previouslyActiveElement, false);\n    }\n    function beginFocusManagement(...elements) {\n        const filteredElements = elements.filter(e => { var _a, _b; return (_b = (_a = settings === null || settings === void 0 ? void 0 : settings.focusableElementFilter) === null || _a === void 0 ? void 0 : _a.call(settings, e)) !== null && _b !== void 0 ? _b : true; });\n        if (filteredElements.length === 0) {\n            return;\n        }\n        focusableElements.splice(findInsertionIndex(filteredElements), 0, ...filteredElements);\n        for (const element of filteredElements) {\n            if (!savedTabIndex.has(element)) {\n                savedTabIndex.set(element, element.getAttribute('tabindex'));\n            }\n            element.setAttribute('tabindex', '-1');\n        }\n        if (!currentFocusedElement) {\n            updateFocusedElement(getFirstFocusableElement());\n        }\n    }\n    function findInsertionIndex(elementsToInsert) {\n        const firstElementToInsert = elementsToInsert[0];\n        if (focusableElements.length === 0)\n            return 0;\n        let iMin = 0;\n        let iMax = focusableElements.length - 1;\n        while (iMin <= iMax) {\n            const i = Math.floor((iMin + iMax) / 2);\n            const element = focusableElements[i];\n            if (followsInDocument(firstElementToInsert, element)) {\n                iMax = i - 1;\n            }\n            else {\n                iMin = i + 1;\n            }\n        }\n        return iMin;\n    }\n    function followsInDocument(first, second) {\n        return (second.compareDocumentPosition(first) & Node.DOCUMENT_POSITION_PRECEDING) > 0;\n    }\n    function endFocusManagement(...elements) {\n        for (const element of elements) {\n            const focusableElementIndex = focusableElements.indexOf(element);\n            if (focusableElementIndex >= 0) {\n                focusableElements.splice(focusableElementIndex, 1);\n            }\n            const savedIndex = savedTabIndex.get(element);\n            if (savedIndex !== undefined) {\n                if (savedIndex === null) {\n                    element.removeAttribute('tabindex');\n                }\n                else {\n                    element.setAttribute('tabindex', savedIndex);\n                }\n                savedTabIndex.delete(element);\n            }\n            if (element === currentFocusedElement) {\n                const nextElementToFocus = getFirstFocusableElement();\n                updateFocusedElement(nextElementToFocus);\n            }\n        }\n    }\n    const iterateFocusableElementsOptions = {\n        reverse: settings === null || settings === void 0 ? void 0 : settings.reverse,\n        strict: settings === null || settings === void 0 ? void 0 : settings.strict,\n        onlyTabbable: settings === null || settings === void 0 ? void 0 : settings.onlyTabbable,\n    };\n    beginFocusManagement(...iterateFocusableElements(container, iterateFocusableElementsOptions));\n    const initialElement = typeof focusInStrategy === 'function' ? focusInStrategy(document.body) : getFirstFocusableElement();\n    updateFocusedElement(initialElement);\n    const observer = new MutationObserver(mutations => {\n        for (const mutation of mutations) {\n            for (const removedNode of mutation.removedNodes) {\n                if (removedNode instanceof HTMLElement) {\n                    endFocusManagement(...iterateFocusableElements(removedNode, iterateFocusableElementsOptions));\n                }\n            }\n        }\n        for (const mutation of mutations) {\n            for (const addedNode of mutation.addedNodes) {\n                if (addedNode instanceof HTMLElement) {\n                    beginFocusManagement(...iterateFocusableElements(addedNode, iterateFocusableElementsOptions));\n                }\n            }\n        }\n    });\n    observer.observe(container, {\n        subtree: true,\n        childList: true,\n    });\n    const controller = new AbortController();\n    const signal = (_e = settings === null || settings === void 0 ? void 0 : settings.abortSignal) !== null && _e !== void 0 ? _e : controller.signal;\n    signal.addEventListener('abort', () => {\n        endFocusManagement(...focusableElements);\n    });\n    let elementIndexFocusedByClick = undefined;\n    container.addEventListener('mousedown', event => {\n        if (event.target instanceof HTMLElement && event.target !== document.activeElement) {\n            elementIndexFocusedByClick = focusableElements.indexOf(event.target);\n        }\n    }, { signal });\n    if (activeDescendantControl) {\n        container.addEventListener('focusin', event => {\n            if (event.target instanceof HTMLElement && focusableElements.includes(event.target)) {\n                activeDescendantControl.focus({ preventScroll });\n                updateFocusedElement(event.target);\n            }\n        });\n        container.addEventListener('mousemove', ({ target }) => {\n            if (!(target instanceof Node)) {\n                return;\n            }\n            const focusableElement = focusableElements.find(element => element.contains(target));\n            if (focusableElement) {\n                updateFocusedElement(focusableElement);\n            }\n        }, { signal, capture: true });\n        activeDescendantControl.addEventListener('focusin', () => {\n            if (!currentFocusedElement) {\n                updateFocusedElement(getFirstFocusableElement());\n            }\n            else {\n                setActiveDescendant(undefined, currentFocusedElement);\n            }\n        });\n        activeDescendantControl.addEventListener('focusout', () => {\n            clearActiveDescendant();\n        });\n    }\n    else {\n        container.addEventListener('focusin', event => {\n            if (event.target instanceof HTMLElement) {\n                if (elementIndexFocusedByClick !== undefined) {\n                    if (elementIndexFocusedByClick >= 0) {\n                        if (focusableElements[elementIndexFocusedByClick] !== currentFocusedElement) {\n                            updateFocusedElement(focusableElements[elementIndexFocusedByClick]);\n                        }\n                    }\n                    elementIndexFocusedByClick = undefined;\n                }\n                else {\n                    if (focusInStrategy === 'previous') {\n                        updateFocusedElement(event.target);\n                    }\n                    else if (focusInStrategy === 'closest' || focusInStrategy === 'first') {\n                        if (event.relatedTarget instanceof Element && !container.contains(event.relatedTarget)) {\n                            const targetElementIndex = lastKeyboardFocusDirection === 'previous' ? focusableElements.length - 1 : 0;\n                            const targetElement = focusableElements[targetElementIndex];\n                            targetElement === null || targetElement === void 0 ? void 0 : targetElement.focus({ preventScroll });\n                            return;\n                        }\n                        else {\n                            updateFocusedElement(event.target);\n                        }\n                    }\n                    else if (typeof focusInStrategy === 'function') {\n                        if (event.relatedTarget instanceof Element && !container.contains(event.relatedTarget)) {\n                            const elementToFocus = focusInStrategy(event.relatedTarget);\n                            const requestedFocusElementIndex = elementToFocus ? focusableElements.indexOf(elementToFocus) : -1;\n                            if (requestedFocusElementIndex >= 0 && elementToFocus instanceof HTMLElement) {\n                                elementToFocus.focus({ preventScroll });\n                                return;\n                            }\n                            else {\n                                console.warn('Element requested is not a known focusable element.');\n                            }\n                        }\n                        else {\n                            updateFocusedElement(event.target);\n                        }\n                    }\n                }\n            }\n            lastKeyboardFocusDirection = undefined;\n        }, { signal });\n    }\n    const keyboardEventRecipient = activeDescendantControl !== null && activeDescendantControl !== void 0 ? activeDescendantControl : container;\n    let lastKeyboardFocusDirection = undefined;\n    if (focusInStrategy === 'closest') {\n        document.addEventListener('keydown', event => {\n            if (event.key === 'Tab') {\n                lastKeyboardFocusDirection = getDirection(event);\n            }\n        }, { signal, capture: true });\n    }\n    function getCurrentFocusedIndex() {\n        if (!currentFocusedElement) {\n            return 0;\n        }\n        const focusedIndex = focusableElements.indexOf(currentFocusedElement);\n        const fallbackIndex = currentFocusedElement === container ? -1 : 0;\n        return focusedIndex !== -1 ? focusedIndex : fallbackIndex;\n    }\n    keyboardEventRecipient.addEventListener('keydown', event => {\n        var _a;\n        if (event.key in KEY_TO_DIRECTION) {\n            const keyBit = KEY_TO_BIT[event.key];\n            if (!event.defaultPrevented &&\n                (keyBit & bindKeys) > 0 &&\n                !shouldIgnoreFocusHandling(event, document.activeElement)) {\n                const direction = getDirection(event);\n                let nextElementToFocus = undefined;\n                if (settings === null || settings === void 0 ? void 0 : settings.getNextFocusable) {\n                    nextElementToFocus = settings.getNextFocusable(direction, (_a = document.activeElement) !== null && _a !== void 0 ? _a : undefined, event);\n                }\n                if (!nextElementToFocus) {\n                    const lastFocusedIndex = getCurrentFocusedIndex();\n                    let nextFocusedIndex = lastFocusedIndex;\n                    if (direction === 'previous') {\n                        nextFocusedIndex -= 1;\n                    }\n                    else if (direction === 'start') {\n                        nextFocusedIndex = 0;\n                    }\n                    else if (direction === 'next') {\n                        nextFocusedIndex += 1;\n                    }\n                    else {\n                        nextFocusedIndex = focusableElements.length - 1;\n                    }\n                    if (nextFocusedIndex < 0) {\n                        if (focusOutBehavior === 'wrap' && event.key !== 'Tab') {\n                            nextFocusedIndex = focusableElements.length - 1;\n                        }\n                        else {\n                            nextFocusedIndex = 0;\n                        }\n                    }\n                    if (nextFocusedIndex >= focusableElements.length) {\n                        if (focusOutBehavior === 'wrap' && event.key !== 'Tab') {\n                            nextFocusedIndex = 0;\n                        }\n                        else {\n                            nextFocusedIndex = focusableElements.length - 1;\n                        }\n                    }\n                    if (lastFocusedIndex !== nextFocusedIndex) {\n                        nextElementToFocus = focusableElements[nextFocusedIndex];\n                    }\n                }\n                if (activeDescendantControl) {\n                    updateFocusedElement(nextElementToFocus || currentFocusedElement, true);\n                }\n                else if (nextElementToFocus) {\n                    lastKeyboardFocusDirection = direction;\n                    nextElementToFocus.focus({ preventScroll });\n                }\n                if (event.key !== 'Tab' || nextElementToFocus) {\n                    event.preventDefault();\n                }\n            }\n        }\n    }, { signal });\n    return controller;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}