{"ast":null,"code":"import { useRef, useEffect, useCallback } from 'react';\nimport useIsomorphicLayoutEffect from '../../utils/useIsomorphicLayoutEffect.js';\nconst callbackCancelledResult = Symbol('callbackCancelledResult');\n/**\n * Making async callbacks within React components is risky and error-prone. It's easy to\n * accidentally call an outdated reference to the function, or to call it after the\n * component has unmounted.\n *\n * This hook solves these problems by returning a function that is referentially constant\n * (it can never be outdated) and will have no effect if called after unmounting. If the\n * callback is cancelled due to calling after unmounting, the returned value will be\n * the unique symbol `callbackCancelledResult`.\n *\n * This callback is safe to call after `await`ing a `Promise` (or in the `.then` clause of a\n * `Promise`) and in `setTimeout`.\n *\n * @param fn the function to call\n * @param allowCallingAfterUnmount If the component is unmounted, should this be called?\n * This should typically be `false` but may be desirable in cases where user's changes would\n * not get saved unless the call is made, so the call can be made in the background after\n * unmount. If this is `true`, it's very important not to set state in this callback!\n *\n * @deprecated Will be removed in v37 (https://github.com/primer/react/issues/3604)\n */\nconst useSafeAsyncCallback = (fn, allowCallingAfterUnmount = false) => {\n  const trackingRef = useRef(fn);\n  useIsomorphicLayoutEffect(() => {\n    trackingRef.current = fn;\n  }, [fn]);\n  const isMountedRef = useRef(false);\n  useEffect(() => {\n    isMountedRef.current = true;\n    return () => {\n      if (!allowCallingAfterUnmount) isMountedRef.current = false;\n    };\n  }, [allowCallingAfterUnmount]);\n  return useCallback((...args) => isMountedRef.current ? trackingRef.current(...args) : callbackCancelledResult, [] // this dependency array must always be empty\n  );\n};\nexport { callbackCancelledResult, useSafeAsyncCallback };","map":{"version":3,"names":["useRef","useEffect","useCallback","useIsomorphicLayoutEffect","callbackCancelledResult","Symbol","useSafeAsyncCallback","fn","allowCallingAfterUnmount","trackingRef","current","isMountedRef","args"],"sources":["/Users/steve/Documents/repos/github/api-insights/node_modules/@primer/react/lib-esm/drafts/hooks/useSafeAsyncCallback.js"],"sourcesContent":["import { useRef, useEffect, useCallback } from 'react';\nimport useIsomorphicLayoutEffect from '../../utils/useIsomorphicLayoutEffect.js';\n\nconst callbackCancelledResult = Symbol('callbackCancelledResult');\n/**\n * Making async callbacks within React components is risky and error-prone. It's easy to\n * accidentally call an outdated reference to the function, or to call it after the\n * component has unmounted.\n *\n * This hook solves these problems by returning a function that is referentially constant\n * (it can never be outdated) and will have no effect if called after unmounting. If the\n * callback is cancelled due to calling after unmounting, the returned value will be\n * the unique symbol `callbackCancelledResult`.\n *\n * This callback is safe to call after `await`ing a `Promise` (or in the `.then` clause of a\n * `Promise`) and in `setTimeout`.\n *\n * @param fn the function to call\n * @param allowCallingAfterUnmount If the component is unmounted, should this be called?\n * This should typically be `false` but may be desirable in cases where user's changes would\n * not get saved unless the call is made, so the call can be made in the background after\n * unmount. If this is `true`, it's very important not to set state in this callback!\n *\n * @deprecated Will be removed in v37 (https://github.com/primer/react/issues/3604)\n */\nconst useSafeAsyncCallback = (fn, allowCallingAfterUnmount = false) => {\n  const trackingRef = useRef(fn);\n  useIsomorphicLayoutEffect(() => {\n    trackingRef.current = fn;\n  }, [fn]);\n  const isMountedRef = useRef(false);\n  useEffect(() => {\n    isMountedRef.current = true;\n    return () => {\n      if (!allowCallingAfterUnmount) isMountedRef.current = false;\n    };\n  }, [allowCallingAfterUnmount]);\n  return useCallback((...args) => isMountedRef.current ? trackingRef.current(...args) : callbackCancelledResult, [] // this dependency array must always be empty\n  );\n};\n\nexport { callbackCancelledResult, useSafeAsyncCallback };\n"],"mappings":"AAAA,SAASA,MAAM,EAAEC,SAAS,EAAEC,WAAW,QAAQ,OAAO;AACtD,OAAOC,yBAAyB,MAAM,0CAA0C;AAEhF,MAAMC,uBAAuB,GAAGC,MAAM,CAAC,yBAAyB,CAAC;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,oBAAoB,GAAGA,CAACC,EAAE,EAAEC,wBAAwB,GAAG,KAAK,KAAK;EACrE,MAAMC,WAAW,GAAGT,MAAM,CAACO,EAAE,CAAC;EAC9BJ,yBAAyB,CAAC,MAAM;IAC9BM,WAAW,CAACC,OAAO,GAAGH,EAAE;EAC1B,CAAC,EAAE,CAACA,EAAE,CAAC,CAAC;EACR,MAAMI,YAAY,GAAGX,MAAM,CAAC,KAAK,CAAC;EAClCC,SAAS,CAAC,MAAM;IACdU,YAAY,CAACD,OAAO,GAAG,IAAI;IAC3B,OAAO,MAAM;MACX,IAAI,CAACF,wBAAwB,EAAEG,YAAY,CAACD,OAAO,GAAG,KAAK;IAC7D,CAAC;EACH,CAAC,EAAE,CAACF,wBAAwB,CAAC,CAAC;EAC9B,OAAON,WAAW,CAAC,CAAC,GAAGU,IAAI,KAAKD,YAAY,CAACD,OAAO,GAAGD,WAAW,CAACC,OAAO,CAAC,GAAGE,IAAI,CAAC,GAAGR,uBAAuB,EAAE,EAAE,CAAC;EAClH,CAAC;AACH,CAAC;AAED,SAASA,uBAAuB,EAAEE,oBAAoB"},"metadata":{},"sourceType":"module","externalDependencies":[]}