{"ast":null,"code":"import React, { useRef, cloneElement } from 'react';\nimport Box from '../../Box/Box.js';\nimport { Portal } from '../../Portal/Portal.js';\nimport { useSyntheticChange } from '../hooks/useSyntheticChange.js';\nimport { getAbsoluteCharacterCoordinates } from '../utils/character-coordinates.js';\nimport { requireChildrenToBeInput, augmentHandler, getSuggestionValue, calculateSuggestionsQuery } from './utils.js';\nimport '@primer/behaviors/utils';\nimport '@primer/behaviors';\nimport { useRefObjectAsForwardedRef } from '../../hooks/useRefObjectAsForwardedRef.js';\nimport AutocompleteSuggestions from './_AutocompleteSuggestions.js';\nimport { useFormControlForwardedProps } from '../../FormControl/_FormControlContext.js';\nimport '../../FormControl/FormControl.js';\nconst getSelectionStart = element => {\n  try {\n    return element.selectionStart;\n  } catch (e) {\n    // Safari throws an exception when trying to access selectionStart on date input element\n    if (e instanceof TypeError) return null;\n    throw e;\n  }\n};\nconst noop = () => {\n  // don't do anything\n};\n\n/**\n * Shows suggestions to complete the current word/phrase the user is actively typing.\n * @deprecated Will be removed in v37 (https://github.com/primer/react/issues/3604)\n */\nconst InlineAutocomplete = ({\n  triggers,\n  suggestions,\n  onShowSuggestions,\n  onHideSuggestions,\n  onSelectSuggestion,\n  sx,\n  children,\n  tabInsertsSuggestions = false,\n  suggestionsPlacement = 'below',\n  ...externalInputProps\n}) => {\n  var _children$ref, _externalInput$props$, _getSelectionStart;\n  const inputProps = useFormControlForwardedProps(externalInputProps);\n  const inputRef = useRef(null);\n  useRefObjectAsForwardedRef((_children$ref = children.ref) !== null && _children$ref !== void 0 ? _children$ref : noop, inputRef);\n  const externalInput = requireChildrenToBeInput(children, inputRef);\n  const emitSyntheticChange = useSyntheticChange({\n    inputRef,\n    fallbackEventHandler: (_externalInput$props$ = externalInput.props.onChange) !== null && _externalInput$props$ !== void 0 ? _externalInput$props$ : noop\n  });\n\n  /** Stores the query that caused the current suggestion list to appear. */\n  const showEventRef = useRef(null);\n  const suggestionsVisible = suggestions !== null && suggestions.length > 0;\n\n  // The suggestions don't usually move while open, so it seems as though this could be\n  // optimized by only re-rendering when suggestionsVisible changes. However, the user\n  // could move the cursor to a different location using arrow keys and then type a\n  // trigger, which would move the suggestions without closing/reopening them.\n  const triggerCharCoords = inputRef.current && showEventRef.current && suggestionsVisible ? getAbsoluteCharacterCoordinates(inputRef.current, ((_getSelectionStart = getSelectionStart(inputRef.current)) !== null && _getSelectionStart !== void 0 ? _getSelectionStart : 0) - showEventRef.current.query.length) : {\n    top: 0,\n    left: 0,\n    height: 0\n  };\n\n  // User can blur while suggestions are visible with shift+tab\n  const onBlur = () => {\n    onHideSuggestions();\n  };\n\n  // Even though the overlay has an Escape listener, it only works when focus is inside\n  // the overlay; in this case the textarea is focused\n  const onKeyDown = event => {\n    if (suggestionsVisible && event.key === 'Escape') {\n      onHideSuggestions();\n      event.stopPropagation();\n    }\n  };\n  const onChange = event => {\n    const selectionStart = getSelectionStart(event.currentTarget);\n    if (selectionStart === null) {\n      onHideSuggestions();\n      return;\n    }\n    showEventRef.current = calculateSuggestionsQuery(triggers, event.currentTarget.value, selectionStart);\n    if (showEventRef.current) {\n      onShowSuggestions(showEventRef.current);\n    } else {\n      onHideSuggestions();\n    }\n  };\n  const onCommit = suggestion => {\n    var _getSelectionStart2, _trigger$keepTriggerC;\n    if (!inputRef.current || !showEventRef.current) return;\n    const {\n      query,\n      trigger\n    } = showEventRef.current;\n    onSelectSuggestion === null || onSelectSuggestion === void 0 ? void 0 : onSelectSuggestion({\n      suggestion,\n      trigger,\n      query\n    });\n    const currentCaretPosition = (_getSelectionStart2 = getSelectionStart(inputRef.current)) !== null && _getSelectionStart2 !== void 0 ? _getSelectionStart2 : 0;\n    const deleteLength = query.length + trigger.triggerChar.length;\n    const startIndex = currentCaretPosition - deleteLength;\n    const keepTriggerChar = (_trigger$keepTriggerC = trigger.keepTriggerCharOnCommit) !== null && _trigger$keepTriggerC !== void 0 ? _trigger$keepTriggerC : true;\n    const maybeTriggerChar = keepTriggerChar ? trigger.triggerChar : '';\n    const replacement = `${maybeTriggerChar}${suggestion} `;\n    emitSyntheticChange(replacement, [startIndex, startIndex + deleteLength]);\n    onHideSuggestions();\n  };\n  const input = /*#__PURE__*/cloneElement(externalInput, {\n    ...inputProps,\n    onBlur: augmentHandler(externalInput.props.onBlur, onBlur),\n    onKeyDown: augmentHandler(externalInput.props.onKeyDown, onKeyDown),\n    onChange: augmentHandler(externalInput.props.onChange, onChange),\n    ref: inputRef\n  });\n\n  /**\n   * Even though we apply all the aria attributes, screen readers don't fully support this\n   * dynamic use case and so they don't have a native way to indicate to the user when\n   * there are suggestions available. So we use some hidden text with aria-live to politely\n   * indicate what's available and how to use it.\n   *\n   * This text should be consistent and the important info should be first, because users\n   * will hear it as they type - if they have heard the message before they should be able\n   * to recognize it and quickly apply the first suggestion without listening to the rest\n   * of the message.\n   *\n   * When screen reader users navigate using arrow keys, the `aria-activedescendant` will\n   * change and will be read out so we don't need to handle that interaction here.\n   */\n  const suggestionsDescription = !suggestionsVisible ? '' : suggestions === 'loading' ? 'Loading autocomplete suggestionsâ€¦' :\n  // It's important to include both Enter and Tab because we are telling the user that we are hijacking these keys:\n  `${suggestions.length} autocomplete ${suggestions.length === 1 ? 'suggestion' : 'suggestions'} available; \"${getSuggestionValue(suggestions[0])}\" is highlighted. Press ${tabInsertsSuggestions ? 'Enter or Tab' : 'Enter'} to insert.`;\n  return /*#__PURE__*/(\n    // Try to get as close as possible to making the container 'invisible' by making it shrink tight to child input\n    React.createElement(Box, {\n      sx: {\n        display: 'inline-block',\n        '& > *': {\n          width: '100%'\n        },\n        ...sx,\n        position: 'relative'\n      }\n    }, input, /*#__PURE__*/React.createElement(AutocompleteSuggestions, {\n      suggestions: suggestions,\n      inputRef: inputRef,\n      onCommit: onCommit,\n      onClose: onHideSuggestions,\n      triggerCharCoords: triggerCharCoords,\n      visible: suggestionsVisible,\n      tabInsertsSuggestions: tabInsertsSuggestions,\n      defaultPlacement: suggestionsPlacement\n    }), /*#__PURE__*/React.createElement(Portal, null, /*#__PURE__*/React.createElement(\"span\", {\n      \"aria-live\": \"assertive\",\n      \"aria-atomic\": true,\n      style: {\n        clipPath: 'circle(0)',\n        position: 'absolute'\n      }\n    }, suggestionsDescription)))\n  );\n};\nInlineAutocomplete.displayName = \"InlineAutocomplete\";\nexport { InlineAutocomplete as default };","map":{"version":3,"names":["React","useRef","cloneElement","Box","Portal","useSyntheticChange","getAbsoluteCharacterCoordinates","requireChildrenToBeInput","augmentHandler","getSuggestionValue","calculateSuggestionsQuery","useRefObjectAsForwardedRef","AutocompleteSuggestions","useFormControlForwardedProps","getSelectionStart","element","selectionStart","e","TypeError","noop","InlineAutocomplete","triggers","suggestions","onShowSuggestions","onHideSuggestions","onSelectSuggestion","sx","children","tabInsertsSuggestions","suggestionsPlacement","externalInputProps","_children$ref","_externalInput$props$","_getSelectionStart","inputProps","inputRef","ref","externalInput","emitSyntheticChange","fallbackEventHandler","props","onChange","showEventRef","suggestionsVisible","length","triggerCharCoords","current","query","top","left","height","onBlur","onKeyDown","event","key","stopPropagation","currentTarget","value","onCommit","suggestion","_getSelectionStart2","_trigger$keepTriggerC","trigger","currentCaretPosition","deleteLength","triggerChar","startIndex","keepTriggerChar","keepTriggerCharOnCommit","maybeTriggerChar","replacement","input","suggestionsDescription","createElement","display","width","position","onClose","visible","defaultPlacement","style","clipPath","displayName","default"],"sources":["/Users/steve/Documents/repos/github/api-insights/node_modules/@primer/react/lib-esm/drafts/InlineAutocomplete/InlineAutocomplete.js"],"sourcesContent":["import React, { useRef, cloneElement } from 'react';\nimport Box from '../../Box/Box.js';\nimport { Portal } from '../../Portal/Portal.js';\nimport { useSyntheticChange } from '../hooks/useSyntheticChange.js';\nimport { getAbsoluteCharacterCoordinates } from '../utils/character-coordinates.js';\nimport { requireChildrenToBeInput, augmentHandler, getSuggestionValue, calculateSuggestionsQuery } from './utils.js';\nimport '@primer/behaviors/utils';\nimport '@primer/behaviors';\nimport { useRefObjectAsForwardedRef } from '../../hooks/useRefObjectAsForwardedRef.js';\nimport AutocompleteSuggestions from './_AutocompleteSuggestions.js';\nimport { useFormControlForwardedProps } from '../../FormControl/_FormControlContext.js';\nimport '../../FormControl/FormControl.js';\n\nconst getSelectionStart = element => {\n  try {\n    return element.selectionStart;\n  } catch (e) {\n    // Safari throws an exception when trying to access selectionStart on date input element\n    if (e instanceof TypeError) return null;\n    throw e;\n  }\n};\nconst noop = () => {\n  // don't do anything\n};\n\n/**\n * Shows suggestions to complete the current word/phrase the user is actively typing.\n * @deprecated Will be removed in v37 (https://github.com/primer/react/issues/3604)\n */\nconst InlineAutocomplete = ({\n  triggers,\n  suggestions,\n  onShowSuggestions,\n  onHideSuggestions,\n  onSelectSuggestion,\n  sx,\n  children,\n  tabInsertsSuggestions = false,\n  suggestionsPlacement = 'below',\n  ...externalInputProps\n}) => {\n  var _children$ref, _externalInput$props$, _getSelectionStart;\n  const inputProps = useFormControlForwardedProps(externalInputProps);\n  const inputRef = useRef(null);\n  useRefObjectAsForwardedRef((_children$ref = children.ref) !== null && _children$ref !== void 0 ? _children$ref : noop, inputRef);\n  const externalInput = requireChildrenToBeInput(children, inputRef);\n  const emitSyntheticChange = useSyntheticChange({\n    inputRef,\n    fallbackEventHandler: (_externalInput$props$ = externalInput.props.onChange) !== null && _externalInput$props$ !== void 0 ? _externalInput$props$ : noop\n  });\n\n  /** Stores the query that caused the current suggestion list to appear. */\n  const showEventRef = useRef(null);\n  const suggestionsVisible = suggestions !== null && suggestions.length > 0;\n\n  // The suggestions don't usually move while open, so it seems as though this could be\n  // optimized by only re-rendering when suggestionsVisible changes. However, the user\n  // could move the cursor to a different location using arrow keys and then type a\n  // trigger, which would move the suggestions without closing/reopening them.\n  const triggerCharCoords = inputRef.current && showEventRef.current && suggestionsVisible ? getAbsoluteCharacterCoordinates(inputRef.current, ((_getSelectionStart = getSelectionStart(inputRef.current)) !== null && _getSelectionStart !== void 0 ? _getSelectionStart : 0) - showEventRef.current.query.length) : {\n    top: 0,\n    left: 0,\n    height: 0\n  };\n\n  // User can blur while suggestions are visible with shift+tab\n  const onBlur = () => {\n    onHideSuggestions();\n  };\n\n  // Even though the overlay has an Escape listener, it only works when focus is inside\n  // the overlay; in this case the textarea is focused\n  const onKeyDown = event => {\n    if (suggestionsVisible && event.key === 'Escape') {\n      onHideSuggestions();\n      event.stopPropagation();\n    }\n  };\n  const onChange = event => {\n    const selectionStart = getSelectionStart(event.currentTarget);\n    if (selectionStart === null) {\n      onHideSuggestions();\n      return;\n    }\n    showEventRef.current = calculateSuggestionsQuery(triggers, event.currentTarget.value, selectionStart);\n    if (showEventRef.current) {\n      onShowSuggestions(showEventRef.current);\n    } else {\n      onHideSuggestions();\n    }\n  };\n  const onCommit = suggestion => {\n    var _getSelectionStart2, _trigger$keepTriggerC;\n    if (!inputRef.current || !showEventRef.current) return;\n    const {\n      query,\n      trigger\n    } = showEventRef.current;\n    onSelectSuggestion === null || onSelectSuggestion === void 0 ? void 0 : onSelectSuggestion({\n      suggestion,\n      trigger,\n      query\n    });\n    const currentCaretPosition = (_getSelectionStart2 = getSelectionStart(inputRef.current)) !== null && _getSelectionStart2 !== void 0 ? _getSelectionStart2 : 0;\n    const deleteLength = query.length + trigger.triggerChar.length;\n    const startIndex = currentCaretPosition - deleteLength;\n    const keepTriggerChar = (_trigger$keepTriggerC = trigger.keepTriggerCharOnCommit) !== null && _trigger$keepTriggerC !== void 0 ? _trigger$keepTriggerC : true;\n    const maybeTriggerChar = keepTriggerChar ? trigger.triggerChar : '';\n    const replacement = `${maybeTriggerChar}${suggestion} `;\n    emitSyntheticChange(replacement, [startIndex, startIndex + deleteLength]);\n    onHideSuggestions();\n  };\n  const input = /*#__PURE__*/cloneElement(externalInput, {\n    ...inputProps,\n    onBlur: augmentHandler(externalInput.props.onBlur, onBlur),\n    onKeyDown: augmentHandler(externalInput.props.onKeyDown, onKeyDown),\n    onChange: augmentHandler(externalInput.props.onChange, onChange),\n    ref: inputRef\n  });\n\n  /**\n   * Even though we apply all the aria attributes, screen readers don't fully support this\n   * dynamic use case and so they don't have a native way to indicate to the user when\n   * there are suggestions available. So we use some hidden text with aria-live to politely\n   * indicate what's available and how to use it.\n   *\n   * This text should be consistent and the important info should be first, because users\n   * will hear it as they type - if they have heard the message before they should be able\n   * to recognize it and quickly apply the first suggestion without listening to the rest\n   * of the message.\n   *\n   * When screen reader users navigate using arrow keys, the `aria-activedescendant` will\n   * change and will be read out so we don't need to handle that interaction here.\n   */\n  const suggestionsDescription = !suggestionsVisible ? '' : suggestions === 'loading' ? 'Loading autocomplete suggestionsâ€¦' :\n  // It's important to include both Enter and Tab because we are telling the user that we are hijacking these keys:\n  `${suggestions.length} autocomplete ${suggestions.length === 1 ? 'suggestion' : 'suggestions'} available; \"${getSuggestionValue(suggestions[0])}\" is highlighted. Press ${tabInsertsSuggestions ? 'Enter or Tab' : 'Enter'} to insert.`;\n  return (\n    /*#__PURE__*/\n    // Try to get as close as possible to making the container 'invisible' by making it shrink tight to child input\n    React.createElement(Box, {\n      sx: {\n        display: 'inline-block',\n        '& > *': {\n          width: '100%'\n        },\n        ...sx,\n        position: 'relative'\n      }\n    }, input, /*#__PURE__*/React.createElement(AutocompleteSuggestions, {\n      suggestions: suggestions,\n      inputRef: inputRef,\n      onCommit: onCommit,\n      onClose: onHideSuggestions,\n      triggerCharCoords: triggerCharCoords,\n      visible: suggestionsVisible,\n      tabInsertsSuggestions: tabInsertsSuggestions,\n      defaultPlacement: suggestionsPlacement\n    }), /*#__PURE__*/React.createElement(Portal, null, /*#__PURE__*/React.createElement(\"span\", {\n      \"aria-live\": \"assertive\",\n      \"aria-atomic\": true,\n      style: {\n        clipPath: 'circle(0)',\n        position: 'absolute'\n      }\n    }, suggestionsDescription)))\n  );\n};\nInlineAutocomplete.displayName = \"InlineAutocomplete\";\n\nexport { InlineAutocomplete as default };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}