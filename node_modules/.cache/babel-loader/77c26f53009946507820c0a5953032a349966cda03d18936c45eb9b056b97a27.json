{"ast":null,"code":"import React, { forwardRef, useRef, useState, useEffect, useCallback } from 'react';\nimport Box from '../Box/Box.js';\nimport sx from '../sx.js';\nimport { UnderlineNavContext } from './UnderlineNavContext.js';\nimport { useResizeObserver } from '../hooks/useResizeObserver.js';\nimport { useTheme } from '../ThemeProvider.js';\nimport VisuallyHidden from '../_VisuallyHidden.js';\nimport { getNavStyles, ulStyles, getDividerStyle, moreBtnStyles, menuStyles, GAP, menuItemStyles } from './styles.js';\nimport styled from 'styled-components';\nimport '../Button/types.js';\nimport { defaultSxProp } from '../utils/defaultSxProp.js';\nimport CounterLabel from '../CounterLabel/CounterLabel.js';\nimport { ButtonComponent } from '../Button/Button.js';\nimport { TriangleDownIcon } from '@primer/octicons-react';\nimport { useOnEscapePress } from '../hooks/useOnEscapePress.js';\nimport { useOnOutsideClick } from '../hooks/useOnOutsideClick.js';\nimport { useId } from '../hooks/useId.js';\nimport { ActionList } from '../ActionList/index.js';\nimport { LoadingCounter } from './LoadingCounter.js';\nimport { invariant } from '../utils/invariant.js';\nimport merge from 'deepmerge';\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n// When page is loaded, we don't have ref for the more button as it is not on the DOM yet.\n// However, we need to calculate number of possible items when the more button present as well. So using the width of the more button as a constant.\nconst MORE_BTN_WIDTH = 86;\n// The height is needed to make sure we don't have a layout shift when the more button is the only item in the nav.\nconst MORE_BTN_HEIGHT = 45;\n\n// Needed this because passing a ref using HTMLULListElement to `Box` causes a type error\nconst NavigationList = styled.ul.withConfig({\n  displayName: \"UnderlineNav__NavigationList\",\n  componentId: \"sc-1jfr31k-0\"\n})([\"\", \";\"], sx);\nconst MoreMenuListItem = styled.li.withConfig({\n  displayName: \"UnderlineNav__MoreMenuListItem\",\n  componentId: \"sc-1jfr31k-1\"\n})([\"display:flex;align-items:center;height:\", \"px;\"], MORE_BTN_HEIGHT);\nconst overflowEffect = (navWidth, moreMenuWidth, childArray, childWidthArray, noIconChildWidthArray, updateListAndMenu) => {\n  let iconsVisible = true;\n  if (childWidthArray.length === 0) {\n    updateListAndMenu({\n      items: childArray,\n      menuItems: []\n    }, iconsVisible);\n  }\n  const numberOfItemsPossible = calculatePossibleItems(childWidthArray, navWidth);\n  const numberOfItemsWithoutIconPossible = calculatePossibleItems(noIconChildWidthArray, navWidth);\n  // We need to take more menu width into account when calculating the number of items possible\n  const numberOfItemsPossibleWithMoreMenu = calculatePossibleItems(noIconChildWidthArray, navWidth, moreMenuWidth || MORE_BTN_WIDTH);\n  const items = [];\n  const menuItems = [];\n\n  // First, we check if we can fit all the items with their icons\n  if (childArray.length <= numberOfItemsPossible) {\n    items.push(...childArray);\n  } else if (childArray.length <= numberOfItemsWithoutIconPossible) {\n    // if we can't fit all the items with their icons, we check if we can fit all the items without their icons\n    iconsVisible = false;\n    items.push(...childArray);\n  } else {\n    // if we can't fit all the items without their icons, we keep the icons hidden and show the ones that doesn't fit into the list in the overflow menu\n    iconsVisible = false;\n\n    /* Below is an accessibility requirement. Never show only one item in the overflow menu.\n     * If there is only one item left to display in the overflow menu according to the calculation,\n     * we need to pull another item from the list into the overflow menu.\n     */\n    const numberOfItemsInMenu = childArray.length - numberOfItemsPossibleWithMoreMenu;\n    const numberOfListItems = numberOfItemsInMenu === 1 ? numberOfItemsPossibleWithMoreMenu - 1 : numberOfItemsPossibleWithMoreMenu;\n    for (const [index, child] of childArray.entries()) {\n      if (index < numberOfListItems) {\n        items.push(child);\n      } else {\n        const ariaCurrent = child.props['aria-current'];\n        const isCurrent = Boolean(ariaCurrent) && ariaCurrent !== 'false';\n        // We need to make sure to keep the selected item always visible.\n        // To do that, we swap the selected item with the last item in the list to make it visible. (When there is at least 1 item in the list to swap.)\n        if (isCurrent && numberOfListItems > 0) {\n          // If selected item couldn't make in to the list, we swap it with the last item in the list.\n          const indexToReplaceAt = numberOfListItems - 1; // because we are replacing the last item in the list\n          // splice method modifies the array by removing 1 item here at the given index and replace it with the \"child\" element then returns the removed item.\n          const propsectiveAction = items.splice(indexToReplaceAt, 1, child)[0];\n          menuItems.push(propsectiveAction);\n        } else {\n          menuItems.push(child);\n        }\n      }\n    }\n  }\n  updateListAndMenu({\n    items,\n    menuItems\n  }, iconsVisible);\n};\nconst getValidChildren = children => {\n  return React.Children.toArray(children).filter(child => /*#__PURE__*/React.isValidElement(child));\n};\nconst calculatePossibleItems = (childWidthArray, navWidth, moreMenuWidth = 0) => {\n  const widthToFit = navWidth - moreMenuWidth;\n  let breakpoint = childWidthArray.length; // assume all items will fit\n  let sumsOfChildWidth = 0;\n  for (const [index, childWidth] of childWidthArray.entries()) {\n    sumsOfChildWidth = sumsOfChildWidth + childWidth.width + GAP;\n    if (sumsOfChildWidth > widthToFit) {\n      breakpoint = index;\n      break;\n    } else {\n      continue;\n    }\n  }\n  return breakpoint;\n};\nconst UnderlineNav = /*#__PURE__*/forwardRef(({\n  as = 'nav',\n  'aria-label': ariaLabel,\n  sx: sxProp = defaultSxProp,\n  loadingCounters = false,\n  children\n}, forwardedRef) => {\n  const backupRef = useRef(null);\n  const navRef = forwardedRef !== null && forwardedRef !== void 0 ? forwardedRef : backupRef;\n  const listRef = useRef(null);\n  const moreMenuRef = useRef(null);\n  const moreMenuBtnRef = useRef(null);\n  const containerRef = React.useRef(null);\n  const disclosureWidgetId = useId();\n  const {\n    theme\n  } = useTheme();\n  const [isWidgetOpen, setIsWidgetOpen] = useState(false);\n  const [iconsVisible, setIconsVisible] = useState(true);\n  const [childWidthArray, setChildWidthArray] = useState([]);\n  const [noIconChildWidthArray, setNoIconChildWidthArray] = useState([]);\n  const validChildren = getValidChildren(children);\n\n  // Responsive props object manages which items are in the list and which items are in the menu.\n  const [responsiveProps, setResponsiveProps] = useState({\n    items: validChildren,\n    menuItems: []\n  });\n\n  // Make sure to have the fresh props data for list items when children are changed (keeping aria-current up-to-date)\n  const listItems = responsiveProps.items.map(item => {\n    var _validChildren$find;\n    return (_validChildren$find = validChildren.find(child => child.key === item.key)) !== null && _validChildren$find !== void 0 ? _validChildren$find : item;\n  });\n\n  // Make sure to have the fresh props data for menu items when children are changed (keeping aria-current up-to-date)\n  const menuItems = responsiveProps.menuItems.map(menuItem => {\n    var _validChildren$find2;\n    return (_validChildren$find2 = validChildren.find(child => child.key === menuItem.key)) !== null && _validChildren$find2 !== void 0 ? _validChildren$find2 : menuItem;\n  });\n  // This is the case where the viewport is too narrow to show any list item with the more menu. In this case, we only show the dropdown\n  const onlyMenuVisible = responsiveProps.items.length === 0;\n  if (process.env.NODE_ENV !== \"production\") {\n    // Practically, this is not a conditional hook, it is just making sure this hook runs only on DEV not PROD.\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useEffect(() => {\n      // Address illegal state where there are multiple items that have `aria-current='page'` attribute\n      const activeElements = validChildren.filter(child => {\n        return child.props['aria-current'] !== undefined;\n      });\n      !(activeElements.length <= 1) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Only one current element is allowed') : invariant(false) : void 0;\n      !ariaLabel ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Use the `aria-label` prop to provide an accessible label for assistive technology') : invariant(false) : void 0;\n    });\n  }\n  function getItemsWidth(itemText) {\n    var _noIconChildWidthArra, _noIconChildWidthArra2;\n    return (_noIconChildWidthArra = (_noIconChildWidthArra2 = noIconChildWidthArray.find(item => item.text === itemText)) === null || _noIconChildWidthArra2 === void 0 ? void 0 : _noIconChildWidthArra2.width) !== null && _noIconChildWidthArra !== void 0 ? _noIconChildWidthArra : 0;\n  }\n  const swapMenuItemWithListItem = (prospectiveListItem, indexOfProspectiveListItem, event, callback) => {\n    var _listRef$current$getB, _listRef$current;\n    // get the selected menu item's width\n    const widthToFitIntoList = getItemsWidth(prospectiveListItem.props.children);\n    // Check if there is any empty space on the right side of the list\n    const availableSpace = navRef.current.getBoundingClientRect().width - ((_listRef$current$getB = (_listRef$current = listRef.current) === null || _listRef$current === void 0 ? void 0 : _listRef$current.getBoundingClientRect().width) !== null && _listRef$current$getB !== void 0 ? _listRef$current$getB : 0);\n\n    // Calculate how many items need to be pulled in to the menu to make room for the selected menu item\n    // I.e. if we need to pull 2 items in (index 0 and index 1), breakpoint (index) will return 1.\n    const index = getBreakpointForItemSwapping(widthToFitIntoList, availableSpace);\n    const indexToSliceAt = responsiveProps.items.length - 1 - index;\n    // Form the new list of items\n    const itemsLeftInList = [...responsiveProps.items].slice(0, indexToSliceAt);\n    const updatedItemList = [...itemsLeftInList, prospectiveListItem];\n    // Form the new menu items\n    const itemsToAddToMenu = [...responsiveProps.items].slice(indexToSliceAt);\n    const updatedMenuItems = [...menuItems];\n    // Add itemsToAddToMenu array's items to the menu at the index of the prospectiveListItem and remove 1 count of items (prospectiveListItem)\n    updatedMenuItems.splice(indexOfProspectiveListItem, 1, ...itemsToAddToMenu);\n    callback({\n      items: updatedItemList,\n      menuItems: updatedMenuItems\n    }, false);\n  };\n  // How many items do we need to pull in to the menu to make room for the selected menu item.\n  function getBreakpointForItemSwapping(widthToFitIntoList, availableSpace) {\n    let widthToSwap = 0;\n    let breakpoint = 0;\n    for (const [index, item] of [...responsiveProps.items].reverse().entries()) {\n      widthToSwap += getItemsWidth(item.props.children);\n      if (widthToFitIntoList < widthToSwap + availableSpace) {\n        breakpoint = index;\n        break;\n      }\n    }\n    return breakpoint;\n  }\n  const updateListAndMenu = useCallback((props, displayIcons) => {\n    setResponsiveProps(props);\n    setIconsVisible(displayIcons);\n  }, []);\n  const setChildrenWidth = useCallback(size => {\n    setChildWidthArray(arr => {\n      const newArr = [...arr, size];\n      return newArr;\n    });\n  }, []);\n  const setNoIconChildrenWidth = useCallback(size => {\n    setNoIconChildWidthArray(arr => {\n      const newArr = [...arr, size];\n      return newArr;\n    });\n  }, []);\n  const closeOverlay = React.useCallback(() => {\n    setIsWidgetOpen(false);\n  }, [setIsWidgetOpen]);\n  const focusOnMoreMenuBtn = React.useCallback(() => {\n    var _moreMenuBtnRef$curre;\n    (_moreMenuBtnRef$curre = moreMenuBtnRef.current) === null || _moreMenuBtnRef$curre === void 0 ? void 0 : _moreMenuBtnRef$curre.focus();\n  }, []);\n  const onAnchorClick = useCallback(event => {\n    if (event.defaultPrevented || event.button !== 0) {\n      return;\n    }\n    setIsWidgetOpen(isWidgetOpen => !isWidgetOpen);\n  }, []);\n  useOnEscapePress(event => {\n    if (isWidgetOpen) {\n      event.preventDefault();\n      closeOverlay();\n      focusOnMoreMenuBtn();\n    }\n  }, [isWidgetOpen]);\n  useOnOutsideClick({\n    onClickOutside: closeOverlay,\n    containerRef,\n    ignoreClickRefs: [moreMenuBtnRef]\n  });\n  useResizeObserver(resizeObserverEntries => {\n    var _moreMenuRef$current$, _moreMenuRef$current;\n    const navWidth = resizeObserverEntries[0].contentRect.width;\n    const moreMenuWidth = (_moreMenuRef$current$ = (_moreMenuRef$current = moreMenuRef.current) === null || _moreMenuRef$current === void 0 ? void 0 : _moreMenuRef$current.getBoundingClientRect().width) !== null && _moreMenuRef$current$ !== void 0 ? _moreMenuRef$current$ : 0;\n    navWidth !== 0 && overflowEffect(navWidth, moreMenuWidth, validChildren, childWidthArray, noIconChildWidthArray, updateListAndMenu);\n  }, navRef);\n  return /*#__PURE__*/React.createElement(UnderlineNavContext.Provider, {\n    value: {\n      theme,\n      setChildrenWidth,\n      setNoIconChildrenWidth,\n      loadingCounters,\n      iconsVisible\n    }\n  }, ariaLabel && /*#__PURE__*/React.createElement(VisuallyHidden, {\n    as: \"h2\"\n  }, `${ariaLabel} navigation`), /*#__PURE__*/React.createElement(Box, {\n    as: as,\n    sx: merge(getNavStyles(theme), sxProp),\n    \"aria-label\": ariaLabel,\n    ref: navRef\n  }, /*#__PURE__*/React.createElement(NavigationList, {\n    sx: ulStyles,\n    ref: listRef,\n    role: \"list\"\n  }, listItems, menuItems.length > 0 && /*#__PURE__*/React.createElement(MoreMenuListItem, {\n    ref: moreMenuRef\n  }, !onlyMenuVisible && /*#__PURE__*/React.createElement(Box, {\n    sx: getDividerStyle(theme)\n  }), /*#__PURE__*/React.createElement(ButtonComponent, {\n    ref: moreMenuBtnRef,\n    sx: moreBtnStyles,\n    \"aria-controls\": disclosureWidgetId,\n    \"aria-expanded\": isWidgetOpen,\n    onClick: onAnchorClick,\n    trailingAction: TriangleDownIcon\n  }, /*#__PURE__*/React.createElement(Box, {\n    as: \"span\"\n  }, onlyMenuVisible ? /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(VisuallyHidden, {\n    as: \"span\"\n  }, `${ariaLabel}`, \"\\xA0\"), \"Menu\") : /*#__PURE__*/React.createElement(React.Fragment, null, \"More\", /*#__PURE__*/React.createElement(VisuallyHidden, {\n    as: \"span\"\n  }, \"\\xA0\", `${ariaLabel} items`)))), /*#__PURE__*/React.createElement(ActionList, {\n    selectionVariant: \"single\",\n    ref: containerRef,\n    id: disclosureWidgetId,\n    sx: menuStyles,\n    style: {\n      display: isWidgetOpen ? 'block' : 'none'\n    }\n  }, menuItems.map((menuItem, index) => {\n    const {\n      children: menuItemChildren,\n      counter,\n      'aria-current': ariaCurrent,\n      onSelect,\n      ...menuItemProps\n    } = menuItem.props;\n\n    // This logic is used to pop the selected item out of the menu and into the list when the navigation is control externally\n    if (Boolean(ariaCurrent) && ariaCurrent !== 'false') {\n      const event = new MouseEvent('click');\n      !onlyMenuVisible && swapMenuItemWithListItem(menuItem, index,\n      // @ts-ignore - not a big deal because it is internally creating an event but ask help\n      event, updateListAndMenu);\n    }\n    return /*#__PURE__*/React.createElement(ActionList.LinkItem, _extends({\n      key: menuItemChildren,\n      sx: menuItemStyles,\n      onClick: event => {\n        // When there are no items in the list, do not run the swap function as we want to keep everything in the menu.\n        !onlyMenuVisible && swapMenuItemWithListItem(menuItem, index, event, updateListAndMenu);\n        closeOverlay();\n        focusOnMoreMenuBtn();\n        // fire onSelect event that comes from the UnderlineNav.Item (if it is defined)\n        typeof onSelect === 'function' && onSelect(event);\n      }\n    }, menuItemProps), /*#__PURE__*/React.createElement(Box, {\n      as: \"span\",\n      sx: {\n        display: 'flex',\n        alignItems: 'center',\n        justifyContent: 'space-between'\n      }\n    }, menuItemChildren, loadingCounters ? /*#__PURE__*/React.createElement(LoadingCounter, null) : counter !== undefined && /*#__PURE__*/React.createElement(Box, {\n      as: \"span\",\n      \"data-component\": \"counter\"\n    }, /*#__PURE__*/React.createElement(CounterLabel, null, counter))));\n  }))))));\n});\nUnderlineNav.displayName = 'UnderlineNav';\nexport { UnderlineNav };","map":{"version":3,"names":["React","forwardRef","useRef","useState","useEffect","useCallback","Box","sx","UnderlineNavContext","useResizeObserver","useTheme","VisuallyHidden","getNavStyles","ulStyles","getDividerStyle","moreBtnStyles","menuStyles","GAP","menuItemStyles","styled","defaultSxProp","CounterLabel","ButtonComponent","TriangleDownIcon","useOnEscapePress","useOnOutsideClick","useId","ActionList","LoadingCounter","invariant","merge","_extends","Object","assign","bind","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","MORE_BTN_WIDTH","MORE_BTN_HEIGHT","NavigationList","ul","withConfig","displayName","componentId","MoreMenuListItem","li","overflowEffect","navWidth","moreMenuWidth","childArray","childWidthArray","noIconChildWidthArray","updateListAndMenu","iconsVisible","items","menuItems","numberOfItemsPossible","calculatePossibleItems","numberOfItemsWithoutIconPossible","numberOfItemsPossibleWithMoreMenu","push","numberOfItemsInMenu","numberOfListItems","index","child","entries","ariaCurrent","props","isCurrent","Boolean","indexToReplaceAt","propsectiveAction","splice","getValidChildren","children","Children","toArray","filter","isValidElement","widthToFit","breakpoint","sumsOfChildWidth","childWidth","width","UnderlineNav","as","ariaLabel","sxProp","loadingCounters","forwardedRef","backupRef","navRef","listRef","moreMenuRef","moreMenuBtnRef","containerRef","disclosureWidgetId","theme","isWidgetOpen","setIsWidgetOpen","setIconsVisible","setChildWidthArray","setNoIconChildWidthArray","validChildren","responsiveProps","setResponsiveProps","listItems","map","item","_validChildren$find","find","menuItem","_validChildren$find2","onlyMenuVisible","process","env","NODE_ENV","activeElements","undefined","getItemsWidth","itemText","_noIconChildWidthArra","_noIconChildWidthArra2","text","swapMenuItemWithListItem","prospectiveListItem","indexOfProspectiveListItem","event","callback","_listRef$current$getB","_listRef$current","widthToFitIntoList","availableSpace","current","getBoundingClientRect","getBreakpointForItemSwapping","indexToSliceAt","itemsLeftInList","slice","updatedItemList","itemsToAddToMenu","updatedMenuItems","widthToSwap","reverse","displayIcons","setChildrenWidth","size","arr","newArr","setNoIconChildrenWidth","closeOverlay","focusOnMoreMenuBtn","_moreMenuBtnRef$curre","focus","onAnchorClick","defaultPrevented","button","preventDefault","onClickOutside","ignoreClickRefs","resizeObserverEntries","_moreMenuRef$current$","_moreMenuRef$current","contentRect","createElement","Provider","value","ref","role","onClick","trailingAction","Fragment","selectionVariant","id","style","display","menuItemChildren","counter","onSelect","menuItemProps","MouseEvent","LinkItem","alignItems","justifyContent"],"sources":["/Users/steve/Documents/repos/github/billing-usage/node_modules/@primer/react/lib-esm/UnderlineNav/UnderlineNav.js"],"sourcesContent":["import React, { forwardRef, useRef, useState, useEffect, useCallback } from 'react';\nimport Box from '../Box/Box.js';\nimport sx from '../sx.js';\nimport { UnderlineNavContext } from './UnderlineNavContext.js';\nimport { useResizeObserver } from '../hooks/useResizeObserver.js';\nimport { useTheme } from '../ThemeProvider.js';\nimport VisuallyHidden from '../_VisuallyHidden.js';\nimport { getNavStyles, ulStyles, getDividerStyle, moreBtnStyles, menuStyles, GAP, menuItemStyles } from './styles.js';\nimport styled from 'styled-components';\nimport '../Button/types.js';\nimport { defaultSxProp } from '../utils/defaultSxProp.js';\nimport CounterLabel from '../CounterLabel/CounterLabel.js';\nimport { ButtonComponent } from '../Button/Button.js';\nimport { TriangleDownIcon } from '@primer/octicons-react';\nimport { useOnEscapePress } from '../hooks/useOnEscapePress.js';\nimport { useOnOutsideClick } from '../hooks/useOnOutsideClick.js';\nimport { useId } from '../hooks/useId.js';\nimport { ActionList } from '../ActionList/index.js';\nimport { LoadingCounter } from './LoadingCounter.js';\nimport { invariant } from '../utils/invariant.js';\nimport merge from 'deepmerge';\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n// When page is loaded, we don't have ref for the more button as it is not on the DOM yet.\n// However, we need to calculate number of possible items when the more button present as well. So using the width of the more button as a constant.\nconst MORE_BTN_WIDTH = 86;\n// The height is needed to make sure we don't have a layout shift when the more button is the only item in the nav.\nconst MORE_BTN_HEIGHT = 45;\n\n// Needed this because passing a ref using HTMLULListElement to `Box` causes a type error\nconst NavigationList = styled.ul.withConfig({\n  displayName: \"UnderlineNav__NavigationList\",\n  componentId: \"sc-1jfr31k-0\"\n})([\"\", \";\"], sx);\nconst MoreMenuListItem = styled.li.withConfig({\n  displayName: \"UnderlineNav__MoreMenuListItem\",\n  componentId: \"sc-1jfr31k-1\"\n})([\"display:flex;align-items:center;height:\", \"px;\"], MORE_BTN_HEIGHT);\nconst overflowEffect = (navWidth, moreMenuWidth, childArray, childWidthArray, noIconChildWidthArray, updateListAndMenu) => {\n  let iconsVisible = true;\n  if (childWidthArray.length === 0) {\n    updateListAndMenu({\n      items: childArray,\n      menuItems: []\n    }, iconsVisible);\n  }\n  const numberOfItemsPossible = calculatePossibleItems(childWidthArray, navWidth);\n  const numberOfItemsWithoutIconPossible = calculatePossibleItems(noIconChildWidthArray, navWidth);\n  // We need to take more menu width into account when calculating the number of items possible\n  const numberOfItemsPossibleWithMoreMenu = calculatePossibleItems(noIconChildWidthArray, navWidth, moreMenuWidth || MORE_BTN_WIDTH);\n  const items = [];\n  const menuItems = [];\n\n  // First, we check if we can fit all the items with their icons\n  if (childArray.length <= numberOfItemsPossible) {\n    items.push(...childArray);\n  } else if (childArray.length <= numberOfItemsWithoutIconPossible) {\n    // if we can't fit all the items with their icons, we check if we can fit all the items without their icons\n    iconsVisible = false;\n    items.push(...childArray);\n  } else {\n    // if we can't fit all the items without their icons, we keep the icons hidden and show the ones that doesn't fit into the list in the overflow menu\n    iconsVisible = false;\n\n    /* Below is an accessibility requirement. Never show only one item in the overflow menu.\n     * If there is only one item left to display in the overflow menu according to the calculation,\n     * we need to pull another item from the list into the overflow menu.\n     */\n    const numberOfItemsInMenu = childArray.length - numberOfItemsPossibleWithMoreMenu;\n    const numberOfListItems = numberOfItemsInMenu === 1 ? numberOfItemsPossibleWithMoreMenu - 1 : numberOfItemsPossibleWithMoreMenu;\n    for (const [index, child] of childArray.entries()) {\n      if (index < numberOfListItems) {\n        items.push(child);\n      } else {\n        const ariaCurrent = child.props['aria-current'];\n        const isCurrent = Boolean(ariaCurrent) && ariaCurrent !== 'false';\n        // We need to make sure to keep the selected item always visible.\n        // To do that, we swap the selected item with the last item in the list to make it visible. (When there is at least 1 item in the list to swap.)\n        if (isCurrent && numberOfListItems > 0) {\n          // If selected item couldn't make in to the list, we swap it with the last item in the list.\n          const indexToReplaceAt = numberOfListItems - 1; // because we are replacing the last item in the list\n          // splice method modifies the array by removing 1 item here at the given index and replace it with the \"child\" element then returns the removed item.\n          const propsectiveAction = items.splice(indexToReplaceAt, 1, child)[0];\n          menuItems.push(propsectiveAction);\n        } else {\n          menuItems.push(child);\n        }\n      }\n    }\n  }\n  updateListAndMenu({\n    items,\n    menuItems\n  }, iconsVisible);\n};\nconst getValidChildren = children => {\n  return React.Children.toArray(children).filter(child => /*#__PURE__*/React.isValidElement(child));\n};\nconst calculatePossibleItems = (childWidthArray, navWidth, moreMenuWidth = 0) => {\n  const widthToFit = navWidth - moreMenuWidth;\n  let breakpoint = childWidthArray.length; // assume all items will fit\n  let sumsOfChildWidth = 0;\n  for (const [index, childWidth] of childWidthArray.entries()) {\n    sumsOfChildWidth = sumsOfChildWidth + childWidth.width + GAP;\n    if (sumsOfChildWidth > widthToFit) {\n      breakpoint = index;\n      break;\n    } else {\n      continue;\n    }\n  }\n  return breakpoint;\n};\nconst UnderlineNav = /*#__PURE__*/forwardRef(({\n  as = 'nav',\n  'aria-label': ariaLabel,\n  sx: sxProp = defaultSxProp,\n  loadingCounters = false,\n  children\n}, forwardedRef) => {\n  const backupRef = useRef(null);\n  const navRef = forwardedRef !== null && forwardedRef !== void 0 ? forwardedRef : backupRef;\n  const listRef = useRef(null);\n  const moreMenuRef = useRef(null);\n  const moreMenuBtnRef = useRef(null);\n  const containerRef = React.useRef(null);\n  const disclosureWidgetId = useId();\n  const {\n    theme\n  } = useTheme();\n  const [isWidgetOpen, setIsWidgetOpen] = useState(false);\n  const [iconsVisible, setIconsVisible] = useState(true);\n  const [childWidthArray, setChildWidthArray] = useState([]);\n  const [noIconChildWidthArray, setNoIconChildWidthArray] = useState([]);\n  const validChildren = getValidChildren(children);\n\n  // Responsive props object manages which items are in the list and which items are in the menu.\n  const [responsiveProps, setResponsiveProps] = useState({\n    items: validChildren,\n    menuItems: []\n  });\n\n  // Make sure to have the fresh props data for list items when children are changed (keeping aria-current up-to-date)\n  const listItems = responsiveProps.items.map(item => {\n    var _validChildren$find;\n    return (_validChildren$find = validChildren.find(child => child.key === item.key)) !== null && _validChildren$find !== void 0 ? _validChildren$find : item;\n  });\n\n  // Make sure to have the fresh props data for menu items when children are changed (keeping aria-current up-to-date)\n  const menuItems = responsiveProps.menuItems.map(menuItem => {\n    var _validChildren$find2;\n    return (_validChildren$find2 = validChildren.find(child => child.key === menuItem.key)) !== null && _validChildren$find2 !== void 0 ? _validChildren$find2 : menuItem;\n  });\n  // This is the case where the viewport is too narrow to show any list item with the more menu. In this case, we only show the dropdown\n  const onlyMenuVisible = responsiveProps.items.length === 0;\n  if (process.env.NODE_ENV !== \"production\") {\n    // Practically, this is not a conditional hook, it is just making sure this hook runs only on DEV not PROD.\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useEffect(() => {\n      // Address illegal state where there are multiple items that have `aria-current='page'` attribute\n      const activeElements = validChildren.filter(child => {\n        return child.props['aria-current'] !== undefined;\n      });\n      !(activeElements.length <= 1) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Only one current element is allowed') : invariant(false) : void 0;\n      !ariaLabel ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Use the `aria-label` prop to provide an accessible label for assistive technology') : invariant(false) : void 0;\n    });\n  }\n  function getItemsWidth(itemText) {\n    var _noIconChildWidthArra, _noIconChildWidthArra2;\n    return (_noIconChildWidthArra = (_noIconChildWidthArra2 = noIconChildWidthArray.find(item => item.text === itemText)) === null || _noIconChildWidthArra2 === void 0 ? void 0 : _noIconChildWidthArra2.width) !== null && _noIconChildWidthArra !== void 0 ? _noIconChildWidthArra : 0;\n  }\n  const swapMenuItemWithListItem = (prospectiveListItem, indexOfProspectiveListItem, event, callback) => {\n    var _listRef$current$getB, _listRef$current;\n    // get the selected menu item's width\n    const widthToFitIntoList = getItemsWidth(prospectiveListItem.props.children);\n    // Check if there is any empty space on the right side of the list\n    const availableSpace = navRef.current.getBoundingClientRect().width - ((_listRef$current$getB = (_listRef$current = listRef.current) === null || _listRef$current === void 0 ? void 0 : _listRef$current.getBoundingClientRect().width) !== null && _listRef$current$getB !== void 0 ? _listRef$current$getB : 0);\n\n    // Calculate how many items need to be pulled in to the menu to make room for the selected menu item\n    // I.e. if we need to pull 2 items in (index 0 and index 1), breakpoint (index) will return 1.\n    const index = getBreakpointForItemSwapping(widthToFitIntoList, availableSpace);\n    const indexToSliceAt = responsiveProps.items.length - 1 - index;\n    // Form the new list of items\n    const itemsLeftInList = [...responsiveProps.items].slice(0, indexToSliceAt);\n    const updatedItemList = [...itemsLeftInList, prospectiveListItem];\n    // Form the new menu items\n    const itemsToAddToMenu = [...responsiveProps.items].slice(indexToSliceAt);\n    const updatedMenuItems = [...menuItems];\n    // Add itemsToAddToMenu array's items to the menu at the index of the prospectiveListItem and remove 1 count of items (prospectiveListItem)\n    updatedMenuItems.splice(indexOfProspectiveListItem, 1, ...itemsToAddToMenu);\n    callback({\n      items: updatedItemList,\n      menuItems: updatedMenuItems\n    }, false);\n  };\n  // How many items do we need to pull in to the menu to make room for the selected menu item.\n  function getBreakpointForItemSwapping(widthToFitIntoList, availableSpace) {\n    let widthToSwap = 0;\n    let breakpoint = 0;\n    for (const [index, item] of [...responsiveProps.items].reverse().entries()) {\n      widthToSwap += getItemsWidth(item.props.children);\n      if (widthToFitIntoList < widthToSwap + availableSpace) {\n        breakpoint = index;\n        break;\n      }\n    }\n    return breakpoint;\n  }\n  const updateListAndMenu = useCallback((props, displayIcons) => {\n    setResponsiveProps(props);\n    setIconsVisible(displayIcons);\n  }, []);\n  const setChildrenWidth = useCallback(size => {\n    setChildWidthArray(arr => {\n      const newArr = [...arr, size];\n      return newArr;\n    });\n  }, []);\n  const setNoIconChildrenWidth = useCallback(size => {\n    setNoIconChildWidthArray(arr => {\n      const newArr = [...arr, size];\n      return newArr;\n    });\n  }, []);\n  const closeOverlay = React.useCallback(() => {\n    setIsWidgetOpen(false);\n  }, [setIsWidgetOpen]);\n  const focusOnMoreMenuBtn = React.useCallback(() => {\n    var _moreMenuBtnRef$curre;\n    (_moreMenuBtnRef$curre = moreMenuBtnRef.current) === null || _moreMenuBtnRef$curre === void 0 ? void 0 : _moreMenuBtnRef$curre.focus();\n  }, []);\n  const onAnchorClick = useCallback(event => {\n    if (event.defaultPrevented || event.button !== 0) {\n      return;\n    }\n    setIsWidgetOpen(isWidgetOpen => !isWidgetOpen);\n  }, []);\n  useOnEscapePress(event => {\n    if (isWidgetOpen) {\n      event.preventDefault();\n      closeOverlay();\n      focusOnMoreMenuBtn();\n    }\n  }, [isWidgetOpen]);\n  useOnOutsideClick({\n    onClickOutside: closeOverlay,\n    containerRef,\n    ignoreClickRefs: [moreMenuBtnRef]\n  });\n  useResizeObserver(resizeObserverEntries => {\n    var _moreMenuRef$current$, _moreMenuRef$current;\n    const navWidth = resizeObserverEntries[0].contentRect.width;\n    const moreMenuWidth = (_moreMenuRef$current$ = (_moreMenuRef$current = moreMenuRef.current) === null || _moreMenuRef$current === void 0 ? void 0 : _moreMenuRef$current.getBoundingClientRect().width) !== null && _moreMenuRef$current$ !== void 0 ? _moreMenuRef$current$ : 0;\n    navWidth !== 0 && overflowEffect(navWidth, moreMenuWidth, validChildren, childWidthArray, noIconChildWidthArray, updateListAndMenu);\n  }, navRef);\n  return /*#__PURE__*/React.createElement(UnderlineNavContext.Provider, {\n    value: {\n      theme,\n      setChildrenWidth,\n      setNoIconChildrenWidth,\n      loadingCounters,\n      iconsVisible\n    }\n  }, ariaLabel && /*#__PURE__*/React.createElement(VisuallyHidden, {\n    as: \"h2\"\n  }, `${ariaLabel} navigation`), /*#__PURE__*/React.createElement(Box, {\n    as: as,\n    sx: merge(getNavStyles(theme), sxProp),\n    \"aria-label\": ariaLabel,\n    ref: navRef\n  }, /*#__PURE__*/React.createElement(NavigationList, {\n    sx: ulStyles,\n    ref: listRef,\n    role: \"list\"\n  }, listItems, menuItems.length > 0 && /*#__PURE__*/React.createElement(MoreMenuListItem, {\n    ref: moreMenuRef\n  }, !onlyMenuVisible && /*#__PURE__*/React.createElement(Box, {\n    sx: getDividerStyle(theme)\n  }), /*#__PURE__*/React.createElement(ButtonComponent, {\n    ref: moreMenuBtnRef,\n    sx: moreBtnStyles,\n    \"aria-controls\": disclosureWidgetId,\n    \"aria-expanded\": isWidgetOpen,\n    onClick: onAnchorClick,\n    trailingAction: TriangleDownIcon\n  }, /*#__PURE__*/React.createElement(Box, {\n    as: \"span\"\n  }, onlyMenuVisible ? /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(VisuallyHidden, {\n    as: \"span\"\n  }, `${ariaLabel}`, \"\\xA0\"), \"Menu\") : /*#__PURE__*/React.createElement(React.Fragment, null, \"More\", /*#__PURE__*/React.createElement(VisuallyHidden, {\n    as: \"span\"\n  }, \"\\xA0\", `${ariaLabel} items`)))), /*#__PURE__*/React.createElement(ActionList, {\n    selectionVariant: \"single\",\n    ref: containerRef,\n    id: disclosureWidgetId,\n    sx: menuStyles,\n    style: {\n      display: isWidgetOpen ? 'block' : 'none'\n    }\n  }, menuItems.map((menuItem, index) => {\n    const {\n      children: menuItemChildren,\n      counter,\n      'aria-current': ariaCurrent,\n      onSelect,\n      ...menuItemProps\n    } = menuItem.props;\n\n    // This logic is used to pop the selected item out of the menu and into the list when the navigation is control externally\n    if (Boolean(ariaCurrent) && ariaCurrent !== 'false') {\n      const event = new MouseEvent('click');\n      !onlyMenuVisible && swapMenuItemWithListItem(menuItem, index,\n      // @ts-ignore - not a big deal because it is internally creating an event but ask help\n      event, updateListAndMenu);\n    }\n    return /*#__PURE__*/React.createElement(ActionList.LinkItem, _extends({\n      key: menuItemChildren,\n      sx: menuItemStyles,\n      onClick: event => {\n        // When there are no items in the list, do not run the swap function as we want to keep everything in the menu.\n        !onlyMenuVisible && swapMenuItemWithListItem(menuItem, index, event, updateListAndMenu);\n        closeOverlay();\n        focusOnMoreMenuBtn();\n        // fire onSelect event that comes from the UnderlineNav.Item (if it is defined)\n        typeof onSelect === 'function' && onSelect(event);\n      }\n    }, menuItemProps), /*#__PURE__*/React.createElement(Box, {\n      as: \"span\",\n      sx: {\n        display: 'flex',\n        alignItems: 'center',\n        justifyContent: 'space-between'\n      }\n    }, menuItemChildren, loadingCounters ? /*#__PURE__*/React.createElement(LoadingCounter, null) : counter !== undefined && /*#__PURE__*/React.createElement(Box, {\n      as: \"span\",\n      \"data-component\": \"counter\"\n    }, /*#__PURE__*/React.createElement(CounterLabel, null, counter))));\n  }))))));\n});\nUnderlineNav.displayName = 'UnderlineNav';\n\nexport { UnderlineNav };\n"],"mappings":"AAAA,OAAOA,KAAK,IAAIC,UAAU,EAAEC,MAAM,EAAEC,QAAQ,EAAEC,SAAS,EAAEC,WAAW,QAAQ,OAAO;AACnF,OAAOC,GAAG,MAAM,eAAe;AAC/B,OAAOC,EAAE,MAAM,UAAU;AACzB,SAASC,mBAAmB,QAAQ,0BAA0B;AAC9D,SAASC,iBAAiB,QAAQ,+BAA+B;AACjE,SAASC,QAAQ,QAAQ,qBAAqB;AAC9C,OAAOC,cAAc,MAAM,uBAAuB;AAClD,SAASC,YAAY,EAAEC,QAAQ,EAAEC,eAAe,EAAEC,aAAa,EAAEC,UAAU,EAAEC,GAAG,EAAEC,cAAc,QAAQ,aAAa;AACrH,OAAOC,MAAM,MAAM,mBAAmB;AACtC,OAAO,oBAAoB;AAC3B,SAASC,aAAa,QAAQ,2BAA2B;AACzD,OAAOC,YAAY,MAAM,iCAAiC;AAC1D,SAASC,eAAe,QAAQ,qBAAqB;AACrD,SAASC,gBAAgB,QAAQ,wBAAwB;AACzD,SAASC,gBAAgB,QAAQ,8BAA8B;AAC/D,SAASC,iBAAiB,QAAQ,+BAA+B;AACjE,SAASC,KAAK,QAAQ,mBAAmB;AACzC,SAASC,UAAU,QAAQ,wBAAwB;AACnD,SAASC,cAAc,QAAQ,qBAAqB;AACpD,SAASC,SAAS,QAAQ,uBAAuB;AACjD,OAAOC,KAAK,MAAM,WAAW;AAE7B,SAASC,QAAQA,CAAA,EAAG;EAAEA,QAAQ,GAAGC,MAAM,CAACC,MAAM,GAAGD,MAAM,CAACC,MAAM,CAACC,IAAI,CAAC,CAAC,GAAG,UAAUC,MAAM,EAAE;IAAE,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGC,SAAS,CAACC,MAAM,EAAEF,CAAC,EAAE,EAAE;MAAE,IAAIG,MAAM,GAAGF,SAAS,CAACD,CAAC,CAAC;MAAE,KAAK,IAAII,GAAG,IAAID,MAAM,EAAE;QAAE,IAAIP,MAAM,CAACS,SAAS,CAACC,cAAc,CAACC,IAAI,CAACJ,MAAM,EAAEC,GAAG,CAAC,EAAE;UAAEL,MAAM,CAACK,GAAG,CAAC,GAAGD,MAAM,CAACC,GAAG,CAAC;QAAE;MAAE;IAAE;IAAE,OAAOL,MAAM;EAAE,CAAC;EAAE,OAAOJ,QAAQ,CAACa,KAAK,CAAC,IAAI,EAAEP,SAAS,CAAC;AAAE;AAClV;AACA;AACA,MAAMQ,cAAc,GAAG,EAAE;AACzB;AACA,MAAMC,eAAe,GAAG,EAAE;;AAE1B;AACA,MAAMC,cAAc,GAAG5B,MAAM,CAAC6B,EAAE,CAACC,UAAU,CAAC;EAC1CC,WAAW,EAAE,8BAA8B;EAC3CC,WAAW,EAAE;AACf,CAAC,CAAC,CAAC,CAAC,EAAE,EAAE,GAAG,CAAC,EAAE5C,EAAE,CAAC;AACjB,MAAM6C,gBAAgB,GAAGjC,MAAM,CAACkC,EAAE,CAACJ,UAAU,CAAC;EAC5CC,WAAW,EAAE,gCAAgC;EAC7CC,WAAW,EAAE;AACf,CAAC,CAAC,CAAC,CAAC,yCAAyC,EAAE,KAAK,CAAC,EAAEL,eAAe,CAAC;AACvE,MAAMQ,cAAc,GAAGA,CAACC,QAAQ,EAAEC,aAAa,EAAEC,UAAU,EAAEC,eAAe,EAAEC,qBAAqB,EAAEC,iBAAiB,KAAK;EACzH,IAAIC,YAAY,GAAG,IAAI;EACvB,IAAIH,eAAe,CAACpB,MAAM,KAAK,CAAC,EAAE;IAChCsB,iBAAiB,CAAC;MAChBE,KAAK,EAAEL,UAAU;MACjBM,SAAS,EAAE;IACb,CAAC,EAAEF,YAAY,CAAC;EAClB;EACA,MAAMG,qBAAqB,GAAGC,sBAAsB,CAACP,eAAe,EAAEH,QAAQ,CAAC;EAC/E,MAAMW,gCAAgC,GAAGD,sBAAsB,CAACN,qBAAqB,EAAEJ,QAAQ,CAAC;EAChG;EACA,MAAMY,iCAAiC,GAAGF,sBAAsB,CAACN,qBAAqB,EAAEJ,QAAQ,EAAEC,aAAa,IAAIX,cAAc,CAAC;EAClI,MAAMiB,KAAK,GAAG,EAAE;EAChB,MAAMC,SAAS,GAAG,EAAE;;EAEpB;EACA,IAAIN,UAAU,CAACnB,MAAM,IAAI0B,qBAAqB,EAAE;IAC9CF,KAAK,CAACM,IAAI,CAAC,GAAGX,UAAU,CAAC;EAC3B,CAAC,MAAM,IAAIA,UAAU,CAACnB,MAAM,IAAI4B,gCAAgC,EAAE;IAChE;IACAL,YAAY,GAAG,KAAK;IACpBC,KAAK,CAACM,IAAI,CAAC,GAAGX,UAAU,CAAC;EAC3B,CAAC,MAAM;IACL;IACAI,YAAY,GAAG,KAAK;;IAEpB;AACJ;AACA;AACA;IACI,MAAMQ,mBAAmB,GAAGZ,UAAU,CAACnB,MAAM,GAAG6B,iCAAiC;IACjF,MAAMG,iBAAiB,GAAGD,mBAAmB,KAAK,CAAC,GAAGF,iCAAiC,GAAG,CAAC,GAAGA,iCAAiC;IAC/H,KAAK,MAAM,CAACI,KAAK,EAAEC,KAAK,CAAC,IAAIf,UAAU,CAACgB,OAAO,CAAC,CAAC,EAAE;MACjD,IAAIF,KAAK,GAAGD,iBAAiB,EAAE;QAC7BR,KAAK,CAACM,IAAI,CAACI,KAAK,CAAC;MACnB,CAAC,MAAM;QACL,MAAME,WAAW,GAAGF,KAAK,CAACG,KAAK,CAAC,cAAc,CAAC;QAC/C,MAAMC,SAAS,GAAGC,OAAO,CAACH,WAAW,CAAC,IAAIA,WAAW,KAAK,OAAO;QACjE;QACA;QACA,IAAIE,SAAS,IAAIN,iBAAiB,GAAG,CAAC,EAAE;UACtC;UACA,MAAMQ,gBAAgB,GAAGR,iBAAiB,GAAG,CAAC,CAAC,CAAC;UAChD;UACA,MAAMS,iBAAiB,GAAGjB,KAAK,CAACkB,MAAM,CAACF,gBAAgB,EAAE,CAAC,EAAEN,KAAK,CAAC,CAAC,CAAC,CAAC;UACrET,SAAS,CAACK,IAAI,CAACW,iBAAiB,CAAC;QACnC,CAAC,MAAM;UACLhB,SAAS,CAACK,IAAI,CAACI,KAAK,CAAC;QACvB;MACF;IACF;EACF;EACAZ,iBAAiB,CAAC;IAChBE,KAAK;IACLC;EACF,CAAC,EAAEF,YAAY,CAAC;AAClB,CAAC;AACD,MAAMoB,gBAAgB,GAAGC,QAAQ,IAAI;EACnC,OAAOlF,KAAK,CAACmF,QAAQ,CAACC,OAAO,CAACF,QAAQ,CAAC,CAACG,MAAM,CAACb,KAAK,IAAI,aAAaxE,KAAK,CAACsF,cAAc,CAACd,KAAK,CAAC,CAAC;AACnG,CAAC;AACD,MAAMP,sBAAsB,GAAGA,CAACP,eAAe,EAAEH,QAAQ,EAAEC,aAAa,GAAG,CAAC,KAAK;EAC/E,MAAM+B,UAAU,GAAGhC,QAAQ,GAAGC,aAAa;EAC3C,IAAIgC,UAAU,GAAG9B,eAAe,CAACpB,MAAM,CAAC,CAAC;EACzC,IAAImD,gBAAgB,GAAG,CAAC;EACxB,KAAK,MAAM,CAAClB,KAAK,EAAEmB,UAAU,CAAC,IAAIhC,eAAe,CAACe,OAAO,CAAC,CAAC,EAAE;IAC3DgB,gBAAgB,GAAGA,gBAAgB,GAAGC,UAAU,CAACC,KAAK,GAAG1E,GAAG;IAC5D,IAAIwE,gBAAgB,GAAGF,UAAU,EAAE;MACjCC,UAAU,GAAGjB,KAAK;MAClB;IACF,CAAC,MAAM;MACL;IACF;EACF;EACA,OAAOiB,UAAU;AACnB,CAAC;AACD,MAAMI,YAAY,GAAG,aAAa3F,UAAU,CAAC,CAAC;EAC5C4F,EAAE,GAAG,KAAK;EACV,YAAY,EAAEC,SAAS;EACvBvF,EAAE,EAAEwF,MAAM,GAAG3E,aAAa;EAC1B4E,eAAe,GAAG,KAAK;EACvBd;AACF,CAAC,EAAEe,YAAY,KAAK;EAClB,MAAMC,SAAS,GAAGhG,MAAM,CAAC,IAAI,CAAC;EAC9B,MAAMiG,MAAM,GAAGF,YAAY,KAAK,IAAI,IAAIA,YAAY,KAAK,KAAK,CAAC,GAAGA,YAAY,GAAGC,SAAS;EAC1F,MAAME,OAAO,GAAGlG,MAAM,CAAC,IAAI,CAAC;EAC5B,MAAMmG,WAAW,GAAGnG,MAAM,CAAC,IAAI,CAAC;EAChC,MAAMoG,cAAc,GAAGpG,MAAM,CAAC,IAAI,CAAC;EACnC,MAAMqG,YAAY,GAAGvG,KAAK,CAACE,MAAM,CAAC,IAAI,CAAC;EACvC,MAAMsG,kBAAkB,GAAG9E,KAAK,CAAC,CAAC;EAClC,MAAM;IACJ+E;EACF,CAAC,GAAG/F,QAAQ,CAAC,CAAC;EACd,MAAM,CAACgG,YAAY,EAAEC,eAAe,CAAC,GAAGxG,QAAQ,CAAC,KAAK,CAAC;EACvD,MAAM,CAAC0D,YAAY,EAAE+C,eAAe,CAAC,GAAGzG,QAAQ,CAAC,IAAI,CAAC;EACtD,MAAM,CAACuD,eAAe,EAAEmD,kBAAkB,CAAC,GAAG1G,QAAQ,CAAC,EAAE,CAAC;EAC1D,MAAM,CAACwD,qBAAqB,EAAEmD,wBAAwB,CAAC,GAAG3G,QAAQ,CAAC,EAAE,CAAC;EACtE,MAAM4G,aAAa,GAAG9B,gBAAgB,CAACC,QAAQ,CAAC;;EAEhD;EACA,MAAM,CAAC8B,eAAe,EAAEC,kBAAkB,CAAC,GAAG9G,QAAQ,CAAC;IACrD2D,KAAK,EAAEiD,aAAa;IACpBhD,SAAS,EAAE;EACb,CAAC,CAAC;;EAEF;EACA,MAAMmD,SAAS,GAAGF,eAAe,CAAClD,KAAK,CAACqD,GAAG,CAACC,IAAI,IAAI;IAClD,IAAIC,mBAAmB;IACvB,OAAO,CAACA,mBAAmB,GAAGN,aAAa,CAACO,IAAI,CAAC9C,KAAK,IAAIA,KAAK,CAAChC,GAAG,KAAK4E,IAAI,CAAC5E,GAAG,CAAC,MAAM,IAAI,IAAI6E,mBAAmB,KAAK,KAAK,CAAC,GAAGA,mBAAmB,GAAGD,IAAI;EAC5J,CAAC,CAAC;;EAEF;EACA,MAAMrD,SAAS,GAAGiD,eAAe,CAACjD,SAAS,CAACoD,GAAG,CAACI,QAAQ,IAAI;IAC1D,IAAIC,oBAAoB;IACxB,OAAO,CAACA,oBAAoB,GAAGT,aAAa,CAACO,IAAI,CAAC9C,KAAK,IAAIA,KAAK,CAAChC,GAAG,KAAK+E,QAAQ,CAAC/E,GAAG,CAAC,MAAM,IAAI,IAAIgF,oBAAoB,KAAK,KAAK,CAAC,GAAGA,oBAAoB,GAAGD,QAAQ;EACvK,CAAC,CAAC;EACF;EACA,MAAME,eAAe,GAAGT,eAAe,CAAClD,KAAK,CAACxB,MAAM,KAAK,CAAC;EAC1D,IAAIoF,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;IACzC;IACA;IACAxH,SAAS,CAAC,MAAM;MACd;MACA,MAAMyH,cAAc,GAAGd,aAAa,CAAC1B,MAAM,CAACb,KAAK,IAAI;QACnD,OAAOA,KAAK,CAACG,KAAK,CAAC,cAAc,CAAC,KAAKmD,SAAS;MAClD,CAAC,CAAC;MACF,EAAED,cAAc,CAACvF,MAAM,IAAI,CAAC,CAAC,GAAGoF,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,GAAG/F,SAAS,CAAC,KAAK,EAAE,qCAAqC,CAAC,GAAGA,SAAS,CAAC,KAAK,CAAC,GAAG,KAAK,CAAC;MAC3J,CAACiE,SAAS,GAAG4B,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,GAAG/F,SAAS,CAAC,KAAK,EAAE,mFAAmF,CAAC,GAAGA,SAAS,CAAC,KAAK,CAAC,GAAG,KAAK,CAAC;IACxL,CAAC,CAAC;EACJ;EACA,SAASkG,aAAaA,CAACC,QAAQ,EAAE;IAC/B,IAAIC,qBAAqB,EAAEC,sBAAsB;IACjD,OAAO,CAACD,qBAAqB,GAAG,CAACC,sBAAsB,GAAGvE,qBAAqB,CAAC2D,IAAI,CAACF,IAAI,IAAIA,IAAI,CAACe,IAAI,KAAKH,QAAQ,CAAC,MAAM,IAAI,IAAIE,sBAAsB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,sBAAsB,CAACvC,KAAK,MAAM,IAAI,IAAIsC,qBAAqB,KAAK,KAAK,CAAC,GAAGA,qBAAqB,GAAG,CAAC;EACvR;EACA,MAAMG,wBAAwB,GAAGA,CAACC,mBAAmB,EAAEC,0BAA0B,EAAEC,KAAK,EAAEC,QAAQ,KAAK;IACrG,IAAIC,qBAAqB,EAAEC,gBAAgB;IAC3C;IACA,MAAMC,kBAAkB,GAAGZ,aAAa,CAACM,mBAAmB,CAAC1D,KAAK,CAACO,QAAQ,CAAC;IAC5E;IACA,MAAM0D,cAAc,GAAGzC,MAAM,CAAC0C,OAAO,CAACC,qBAAqB,CAAC,CAAC,CAACnD,KAAK,IAAI,CAAC8C,qBAAqB,GAAG,CAACC,gBAAgB,GAAGtC,OAAO,CAACyC,OAAO,MAAM,IAAI,IAAIH,gBAAgB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,gBAAgB,CAACI,qBAAqB,CAAC,CAAC,CAACnD,KAAK,MAAM,IAAI,IAAI8C,qBAAqB,KAAK,KAAK,CAAC,GAAGA,qBAAqB,GAAG,CAAC,CAAC;;IAEjT;IACA;IACA,MAAMlE,KAAK,GAAGwE,4BAA4B,CAACJ,kBAAkB,EAAEC,cAAc,CAAC;IAC9E,MAAMI,cAAc,GAAGhC,eAAe,CAAClD,KAAK,CAACxB,MAAM,GAAG,CAAC,GAAGiC,KAAK;IAC/D;IACA,MAAM0E,eAAe,GAAG,CAAC,GAAGjC,eAAe,CAAClD,KAAK,CAAC,CAACoF,KAAK,CAAC,CAAC,EAAEF,cAAc,CAAC;IAC3E,MAAMG,eAAe,GAAG,CAAC,GAAGF,eAAe,EAAEZ,mBAAmB,CAAC;IACjE;IACA,MAAMe,gBAAgB,GAAG,CAAC,GAAGpC,eAAe,CAAClD,KAAK,CAAC,CAACoF,KAAK,CAACF,cAAc,CAAC;IACzE,MAAMK,gBAAgB,GAAG,CAAC,GAAGtF,SAAS,CAAC;IACvC;IACAsF,gBAAgB,CAACrE,MAAM,CAACsD,0BAA0B,EAAE,CAAC,EAAE,GAAGc,gBAAgB,CAAC;IAC3EZ,QAAQ,CAAC;MACP1E,KAAK,EAAEqF,eAAe;MACtBpF,SAAS,EAAEsF;IACb,CAAC,EAAE,KAAK,CAAC;EACX,CAAC;EACD;EACA,SAASN,4BAA4BA,CAACJ,kBAAkB,EAAEC,cAAc,EAAE;IACxE,IAAIU,WAAW,GAAG,CAAC;IACnB,IAAI9D,UAAU,GAAG,CAAC;IAClB,KAAK,MAAM,CAACjB,KAAK,EAAE6C,IAAI,CAAC,IAAI,CAAC,GAAGJ,eAAe,CAAClD,KAAK,CAAC,CAACyF,OAAO,CAAC,CAAC,CAAC9E,OAAO,CAAC,CAAC,EAAE;MAC1E6E,WAAW,IAAIvB,aAAa,CAACX,IAAI,CAACzC,KAAK,CAACO,QAAQ,CAAC;MACjD,IAAIyD,kBAAkB,GAAGW,WAAW,GAAGV,cAAc,EAAE;QACrDpD,UAAU,GAAGjB,KAAK;QAClB;MACF;IACF;IACA,OAAOiB,UAAU;EACnB;EACA,MAAM5B,iBAAiB,GAAGvD,WAAW,CAAC,CAACsE,KAAK,EAAE6E,YAAY,KAAK;IAC7DvC,kBAAkB,CAACtC,KAAK,CAAC;IACzBiC,eAAe,CAAC4C,YAAY,CAAC;EAC/B,CAAC,EAAE,EAAE,CAAC;EACN,MAAMC,gBAAgB,GAAGpJ,WAAW,CAACqJ,IAAI,IAAI;IAC3C7C,kBAAkB,CAAC8C,GAAG,IAAI;MACxB,MAAMC,MAAM,GAAG,CAAC,GAAGD,GAAG,EAAED,IAAI,CAAC;MAC7B,OAAOE,MAAM;IACf,CAAC,CAAC;EACJ,CAAC,EAAE,EAAE,CAAC;EACN,MAAMC,sBAAsB,GAAGxJ,WAAW,CAACqJ,IAAI,IAAI;IACjD5C,wBAAwB,CAAC6C,GAAG,IAAI;MAC9B,MAAMC,MAAM,GAAG,CAAC,GAAGD,GAAG,EAAED,IAAI,CAAC;MAC7B,OAAOE,MAAM;IACf,CAAC,CAAC;EACJ,CAAC,EAAE,EAAE,CAAC;EACN,MAAME,YAAY,GAAG9J,KAAK,CAACK,WAAW,CAAC,MAAM;IAC3CsG,eAAe,CAAC,KAAK,CAAC;EACxB,CAAC,EAAE,CAACA,eAAe,CAAC,CAAC;EACrB,MAAMoD,kBAAkB,GAAG/J,KAAK,CAACK,WAAW,CAAC,MAAM;IACjD,IAAI2J,qBAAqB;IACzB,CAACA,qBAAqB,GAAG1D,cAAc,CAACuC,OAAO,MAAM,IAAI,IAAImB,qBAAqB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,qBAAqB,CAACC,KAAK,CAAC,CAAC;EACxI,CAAC,EAAE,EAAE,CAAC;EACN,MAAMC,aAAa,GAAG7J,WAAW,CAACkI,KAAK,IAAI;IACzC,IAAIA,KAAK,CAAC4B,gBAAgB,IAAI5B,KAAK,CAAC6B,MAAM,KAAK,CAAC,EAAE;MAChD;IACF;IACAzD,eAAe,CAACD,YAAY,IAAI,CAACA,YAAY,CAAC;EAChD,CAAC,EAAE,EAAE,CAAC;EACNlF,gBAAgB,CAAC+G,KAAK,IAAI;IACxB,IAAI7B,YAAY,EAAE;MAChB6B,KAAK,CAAC8B,cAAc,CAAC,CAAC;MACtBP,YAAY,CAAC,CAAC;MACdC,kBAAkB,CAAC,CAAC;IACtB;EACF,CAAC,EAAE,CAACrD,YAAY,CAAC,CAAC;EAClBjF,iBAAiB,CAAC;IAChB6I,cAAc,EAAER,YAAY;IAC5BvD,YAAY;IACZgE,eAAe,EAAE,CAACjE,cAAc;EAClC,CAAC,CAAC;EACF7F,iBAAiB,CAAC+J,qBAAqB,IAAI;IACzC,IAAIC,qBAAqB,EAAEC,oBAAoB;IAC/C,MAAMnH,QAAQ,GAAGiH,qBAAqB,CAAC,CAAC,CAAC,CAACG,WAAW,CAAChF,KAAK;IAC3D,MAAMnC,aAAa,GAAG,CAACiH,qBAAqB,GAAG,CAACC,oBAAoB,GAAGrE,WAAW,CAACwC,OAAO,MAAM,IAAI,IAAI6B,oBAAoB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,oBAAoB,CAAC5B,qBAAqB,CAAC,CAAC,CAACnD,KAAK,MAAM,IAAI,IAAI8E,qBAAqB,KAAK,KAAK,CAAC,GAAGA,qBAAqB,GAAG,CAAC;IAC/QlH,QAAQ,KAAK,CAAC,IAAID,cAAc,CAACC,QAAQ,EAAEC,aAAa,EAAEuD,aAAa,EAAErD,eAAe,EAAEC,qBAAqB,EAAEC,iBAAiB,CAAC;EACrI,CAAC,EAAEuC,MAAM,CAAC;EACV,OAAO,aAAanG,KAAK,CAAC4K,aAAa,CAACpK,mBAAmB,CAACqK,QAAQ,EAAE;IACpEC,KAAK,EAAE;MACLrE,KAAK;MACLgD,gBAAgB;MAChBI,sBAAsB;MACtB7D,eAAe;MACfnC;IACF;EACF,CAAC,EAAEiC,SAAS,IAAI,aAAa9F,KAAK,CAAC4K,aAAa,CAACjK,cAAc,EAAE;IAC/DkF,EAAE,EAAE;EACN,CAAC,EAAG,GAAEC,SAAU,aAAY,CAAC,EAAE,aAAa9F,KAAK,CAAC4K,aAAa,CAACtK,GAAG,EAAE;IACnEuF,EAAE,EAAEA,EAAE;IACNtF,EAAE,EAAEuB,KAAK,CAAClB,YAAY,CAAC6F,KAAK,CAAC,EAAEV,MAAM,CAAC;IACtC,YAAY,EAAED,SAAS;IACvBiF,GAAG,EAAE5E;EACP,CAAC,EAAE,aAAanG,KAAK,CAAC4K,aAAa,CAAC7H,cAAc,EAAE;IAClDxC,EAAE,EAAEM,QAAQ;IACZkK,GAAG,EAAE3E,OAAO;IACZ4E,IAAI,EAAE;EACR,CAAC,EAAE9D,SAAS,EAAEnD,SAAS,CAACzB,MAAM,GAAG,CAAC,IAAI,aAAatC,KAAK,CAAC4K,aAAa,CAACxH,gBAAgB,EAAE;IACvF2H,GAAG,EAAE1E;EACP,CAAC,EAAE,CAACoB,eAAe,IAAI,aAAazH,KAAK,CAAC4K,aAAa,CAACtK,GAAG,EAAE;IAC3DC,EAAE,EAAEO,eAAe,CAAC2F,KAAK;EAC3B,CAAC,CAAC,EAAE,aAAazG,KAAK,CAAC4K,aAAa,CAACtJ,eAAe,EAAE;IACpDyJ,GAAG,EAAEzE,cAAc;IACnB/F,EAAE,EAAEQ,aAAa;IACjB,eAAe,EAAEyF,kBAAkB;IACnC,eAAe,EAAEE,YAAY;IAC7BuE,OAAO,EAAEf,aAAa;IACtBgB,cAAc,EAAE3J;EAClB,CAAC,EAAE,aAAavB,KAAK,CAAC4K,aAAa,CAACtK,GAAG,EAAE;IACvCuF,EAAE,EAAE;EACN,CAAC,EAAE4B,eAAe,GAAG,aAAazH,KAAK,CAAC4K,aAAa,CAAC5K,KAAK,CAACmL,QAAQ,EAAE,IAAI,EAAE,aAAanL,KAAK,CAAC4K,aAAa,CAACjK,cAAc,EAAE;IAC3HkF,EAAE,EAAE;EACN,CAAC,EAAG,GAAEC,SAAU,EAAC,EAAE,MAAM,CAAC,EAAE,MAAM,CAAC,GAAG,aAAa9F,KAAK,CAAC4K,aAAa,CAAC5K,KAAK,CAACmL,QAAQ,EAAE,IAAI,EAAE,MAAM,EAAE,aAAanL,KAAK,CAAC4K,aAAa,CAACjK,cAAc,EAAE;IACpJkF,EAAE,EAAE;EACN,CAAC,EAAE,MAAM,EAAG,GAAEC,SAAU,QAAO,CAAC,CAAC,CAAC,CAAC,EAAE,aAAa9F,KAAK,CAAC4K,aAAa,CAACjJ,UAAU,EAAE;IAChFyJ,gBAAgB,EAAE,QAAQ;IAC1BL,GAAG,EAAExE,YAAY;IACjB8E,EAAE,EAAE7E,kBAAkB;IACtBjG,EAAE,EAAES,UAAU;IACdsK,KAAK,EAAE;MACLC,OAAO,EAAE7E,YAAY,GAAG,OAAO,GAAG;IACpC;EACF,CAAC,EAAE3C,SAAS,CAACoD,GAAG,CAAC,CAACI,QAAQ,EAAEhD,KAAK,KAAK;IACpC,MAAM;MACJW,QAAQ,EAAEsG,gBAAgB;MAC1BC,OAAO;MACP,cAAc,EAAE/G,WAAW;MAC3BgH,QAAQ;MACR,GAAGC;IACL,CAAC,GAAGpE,QAAQ,CAAC5C,KAAK;;IAElB;IACA,IAAIE,OAAO,CAACH,WAAW,CAAC,IAAIA,WAAW,KAAK,OAAO,EAAE;MACnD,MAAM6D,KAAK,GAAG,IAAIqD,UAAU,CAAC,OAAO,CAAC;MACrC,CAACnE,eAAe,IAAIW,wBAAwB,CAACb,QAAQ,EAAEhD,KAAK;MAC5D;MACAgE,KAAK,EAAE3E,iBAAiB,CAAC;IAC3B;IACA,OAAO,aAAa5D,KAAK,CAAC4K,aAAa,CAACjJ,UAAU,CAACkK,QAAQ,EAAE9J,QAAQ,CAAC;MACpES,GAAG,EAAEgJ,gBAAgB;MACrBjL,EAAE,EAAEW,cAAc;MAClB+J,OAAO,EAAE1C,KAAK,IAAI;QAChB;QACA,CAACd,eAAe,IAAIW,wBAAwB,CAACb,QAAQ,EAAEhD,KAAK,EAAEgE,KAAK,EAAE3E,iBAAiB,CAAC;QACvFkG,YAAY,CAAC,CAAC;QACdC,kBAAkB,CAAC,CAAC;QACpB;QACA,OAAO2B,QAAQ,KAAK,UAAU,IAAIA,QAAQ,CAACnD,KAAK,CAAC;MACnD;IACF,CAAC,EAAEoD,aAAa,CAAC,EAAE,aAAa3L,KAAK,CAAC4K,aAAa,CAACtK,GAAG,EAAE;MACvDuF,EAAE,EAAE,MAAM;MACVtF,EAAE,EAAE;QACFgL,OAAO,EAAE,MAAM;QACfO,UAAU,EAAE,QAAQ;QACpBC,cAAc,EAAE;MAClB;IACF,CAAC,EAAEP,gBAAgB,EAAExF,eAAe,GAAG,aAAahG,KAAK,CAAC4K,aAAa,CAAChJ,cAAc,EAAE,IAAI,CAAC,GAAG6J,OAAO,KAAK3D,SAAS,IAAI,aAAa9H,KAAK,CAAC4K,aAAa,CAACtK,GAAG,EAAE;MAC7JuF,EAAE,EAAE,MAAM;MACV,gBAAgB,EAAE;IACpB,CAAC,EAAE,aAAa7F,KAAK,CAAC4K,aAAa,CAACvJ,YAAY,EAAE,IAAI,EAAEoK,OAAO,CAAC,CAAC,CAAC,CAAC;EACrE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACT,CAAC,CAAC;AACF7F,YAAY,CAAC1C,WAAW,GAAG,cAAc;AAEzC,SAAS0C,YAAY"},"metadata":{},"sourceType":"module","externalDependencies":[]}