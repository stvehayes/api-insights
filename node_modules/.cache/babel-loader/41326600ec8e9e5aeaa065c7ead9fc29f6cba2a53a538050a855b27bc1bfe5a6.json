{"ast":null,"code":"import React from 'react';\nimport styled from 'styled-components';\nimport { XIcon } from '@primer/octicons-react';\nimport { getFocusableChild } from '@primer/behaviors/utils';\nimport { get } from '../constants.js';\nimport VisuallyHidden from '../_VisuallyHidden.js';\nimport { AnchoredOverlay } from '../AnchoredOverlay/AnchoredOverlay.js';\nimport Box from '../Box/Box.js';\nimport { IconButton } from '../Button/IconButton.js';\nimport sx from '../sx.js';\nimport { useTheme } from '../ThemeProvider.js';\nimport '../Button/types.js';\nimport '../utils/defaultSxProp.js';\nimport '../CounterLabel/CounterLabel.js';\nimport { ButtonComponent } from '../Button/Button.js';\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nconst StyledLabelGroupContainer = styled.div.withConfig({\n  displayName: \"LabelGroup__StyledLabelGroupContainer\",\n  componentId: \"sc-6tqg8q-0\"\n})([\"display:flex;flex-wrap:nowrap;gap:\", \";line-height:1;max-width:100%;overflow:hidden;&[data-overflow='inline']{flex-wrap:wrap;}\", \";\"], get('space.1'), sx);\nconst ItemWrapper = styled.div.withConfig({\n  displayName: \"LabelGroup__ItemWrapper\",\n  componentId: \"sc-6tqg8q-1\"\n})([\"display:flex;align-items:center;min-height:28px;&.ItemWrapper--hidden{order:9999;pointer-events:none;visibility:hidden;}\"]);\n\n// Calculates the width of the overlay to cover the labels/tokens and the expand button.\nconst getOverlayWidth = (buttonClientRect, containerRef, overlayPaddingPx) => {\n  var _containerRef$current;\n  return overlayPaddingPx + buttonClientRect.right - (((_containerRef$current = containerRef.current) === null || _containerRef$current === void 0 ? void 0 : _containerRef$current.getBoundingClientRect().left) || 0);\n};\nconst InlineToggle = ({\n  collapseButtonRef,\n  collapseInlineExpandedChildren,\n  expandButtonRef,\n  hiddenItemIds,\n  isOverflowShown,\n  showAllTokensInline,\n  totalLength\n}) => isOverflowShown ? /*#__PURE__*/React.createElement(ButtonComponent, {\n  ref: collapseButtonRef,\n  onClick: collapseInlineExpandedChildren,\n  size: \"small\",\n  variant: \"invisible\"\n}, \"Show less\") : hiddenItemIds.length ? /*#__PURE__*/React.createElement(ButtonComponent, {\n  ref: expandButtonRef,\n  variant: \"invisible\",\n  size: \"small\",\n  onClick: showAllTokensInline\n}, /*#__PURE__*/React.createElement(VisuallyHidden, null, \"Show all \", totalLength), /*#__PURE__*/React.createElement(\"span\", {\n  \"aria-hidden\": \"true\"\n}, \"+\", hiddenItemIds.length)) : null;\nconst OverlayToggle = ({\n  children,\n  closeOverflowOverlay,\n  expandButtonRef,\n  hiddenItemIds,\n  isOverflowShown,\n  openOverflowOverlay,\n  overlayPaddingPx,\n  overlayWidth,\n  totalLength\n}) => hiddenItemIds.length ? /*#__PURE__*/React.createElement(AnchoredOverlay, {\n  open: isOverflowShown,\n  onOpen: openOverflowOverlay,\n  onClose: closeOverflowOverlay,\n  width: \"auto\",\n  height: \"auto\",\n  align: \"start\",\n  side: \"inside-right\"\n  // expandButtonRef satisfies React.RefObject<HTMLButtonElement> because we manually set `.current` in the `useCallback` above\n  ,\n\n  anchorRef: expandButtonRef,\n  anchorOffset: overlayPaddingPx * -1,\n  alignmentOffset: overlayPaddingPx * -1,\n  renderAnchor: props => /*#__PURE__*/React.createElement(ButtonComponent, _extends({\n    variant: \"invisible\",\n    size: \"small\"\n  }, props, {\n    ref: expandButtonRef\n  }), /*#__PURE__*/React.createElement(VisuallyHidden, null, \"Show all \", totalLength), /*#__PURE__*/React.createElement(\"span\", {\n    \"aria-hidden\": \"true\"\n  }, \"+\", hiddenItemIds.length)),\n  focusZoneSettings: {\n    disabled: true\n  }\n}, /*#__PURE__*/React.createElement(Box, {\n  alignItems: \"flex-start\",\n  display: \"flex\",\n  width: overlayWidth,\n  padding: `${overlayPaddingPx}px`\n}, /*#__PURE__*/React.createElement(Box, {\n  display: \"flex\",\n  flexWrap: \"wrap\",\n  sx: {\n    gap: 1\n  }\n}, children), /*#__PURE__*/React.createElement(IconButton, {\n  onClick: closeOverflowOverlay,\n  icon: XIcon,\n  \"aria-label\": \"Close\",\n  variant: \"invisible\",\n  sx: {\n    flexShrink: 0\n  }\n}))) : null;\n\n// TODO: reduce re-renders\nconst LabelGroup = ({\n  children,\n  visibleChildCount,\n  overflowStyle = 'overlay',\n  sx: sxProp\n}) => {\n  const containerRef = React.useRef(null);\n  const collapseButtonRef = React.useRef(null);\n  const firstHiddenIndexRef = React.useRef(undefined);\n  const [visibilityMap, setVisibilityMap] = React.useState({});\n  const [isOverflowShown, setIsOverflowShown] = React.useState(false);\n  const [buttonClientRect, setButtonClientRect] = React.useState({\n    width: 0,\n    right: 0,\n    height: 0,\n    x: 0,\n    y: 0,\n    top: 0,\n    left: 0,\n    bottom: 0,\n    toJSON: () => undefined\n  });\n  const {\n    theme\n  } = useTheme();\n  const overlayPaddingPx = parseInt(get('space.2')(theme), 10);\n  const hiddenItemIds = Object.keys(visibilityMap).filter(key => !visibilityMap[key]);\n\n  // `overlayWidth` is only needed when we render an overlay\n  // if we don't use an overlay, we can skip the width calculation\n  // and save on reflows caused by measuring DOM nodes.\n  const overlayWidth = hiddenItemIds.length && overflowStyle === 'overlay' ? getOverlayWidth(buttonClientRect, containerRef, overlayPaddingPx) : undefined;\n  const expandButtonRef = React.useCallback(node => {\n    if (node !== null) {\n      const nodeClientRect = node.getBoundingClientRect();\n      if (nodeClientRect.width !== buttonClientRect.width || nodeClientRect.right !== buttonClientRect.right) {\n        setButtonClientRect(nodeClientRect);\n      }\n\n      // @ts-ignore you can set `.current` on ref objects or ref callbacks in React\n      expandButtonRef.current = node;\n    }\n  }, [buttonClientRect]);\n\n  // Sets the visibility map to hide children after the given index.\n  const hideChildrenAfterIndex = React.useCallback(truncateAfter => {\n    var _containerRef$current2;\n    const containerChildren = ((_containerRef$current2 = containerRef.current) === null || _containerRef$current2 === void 0 ? void 0 : _containerRef$current2.children) || [];\n    const updatedEntries = {};\n    for (const child of containerChildren) {\n      const targetId = child.getAttribute('data-index');\n      if (targetId) {\n        updatedEntries[targetId] = parseInt(targetId, 10) < truncateAfter;\n      }\n    }\n    setVisibilityMap(updatedEntries);\n  }, []);\n  const openOverflowOverlay = React.useCallback(() => setIsOverflowShown(true), [setIsOverflowShown]);\n  const closeOverflowOverlay = React.useCallback(() => {\n    setIsOverflowShown(false);\n  }, [setIsOverflowShown]);\n  const collapseInlineExpandedChildren = React.useCallback(() => {\n    setIsOverflowShown(false);\n    if (visibleChildCount && typeof visibleChildCount === 'number') {\n      hideChildrenAfterIndex(visibleChildCount);\n    }\n\n    // We need to manually re-focus the collapse button if we're not showing the full\n    // list in an overlay.\n    // TODO: get rid of this hack\n    setTimeout(() => {\n      var _expandButtonRef$curr;\n      // @ts-ignore you can set `.current` on ref objects or ref callbacks in React\n      (_expandButtonRef$curr = expandButtonRef.current) === null || _expandButtonRef$curr === void 0 ? void 0 : _expandButtonRef$curr.focus();\n    }, 10);\n  }, [expandButtonRef, hideChildrenAfterIndex, visibleChildCount]);\n  const showAllTokensInline = React.useCallback(() => {\n    setVisibilityMap({});\n    setIsOverflowShown(true);\n  }, [setVisibilityMap, setIsOverflowShown]);\n  React.useEffect(() => {\n    // If we're not truncating, we don't need to run this useEffect.\n    if (!visibleChildCount || isOverflowShown) {\n      return;\n    }\n    if (visibleChildCount === 'auto') {\n      // Instatiates the IntersectionObserver to track when children fit in the container.\n      const observer = new IntersectionObserver(entries => {\n        const updatedEntries = {};\n        for (const entry of entries) {\n          // Checks which children are intersecting the root container\n          const targetId = entry.target.getAttribute('data-index');\n          if (targetId) {\n            updatedEntries[targetId] = entry.isIntersecting;\n          }\n        }\n\n        // Updates the visibility map based on the intersection results.\n        setVisibilityMap(prev => ({\n          ...prev,\n          ...updatedEntries\n        }));\n      }, {\n        root: containerRef.current,\n        rootMargin: `0px -${buttonClientRect.width}px 0px 0px`,\n        threshold: 1\n      });\n      for (const item of ((_containerRef$current3 = containerRef.current) === null || _containerRef$current3 === void 0 ? void 0 : _containerRef$current3.children) || []) {\n        var _containerRef$current3;\n        if (item.getAttribute('data-index')) {\n          observer.observe(item);\n        }\n      }\n      return () => observer.disconnect();\n    }\n    // We're not auto truncating, so we need to hide children after the given `visibleChildCount`.\n    else {\n      hideChildrenAfterIndex(visibleChildCount);\n    }\n  }, [buttonClientRect, visibleChildCount, hideChildrenAfterIndex, isOverflowShown]);\n\n  // Updates the index of the first hidden child.\n  // We need to keep track of this so we can focus the first hidden child when the overflow is shown inline.\n  React.useEffect(() => {\n    // If we're using an overlay, we don't need to keep track of the first hidden index.\n    if (overflowStyle === 'overlay') {\n      return;\n    }\n    if (hiddenItemIds.length) {\n      firstHiddenIndexRef.current = parseInt(hiddenItemIds[0], 10);\n    }\n  }, [hiddenItemIds, overflowStyle, isOverflowShown]);\n\n  // Updates the index of the first hidden child.\n  // We need to keep track of this so we can focus the first hidden child when the overflow is shown inline.\n  React.useEffect(() => {\n    // If we're using an overlay, we don't need to focus the first child that was previously hidden.\n    if (overflowStyle === 'overlay') {\n      return;\n    }\n    const firstHiddenChildDOM = document.querySelector(`[data-index=\"${firstHiddenIndexRef.current}\"]`);\n    const focusableChild = firstHiddenChildDOM ? getFocusableChild(firstHiddenChildDOM) : null;\n    if (isOverflowShown) {\n      // If the first hidden child is focusable, focus it.\n      // Otherwise, focus the collapse button.\n      if (focusableChild) {\n        focusableChild.focus();\n      } else {\n        var _collapseButtonRef$cu;\n        (_collapseButtonRef$cu = collapseButtonRef.current) === null || _collapseButtonRef$cu === void 0 ? void 0 : _collapseButtonRef$cu.focus();\n      }\n    }\n  }, [overflowStyle, isOverflowShown]);\n\n  // If truncation is enabled, we need to render based on truncation logic.\n  return visibleChildCount ? /*#__PURE__*/React.createElement(StyledLabelGroupContainer, {\n    ref: containerRef,\n    \"data-overflow\": overflowStyle === 'inline' && isOverflowShown ? 'inline' : undefined,\n    sx: sxProp\n  }, React.Children.map(children, (child, index) => /*#__PURE__*/React.createElement(ItemWrapper\n  // data-index is used as an identifier we can use in the IntersectionObserver\n  , {\n    \"data-index\": index,\n    className: hiddenItemIds.includes(index.toString()) ? 'ItemWrapper--hidden' : undefined\n  }, child)), overflowStyle === 'inline' ? /*#__PURE__*/React.createElement(InlineToggle, {\n    collapseButtonRef: collapseButtonRef,\n    collapseInlineExpandedChildren: collapseInlineExpandedChildren,\n    expandButtonRef: expandButtonRef,\n    hiddenItemIds: hiddenItemIds,\n    isOverflowShown: isOverflowShown,\n    showAllTokensInline: showAllTokensInline,\n    totalLength: React.Children.toArray(children).length\n  }) : /*#__PURE__*/React.createElement(OverlayToggle, {\n    closeOverflowOverlay: closeOverflowOverlay,\n    expandButtonRef: expandButtonRef,\n    hiddenItemIds: hiddenItemIds,\n    isOverflowShown: isOverflowShown,\n    openOverflowOverlay: openOverflowOverlay,\n    overlayPaddingPx: overlayPaddingPx,\n    overlayWidth: overlayWidth,\n    totalLength: React.Children.toArray(children).length\n  }, children)) : /*#__PURE__*/React.createElement(StyledLabelGroupContainer, {\n    \"data-overflow\": \"inline\",\n    sx: sxProp\n  }, children);\n};\nLabelGroup.displayName = 'LabelGroup';\nexport { LabelGroup as default };","map":{"version":3,"names":["React","styled","XIcon","getFocusableChild","get","VisuallyHidden","AnchoredOverlay","Box","IconButton","sx","useTheme","ButtonComponent","_extends","Object","assign","bind","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","StyledLabelGroupContainer","div","withConfig","displayName","componentId","ItemWrapper","getOverlayWidth","buttonClientRect","containerRef","overlayPaddingPx","_containerRef$current","right","current","getBoundingClientRect","left","InlineToggle","collapseButtonRef","collapseInlineExpandedChildren","expandButtonRef","hiddenItemIds","isOverflowShown","showAllTokensInline","totalLength","createElement","ref","onClick","size","variant","OverlayToggle","children","closeOverflowOverlay","openOverflowOverlay","overlayWidth","open","onOpen","onClose","width","height","align","side","anchorRef","anchorOffset","alignmentOffset","renderAnchor","props","focusZoneSettings","disabled","alignItems","display","padding","flexWrap","gap","icon","flexShrink","LabelGroup","visibleChildCount","overflowStyle","sxProp","useRef","firstHiddenIndexRef","undefined","visibilityMap","setVisibilityMap","useState","setIsOverflowShown","setButtonClientRect","x","y","top","bottom","toJSON","theme","parseInt","keys","filter","useCallback","node","nodeClientRect","hideChildrenAfterIndex","truncateAfter","_containerRef$current2","containerChildren","updatedEntries","child","targetId","getAttribute","setTimeout","_expandButtonRef$curr","focus","useEffect","observer","IntersectionObserver","entries","entry","isIntersecting","prev","root","rootMargin","threshold","item","_containerRef$current3","observe","disconnect","firstHiddenChildDOM","document","querySelector","focusableChild","_collapseButtonRef$cu","Children","map","index","className","includes","toString","toArray","default"],"sources":["/Users/steve/Documents/repos/github/licensing/node_modules/@primer/react/lib-esm/LabelGroup/LabelGroup.js"],"sourcesContent":["import React from 'react';\nimport styled from 'styled-components';\nimport { XIcon } from '@primer/octicons-react';\nimport { getFocusableChild } from '@primer/behaviors/utils';\nimport { get } from '../constants.js';\nimport VisuallyHidden from '../_VisuallyHidden.js';\nimport { AnchoredOverlay } from '../AnchoredOverlay/AnchoredOverlay.js';\nimport Box from '../Box/Box.js';\nimport { IconButton } from '../Button/IconButton.js';\nimport sx from '../sx.js';\nimport { useTheme } from '../ThemeProvider.js';\nimport '../Button/types.js';\nimport '../utils/defaultSxProp.js';\nimport '../CounterLabel/CounterLabel.js';\nimport { ButtonComponent } from '../Button/Button.js';\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nconst StyledLabelGroupContainer = styled.div.withConfig({\n  displayName: \"LabelGroup__StyledLabelGroupContainer\",\n  componentId: \"sc-6tqg8q-0\"\n})([\"display:flex;flex-wrap:nowrap;gap:\", \";line-height:1;max-width:100%;overflow:hidden;&[data-overflow='inline']{flex-wrap:wrap;}\", \";\"], get('space.1'), sx);\nconst ItemWrapper = styled.div.withConfig({\n  displayName: \"LabelGroup__ItemWrapper\",\n  componentId: \"sc-6tqg8q-1\"\n})([\"display:flex;align-items:center;min-height:28px;&.ItemWrapper--hidden{order:9999;pointer-events:none;visibility:hidden;}\"]);\n\n// Calculates the width of the overlay to cover the labels/tokens and the expand button.\nconst getOverlayWidth = (buttonClientRect, containerRef, overlayPaddingPx) => {\n  var _containerRef$current;\n  return overlayPaddingPx + buttonClientRect.right - (((_containerRef$current = containerRef.current) === null || _containerRef$current === void 0 ? void 0 : _containerRef$current.getBoundingClientRect().left) || 0);\n};\nconst InlineToggle = ({\n  collapseButtonRef,\n  collapseInlineExpandedChildren,\n  expandButtonRef,\n  hiddenItemIds,\n  isOverflowShown,\n  showAllTokensInline,\n  totalLength\n}) => isOverflowShown ? /*#__PURE__*/React.createElement(ButtonComponent, {\n  ref: collapseButtonRef,\n  onClick: collapseInlineExpandedChildren,\n  size: \"small\",\n  variant: \"invisible\"\n}, \"Show less\") : hiddenItemIds.length ? /*#__PURE__*/React.createElement(ButtonComponent, {\n  ref: expandButtonRef,\n  variant: \"invisible\",\n  size: \"small\",\n  onClick: showAllTokensInline\n}, /*#__PURE__*/React.createElement(VisuallyHidden, null, \"Show all \", totalLength), /*#__PURE__*/React.createElement(\"span\", {\n  \"aria-hidden\": \"true\"\n}, \"+\", hiddenItemIds.length)) : null;\nconst OverlayToggle = ({\n  children,\n  closeOverflowOverlay,\n  expandButtonRef,\n  hiddenItemIds,\n  isOverflowShown,\n  openOverflowOverlay,\n  overlayPaddingPx,\n  overlayWidth,\n  totalLength\n}) => hiddenItemIds.length ? /*#__PURE__*/React.createElement(AnchoredOverlay, {\n  open: isOverflowShown,\n  onOpen: openOverflowOverlay,\n  onClose: closeOverflowOverlay,\n  width: \"auto\",\n  height: \"auto\",\n  align: \"start\",\n  side: \"inside-right\"\n  // expandButtonRef satisfies React.RefObject<HTMLButtonElement> because we manually set `.current` in the `useCallback` above\n  ,\n  anchorRef: expandButtonRef,\n  anchorOffset: overlayPaddingPx * -1,\n  alignmentOffset: overlayPaddingPx * -1,\n  renderAnchor: props => /*#__PURE__*/React.createElement(ButtonComponent, _extends({\n    variant: \"invisible\",\n    size: \"small\"\n  }, props, {\n    ref: expandButtonRef\n  }), /*#__PURE__*/React.createElement(VisuallyHidden, null, \"Show all \", totalLength), /*#__PURE__*/React.createElement(\"span\", {\n    \"aria-hidden\": \"true\"\n  }, \"+\", hiddenItemIds.length)),\n  focusZoneSettings: {\n    disabled: true\n  }\n}, /*#__PURE__*/React.createElement(Box, {\n  alignItems: \"flex-start\",\n  display: \"flex\",\n  width: overlayWidth,\n  padding: `${overlayPaddingPx}px`\n}, /*#__PURE__*/React.createElement(Box, {\n  display: \"flex\",\n  flexWrap: \"wrap\",\n  sx: {\n    gap: 1\n  }\n}, children), /*#__PURE__*/React.createElement(IconButton, {\n  onClick: closeOverflowOverlay,\n  icon: XIcon,\n  \"aria-label\": \"Close\",\n  variant: \"invisible\",\n  sx: {\n    flexShrink: 0\n  }\n}))) : null;\n\n// TODO: reduce re-renders\nconst LabelGroup = ({\n  children,\n  visibleChildCount,\n  overflowStyle = 'overlay',\n  sx: sxProp\n}) => {\n  const containerRef = React.useRef(null);\n  const collapseButtonRef = React.useRef(null);\n  const firstHiddenIndexRef = React.useRef(undefined);\n  const [visibilityMap, setVisibilityMap] = React.useState({});\n  const [isOverflowShown, setIsOverflowShown] = React.useState(false);\n  const [buttonClientRect, setButtonClientRect] = React.useState({\n    width: 0,\n    right: 0,\n    height: 0,\n    x: 0,\n    y: 0,\n    top: 0,\n    left: 0,\n    bottom: 0,\n    toJSON: () => undefined\n  });\n  const {\n    theme\n  } = useTheme();\n  const overlayPaddingPx = parseInt(get('space.2')(theme), 10);\n  const hiddenItemIds = Object.keys(visibilityMap).filter(key => !visibilityMap[key]);\n\n  // `overlayWidth` is only needed when we render an overlay\n  // if we don't use an overlay, we can skip the width calculation\n  // and save on reflows caused by measuring DOM nodes.\n  const overlayWidth = hiddenItemIds.length && overflowStyle === 'overlay' ? getOverlayWidth(buttonClientRect, containerRef, overlayPaddingPx) : undefined;\n  const expandButtonRef = React.useCallback(node => {\n    if (node !== null) {\n      const nodeClientRect = node.getBoundingClientRect();\n      if (nodeClientRect.width !== buttonClientRect.width || nodeClientRect.right !== buttonClientRect.right) {\n        setButtonClientRect(nodeClientRect);\n      }\n\n      // @ts-ignore you can set `.current` on ref objects or ref callbacks in React\n      expandButtonRef.current = node;\n    }\n  }, [buttonClientRect]);\n\n  // Sets the visibility map to hide children after the given index.\n  const hideChildrenAfterIndex = React.useCallback(truncateAfter => {\n    var _containerRef$current2;\n    const containerChildren = ((_containerRef$current2 = containerRef.current) === null || _containerRef$current2 === void 0 ? void 0 : _containerRef$current2.children) || [];\n    const updatedEntries = {};\n    for (const child of containerChildren) {\n      const targetId = child.getAttribute('data-index');\n      if (targetId) {\n        updatedEntries[targetId] = parseInt(targetId, 10) < truncateAfter;\n      }\n    }\n    setVisibilityMap(updatedEntries);\n  }, []);\n  const openOverflowOverlay = React.useCallback(() => setIsOverflowShown(true), [setIsOverflowShown]);\n  const closeOverflowOverlay = React.useCallback(() => {\n    setIsOverflowShown(false);\n  }, [setIsOverflowShown]);\n  const collapseInlineExpandedChildren = React.useCallback(() => {\n    setIsOverflowShown(false);\n    if (visibleChildCount && typeof visibleChildCount === 'number') {\n      hideChildrenAfterIndex(visibleChildCount);\n    }\n\n    // We need to manually re-focus the collapse button if we're not showing the full\n    // list in an overlay.\n    // TODO: get rid of this hack\n    setTimeout(() => {\n      var _expandButtonRef$curr;\n      // @ts-ignore you can set `.current` on ref objects or ref callbacks in React\n      (_expandButtonRef$curr = expandButtonRef.current) === null || _expandButtonRef$curr === void 0 ? void 0 : _expandButtonRef$curr.focus();\n    }, 10);\n  }, [expandButtonRef, hideChildrenAfterIndex, visibleChildCount]);\n  const showAllTokensInline = React.useCallback(() => {\n    setVisibilityMap({});\n    setIsOverflowShown(true);\n  }, [setVisibilityMap, setIsOverflowShown]);\n  React.useEffect(() => {\n    // If we're not truncating, we don't need to run this useEffect.\n    if (!visibleChildCount || isOverflowShown) {\n      return;\n    }\n    if (visibleChildCount === 'auto') {\n      // Instatiates the IntersectionObserver to track when children fit in the container.\n      const observer = new IntersectionObserver(entries => {\n        const updatedEntries = {};\n        for (const entry of entries) {\n          // Checks which children are intersecting the root container\n          const targetId = entry.target.getAttribute('data-index');\n          if (targetId) {\n            updatedEntries[targetId] = entry.isIntersecting;\n          }\n        }\n\n        // Updates the visibility map based on the intersection results.\n        setVisibilityMap(prev => ({\n          ...prev,\n          ...updatedEntries\n        }));\n      }, {\n        root: containerRef.current,\n        rootMargin: `0px -${buttonClientRect.width}px 0px 0px`,\n        threshold: 1\n      });\n      for (const item of ((_containerRef$current3 = containerRef.current) === null || _containerRef$current3 === void 0 ? void 0 : _containerRef$current3.children) || []) {\n        var _containerRef$current3;\n        if (item.getAttribute('data-index')) {\n          observer.observe(item);\n        }\n      }\n      return () => observer.disconnect();\n    }\n    // We're not auto truncating, so we need to hide children after the given `visibleChildCount`.\n    else {\n      hideChildrenAfterIndex(visibleChildCount);\n    }\n  }, [buttonClientRect, visibleChildCount, hideChildrenAfterIndex, isOverflowShown]);\n\n  // Updates the index of the first hidden child.\n  // We need to keep track of this so we can focus the first hidden child when the overflow is shown inline.\n  React.useEffect(() => {\n    // If we're using an overlay, we don't need to keep track of the first hidden index.\n    if (overflowStyle === 'overlay') {\n      return;\n    }\n    if (hiddenItemIds.length) {\n      firstHiddenIndexRef.current = parseInt(hiddenItemIds[0], 10);\n    }\n  }, [hiddenItemIds, overflowStyle, isOverflowShown]);\n\n  // Updates the index of the first hidden child.\n  // We need to keep track of this so we can focus the first hidden child when the overflow is shown inline.\n  React.useEffect(() => {\n    // If we're using an overlay, we don't need to focus the first child that was previously hidden.\n    if (overflowStyle === 'overlay') {\n      return;\n    }\n    const firstHiddenChildDOM = document.querySelector(`[data-index=\"${firstHiddenIndexRef.current}\"]`);\n    const focusableChild = firstHiddenChildDOM ? getFocusableChild(firstHiddenChildDOM) : null;\n    if (isOverflowShown) {\n      // If the first hidden child is focusable, focus it.\n      // Otherwise, focus the collapse button.\n      if (focusableChild) {\n        focusableChild.focus();\n      } else {\n        var _collapseButtonRef$cu;\n        (_collapseButtonRef$cu = collapseButtonRef.current) === null || _collapseButtonRef$cu === void 0 ? void 0 : _collapseButtonRef$cu.focus();\n      }\n    }\n  }, [overflowStyle, isOverflowShown]);\n\n  // If truncation is enabled, we need to render based on truncation logic.\n  return visibleChildCount ? /*#__PURE__*/React.createElement(StyledLabelGroupContainer, {\n    ref: containerRef,\n    \"data-overflow\": overflowStyle === 'inline' && isOverflowShown ? 'inline' : undefined,\n    sx: sxProp\n  }, React.Children.map(children, (child, index) => /*#__PURE__*/React.createElement(ItemWrapper\n  // data-index is used as an identifier we can use in the IntersectionObserver\n  , {\n    \"data-index\": index,\n    className: hiddenItemIds.includes(index.toString()) ? 'ItemWrapper--hidden' : undefined\n  }, child)), overflowStyle === 'inline' ? /*#__PURE__*/React.createElement(InlineToggle, {\n    collapseButtonRef: collapseButtonRef,\n    collapseInlineExpandedChildren: collapseInlineExpandedChildren,\n    expandButtonRef: expandButtonRef,\n    hiddenItemIds: hiddenItemIds,\n    isOverflowShown: isOverflowShown,\n    showAllTokensInline: showAllTokensInline,\n    totalLength: React.Children.toArray(children).length\n  }) : /*#__PURE__*/React.createElement(OverlayToggle, {\n    closeOverflowOverlay: closeOverflowOverlay,\n    expandButtonRef: expandButtonRef,\n    hiddenItemIds: hiddenItemIds,\n    isOverflowShown: isOverflowShown,\n    openOverflowOverlay: openOverflowOverlay,\n    overlayPaddingPx: overlayPaddingPx,\n    overlayWidth: overlayWidth,\n    totalLength: React.Children.toArray(children).length\n  }, children)) : /*#__PURE__*/React.createElement(StyledLabelGroupContainer, {\n    \"data-overflow\": \"inline\",\n    sx: sxProp\n  }, children);\n};\nLabelGroup.displayName = 'LabelGroup';\n\nexport { LabelGroup as default };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}