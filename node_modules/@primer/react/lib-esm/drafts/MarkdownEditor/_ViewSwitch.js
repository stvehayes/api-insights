import React from 'react';
import Box from '../../Box/Box.js';
import TabNav from '../../TabNav/TabNav.js';

function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
// no point in memoizing this component because onLoadPreview depends on value, so it would still re-render on every change
const ViewSwitch = ({
  selectedView,
  onViewSelect,
  onLoadPreview,
  disabled
}) => {
  // don't get disabled from context - the switch is not disabled when the editor is disabled

  const sharedProps = selectedView === 'preview' ? {
    onClick: () => onViewSelect === null || onViewSelect === void 0 ? void 0 : onViewSelect('edit')
  } : {
    onClick: () => {
      onLoadPreview();
      onViewSelect === null || onViewSelect === void 0 ? void 0 : onViewSelect('preview');
    },
    onMouseOver: () => onLoadPreview(),
    onFocus: () => onLoadPreview()
  };
  return /*#__PURE__*/React.createElement(Box, {
    sx: {
      display: 'flex',
      flexDirection: 'row'
    }
  }, /*#__PURE__*/React.createElement(TabNav, {
    "aria-label": "View mode"
  }, /*#__PURE__*/React.createElement(TabNav.Link, _extends({}, sharedProps, {
    as: "button",
    selected: selectedView === 'edit',
    disabled: disabled,
    sx: {
      cursor: 'pointer',
      color: selectedView === 'edit' ? 'fg.default' : 'fg.muted',
      borderTopLeftRadius: 1
    }
  }), "Write"), /*#__PURE__*/React.createElement(TabNav.Link, _extends({}, sharedProps, {
    as: "button",
    selected: selectedView === 'preview',
    disabled: disabled,
    sx: {
      cursor: 'pointer',
      color: selectedView === 'preview' ? 'fg.default' : 'fg.muted',
      borderTopLeftRadius: 1
    }
  }), "Preview")));
};
ViewSwitch.displayName = "ViewSwitch";

export { ViewSwitch };
