'use strict';

var React = require('react');
var styled = require('styled-components');
var octiconsReact = require('@primer/octicons-react');
var Box = require('../Box/Box.js');
var Tooltip = require('../TooltipV2/Tooltip.js');
var useId = require('../hooks/useId.js');
var useSlots = require('../hooks/useSlots.js');
var sx = require('../sx.js');
var ThemeProvider = require('../ThemeProvider.js');
var defaultSxProp = require('../utils/defaultSxProp.js');
var ActionListContainerContext = require('./ActionListContainerContext.js');
var Description = require('./Description.js');
var Group = require('./Group.js');
var Selection = require('./Selection.js');
var shared = require('./shared.js');
var Visuals = require('./Visuals.js');
var merge = require('deepmerge');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var React__default = /*#__PURE__*/_interopDefault(React);
var styled__default = /*#__PURE__*/_interopDefault(styled);
var merge__default = /*#__PURE__*/_interopDefault(merge);

function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
const LiBox = styled__default.default.li.withConfig({
  displayName: "Item__LiBox",
  componentId: "sc-yeql7o-0"
})(sx.default);
const InactiveIndicator = ({
  labelId,
  text,
  visualComponent: VisualComponent
}) => /*#__PURE__*/React__default.default.createElement(Tooltip.Tooltip, {
  text: text
}, /*#__PURE__*/React__default.default.createElement(Box, {
  as: "button",
  sx: {
    background: 'none',
    color: 'inherit',
    border: 'none',
    padding: 0,
    font: 'inherit',
    cursor: 'pointer',
    display: 'flex'
  },
  "aria-labelledby": labelId
}, /*#__PURE__*/React__default.default.createElement(VisualComponent, null, /*#__PURE__*/React__default.default.createElement(octiconsReact.AlertIcon, null))));
InactiveIndicator.displayName = "InactiveIndicator";
const Item = /*#__PURE__*/React__default.default.forwardRef(({
  variant = 'default',
  disabled = false,
  inactiveText,
  selected = undefined,
  active = false,
  onSelect: onSelectUser,
  sx: sxProp = defaultSxProp.defaultSxProp,
  id,
  role,
  _PrivateItemWrapper,
  ...props
}, forwardedRef) => {
  const [slots, childrenWithoutSlots] = useSlots.useSlots(props.children, {
    leadingVisual: Visuals.LeadingVisual,
    trailingVisual: Visuals.TrailingVisual,
    blockDescription: [Description.Description, props => props.variant === 'block'],
    inlineDescription: [Description.Description, props => props.variant !== 'block']
  });
  const {
    variant: listVariant,
    role: listRole,
    showDividers,
    selectionVariant: listSelectionVariant
  } = React__default.default.useContext(shared.ListContext);
  const {
    selectionVariant: groupSelectionVariant
  } = React__default.default.useContext(Group.GroupContext);
  const {
    container,
    afterSelect,
    selectionAttribute
  } = React__default.default.useContext(ActionListContainerContext.ActionListContainerContext);
  const inactive = Boolean(inactiveText);
  const showInactiveIndicator = inactive && container === undefined;
  const onSelect = React__default.default.useCallback((event, afterSelect) => {
    if (typeof onSelectUser === 'function') onSelectUser(event);
    if (event.defaultPrevented) return;
    if (typeof afterSelect === 'function') afterSelect(event);
  }, [onSelectUser]);
  const selectionVariant = groupSelectionVariant ? groupSelectionVariant : listSelectionVariant;

  /** Infer item role based on the container */
  let inferredItemRole;
  if (container === 'ActionMenu') {
    if (selectionVariant === 'single') inferredItemRole = 'menuitemradio';else if (selectionVariant === 'multiple') inferredItemRole = 'menuitemcheckbox';else inferredItemRole = 'menuitem';
  } else if (container === 'SelectPanel' && listRole === 'listbox') {
    if (selectionVariant !== undefined) inferredItemRole = 'option';
  }
  const itemRole = role || inferredItemRole;

  /** Infer the proper selection attribute based on the item's role */
  let inferredSelectionAttribute;
  if (itemRole === 'menuitemradio' || itemRole === 'menuitemcheckbox') inferredSelectionAttribute = 'aria-checked';else if (itemRole === 'option') inferredSelectionAttribute = 'aria-selected';
  const itemSelectionAttribute = selectionAttribute || inferredSelectionAttribute;
  const {
    theme
  } = ThemeProvider.useTheme();
  const activeStyles = {
    fontWeight: 'bold',
    bg: 'actionListItem.default.selectedBg',
    '&::after': {
      position: 'absolute',
      top: 'calc(50% - 12px)',
      left: -2,
      width: '4px',
      height: '24px',
      content: '""',
      bg: 'accent.fg',
      borderRadius: 2
    }
  };
  const styles = {
    position: 'relative',
    display: 'flex',
    paddingX: 2,
    fontSize: 1,
    paddingY: '6px',
    // custom value off the scale
    lineHeight: shared.TEXT_ROW_HEIGHT,
    minHeight: 5,
    marginX: listVariant === 'inset' ? 2 : 0,
    borderRadius: 2,
    transition: 'background 33.333ms linear',
    color: shared.getVariantStyles(variant, disabled, inactive).color,
    cursor: 'pointer',
    '&[aria-disabled], &[data-inactive]': {
      cursor: 'not-allowed',
      '[data-component="ActionList.Checkbox"]': {
        cursor: 'not-allowed',
        bg: selected ? 'fg.muted' : 'var(--color-input-disabled-bg, rgba(175, 184, 193, 0.2))',
        borderColor: selected ? 'fg.muted' : 'var(--color-input-disabled-bg, rgba(175, 184, 193, 0.2))'
      }
    },
    // Button reset styles (to support as="button")
    appearance: 'none',
    background: 'unset',
    border: 'unset',
    width: listVariant === 'inset' ? 'calc(100% - 16px)' : '100%',
    fontFamily: 'unset',
    textAlign: 'unset',
    marginY: 'unset',
    '@media (hover: hover) and (pointer: fine)': {
      ':hover:not([aria-disabled]):not([data-inactive])': {
        backgroundColor: `actionListItem.${variant}.hoverBg`,
        color: shared.getVariantStyles(variant, disabled, inactive).hoverColor,
        boxShadow: `inset 0 0 0 max(1px, 0.0625rem) ${theme === null || theme === void 0 ? void 0 : theme.colors.actionListItem.default.activeBorder}`
      },
      '&:focus-visible, > a:focus-visible, &:focus.focus-visible': {
        outline: 'none',
        border: `2 solid`,
        boxShadow: `0 0 0 2px ${theme === null || theme === void 0 ? void 0 : theme.colors.accent.emphasis}`
      },
      ':active:not([aria-disabled]):not([data-inactive])': {
        backgroundColor: `actionListItem.${variant}.activeBg`,
        color: shared.getVariantStyles(variant, disabled, inactive).hoverColor
      }
    },
    '@media (forced-colors: active)': {
      ':focus': {
        // Support for Windows high contrast https://sarahmhigley.com/writing/whcm-quick-tips
        outline: 'solid 1px transparent !important'
      }
    },
    /** Divider styles */
    '[data-component="ActionList.Item--DividerContainer"]': {
      position: 'relative'
    },
    '[data-component="ActionList.Item--DividerContainer"]::before': {
      content: '" "',
      display: 'block',
      position: 'absolute',
      width: '100%',
      top: '-7px',
      border: '0 solid',
      borderTopWidth: showDividers ? `1px` : '0',
      borderColor: 'var(--divider-color, transparent)'
    },
    // show between 2 items
    ':not(:first-of-type)': {
      '--divider-color': theme === null || theme === void 0 ? void 0 : theme.colors.actionListItem.inlineDivider
    },
    // hide divider after dividers & group header, with higher importance!
    '[data-component="ActionList.Divider"] + &': {
      '--divider-color': 'transparent !important'
    },
    // hide border on current and previous item
    '&:hover:not([aria-disabled]):not([data-inactive]), &:focus:not([aria-disabled]):not([data-inactive]), &[data-focus-visible-added]:not([aria-disabled]):not([data-inactive])': {
      '--divider-color': 'transparent'
    },
    '&:hover:not([aria-disabled]):not([data-inactive]) + &, &[data-focus-visible-added] + li': {
      '--divider-color': 'transparent'
    },
    ...(active ? activeStyles : {})
  };
  const clickHandler = React__default.default.useCallback(event => {
    if (disabled || inactive) return;
    onSelect(event, afterSelect);
  }, [onSelect, disabled, inactive, afterSelect]);
  const keyPressHandler = React__default.default.useCallback(event => {
    if (disabled || inactive) return;
    if ([' ', 'Enter'].includes(event.key)) {
      if (event.key === ' ') {
        event.preventDefault(); // prevent scrolling on Space
        // immediately reset defaultPrevented once it's job is done
        // so as to not disturb the functions that use that event after this
        event.defaultPrevented = false;
      }
      onSelect(event, afterSelect);
    }
  }, [onSelect, disabled, inactive, afterSelect]);
  const itemId = useId.useId(id);
  const labelId = `${itemId}--label`;
  const inlineDescriptionId = `${itemId}--inline-description`;
  const blockDescriptionId = `${itemId}--block-description`;
  const inactiveWarningId = inactive && !showInactiveIndicator ? `${itemId}--warning-message` : undefined;
  const ItemWrapper = _PrivateItemWrapper || React__default.default.Fragment;

  // only apply aria-selected and aria-checked to selectable items
  const selectableRoles = ['menuitemradio', 'menuitemcheckbox', 'option'];
  const includeSelectionAttribute = itemSelectionAttribute && itemRole && selectableRoles.includes(itemRole);
  const menuItemProps = {
    onClick: clickHandler,
    onKeyPress: keyPressHandler,
    'aria-disabled': disabled ? true : undefined,
    'data-inactive': inactive ? true : undefined,
    tabIndex: disabled || showInactiveIndicator ? undefined : 0,
    'aria-labelledby': `${labelId} ${slots.inlineDescription ? inlineDescriptionId : ''}`,
    'aria-describedby': slots.blockDescription ? [blockDescriptionId, inactiveWarningId].join(' ') : inactiveWarningId,
    ...(includeSelectionAttribute && {
      [itemSelectionAttribute]: selected
    }),
    role: itemRole,
    id: itemId
  };
  const containerProps = _PrivateItemWrapper ? {
    role: itemRole ? 'none' : undefined
  } : menuItemProps;
  const wrapperProps = _PrivateItemWrapper ? menuItemProps : {};
  return /*#__PURE__*/React__default.default.createElement(shared.ItemContext.Provider, {
    value: {
      variant,
      disabled,
      inactive: Boolean(inactiveText),
      inlineDescriptionId,
      blockDescriptionId
    }
  }, /*#__PURE__*/React__default.default.createElement(LiBox, _extends({
    ref: forwardedRef,
    sx: merge__default.default(styles, sxProp),
    "data-variant": variant === 'danger' ? variant : undefined
  }, containerProps, props), /*#__PURE__*/React__default.default.createElement(ItemWrapper, wrapperProps, /*#__PURE__*/React__default.default.createElement(Selection.Selection, {
    selected: selected
  }),
  // If we're showing an inactive indicator and a leading visual has been passed,
  // replace the leading visual with the inactive indicator.
  //
  // Inactive items without a leading visual place the inactive indicator in the
  // trailing visual slot. This preserves the left alignment of item text.
  showInactiveIndicator && slots.leadingVisual ? /*#__PURE__*/React__default.default.createElement(InactiveIndicator, {
    labelId: labelId,
    text: inactiveText,
    visualComponent: Visuals.LeadingVisual
  }) :
  // If it's not inactive, just render the leading visual slot
  slots.leadingVisual, /*#__PURE__*/React__default.default.createElement(Box, {
    "data-component": "ActionList.Item--DividerContainer",
    sx: {
      display: 'flex',
      flexDirection: 'column',
      flexGrow: 1,
      minWidth: 0
    }
  }, /*#__PURE__*/React__default.default.createElement(ConditionalBox, {
    if: Boolean(slots.trailingVisual) || showInactiveIndicator && !slots.leadingVisual,
    sx: {
      display: 'flex',
      flexGrow: 1
    }
  }, /*#__PURE__*/React__default.default.createElement(ConditionalBox, {
    if: !!slots.inlineDescription,
    sx: {
      display: 'flex',
      flexGrow: 1,
      alignItems: 'baseline',
      minWidth: 0
    }
  }, /*#__PURE__*/React__default.default.createElement(Box, {
    as: "span",
    id: labelId,
    sx: {
      flexGrow: slots.inlineDescription ? 0 : 1,
      fontWeight: slots.inlineDescription || slots.blockDescription ? 'bold' : 'normal',
      marginBlockEnd: slots.blockDescription ? '4px' : undefined
    }
  }, childrenWithoutSlots), slots.inlineDescription),
  // If we're showing an inactive indicator and a leading visual has NOT been passed,
  // replace the trailing visual with the inactive indicator.
  //
  // This preserves the left alignment of item text.
  showInactiveIndicator && !slots.leadingVisual ? /*#__PURE__*/React__default.default.createElement(InactiveIndicator, {
    labelId: labelId,
    text: inactiveText,
    visualComponent: Visuals.TrailingVisual
  }) :
  // If it's not inactive, or it has a leading visual that can be replaced,
  // just render the trailing visual slot.
  slots.trailingVisual),
  // If the item is inactive, but it's not in an overlay (e.g. ActionMenu, SelectPanel),
  // render the inactive warning message directly in the item.
  inactive && container ? /*#__PURE__*/React__default.default.createElement(Box, {
    as: "span",
    sx: {
      fontSize: 0,
      lineHeight: '16px',
      color: 'attention.fg'
    },
    id: inactiveWarningId
  }, inactiveText) : null, slots.blockDescription))));
});
Item.displayName = 'ActionList.Item';
const ConditionalBox = props => {
  const {
    if: condition,
    ...rest
  } = props;
  if (condition) return /*#__PURE__*/React__default.default.createElement(Box, rest, props.children);else return /*#__PURE__*/React__default.default.createElement(React__default.default.Fragment, null, props.children);
};

exports.Item = Item;
