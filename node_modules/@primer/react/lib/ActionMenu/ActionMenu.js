'use strict';

var React = require('react');
var octiconsReact = require('@primer/octicons-react');
var AnchoredOverlay = require('../AnchoredOverlay/AnchoredOverlay.js');
var useProvidedRefOrCreate = require('../hooks/useProvidedRefOrCreate.js');
require('@primer/behaviors/utils');
require('@primer/behaviors');
var useProvidedStateOrCreate = require('../hooks/useProvidedStateOrCreate.js');
var useMenuKeyboardNavigation = require('../hooks/useMenuKeyboardNavigation.js');
var useId = require('../hooks/useId.js');
var Divider = require('../ActionList/Divider.js');
var ActionListContainerContext = require('../ActionList/ActionListContainerContext.js');
require('../Box/Box.js');
require('@styled-system/css');
require('deepmerge');
require('../ThemeProvider.js');
require('../Button/types.js');
require('../utils/defaultSxProp.js');
require('../CounterLabel/CounterLabel.js');
var Button = require('../Button/Button.js');
var Tooltip = require('../TooltipV2/Tooltip.js');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var React__default = /*#__PURE__*/_interopDefault(React);

function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
const MenuContext = /*#__PURE__*/React__default.default.createContext({
  renderAnchor: null,
  open: false
});
const Menu = ({
  anchorRef: externalAnchorRef,
  open,
  onOpenChange,
  children
}) => {
  const [combinedOpenState, setCombinedOpenState] = useProvidedStateOrCreate.useProvidedStateOrCreate(open, onOpenChange, false);
  const onOpen = React__default.default.useCallback(() => setCombinedOpenState(true), [setCombinedOpenState]);
  const onClose = React__default.default.useCallback(() => setCombinedOpenState(false), [setCombinedOpenState]);
  const menuButtonChild = React__default.default.Children.toArray(children).find(child => /*#__PURE__*/React__default.default.isValidElement(child) && (child.type === MenuButton || child.type === Anchor));
  const menuButtonChildId = /*#__PURE__*/React__default.default.isValidElement(menuButtonChild) ? menuButtonChild.props.id : undefined;
  const anchorRef = useProvidedRefOrCreate.useProvidedRefOrCreate(externalAnchorRef);
  const anchorId = useId.useId(menuButtonChildId);
  let renderAnchor = null;
  // 🚨 Hack for good API!
  // we strip out Anchor from children and pass it to AnchoredOverlay to render
  // with additional props for accessibility
  // 🚨 Accounting for Tooltip wrapping ActionMenu.Button or being a direct child of ActionMenu.Anchor.
  const contents = React__default.default.Children.map(children, child => {
    // Is ActionMenu.Button wrapped with Tooltip? If this is the case, our anchor is the tooltip's trigger (ActionMenu.Button's grandchild)
    if (child.type === Tooltip.Tooltip) {
      // tooltip trigger
      const anchorChildren = child.props.children;
      if (anchorChildren.type === MenuButton) {
        renderAnchor = anchorProps => {
          // We need to attach the anchor props to the tooltip trigger (ActionMenu.Button's grandchild) not the tooltip itself.
          const triggerButton = /*#__PURE__*/React__default.default.cloneElement(anchorChildren, {
            ...anchorProps
          });
          return /*#__PURE__*/React__default.default.cloneElement(child, {
            children: triggerButton,
            ref: anchorRef
          });
        };
      }
      return null;
    } else if (child.type === Anchor) {
      const anchorChildren = child.props.children;
      const isWrappedWithTooltip = anchorChildren !== undefined ? anchorChildren.type === Tooltip.Tooltip : false;
      if (isWrappedWithTooltip) {
        if (anchorChildren.props.children !== null) {
          renderAnchor = anchorProps => {
            // ActionMenu.Anchor's children can be wrapped with Tooltip. If this is the case, our anchor is the tooltip's trigger
            const tooltipTrigger = anchorChildren.props.children;
            // We need to attach the anchor props to the tooltip trigger not the tooltip itself.
            const tooltipTriggerEl = /*#__PURE__*/React__default.default.cloneElement(tooltipTrigger, {
              ...anchorProps
            });
            const tooltip = /*#__PURE__*/React__default.default.cloneElement(anchorChildren, {
              children: tooltipTriggerEl
            });
            return /*#__PURE__*/React__default.default.cloneElement(child, {
              children: tooltip,
              ref: anchorRef
            });
          };
        }
      } else {
        renderAnchor = anchorProps => /*#__PURE__*/React__default.default.cloneElement(child, anchorProps);
      }
      return null;
    } else if (child.type === MenuButton) {
      renderAnchor = anchorProps => /*#__PURE__*/React__default.default.cloneElement(child, anchorProps);
      return null;
    } else {
      return child;
    }
  });
  return /*#__PURE__*/React__default.default.createElement(MenuContext.Provider, {
    value: {
      anchorRef,
      renderAnchor,
      anchorId,
      open: combinedOpenState,
      onOpen,
      onClose
    }
  }, contents);
};
Menu.displayName = "Menu";
const Anchor = /*#__PURE__*/React__default.default.forwardRef(({
  children,
  ...anchorProps
}, anchorRef) => {
  return /*#__PURE__*/React__default.default.cloneElement(children, {
    ...anchorProps,
    ref: anchorRef
  });
});

/** this component is syntactical sugar 🍭 */

const MenuButton = /*#__PURE__*/React__default.default.forwardRef(({
  ...props
}, anchorRef) => {
  return /*#__PURE__*/React__default.default.createElement(Anchor, {
    ref: anchorRef
  }, /*#__PURE__*/React__default.default.createElement(Button.ButtonComponent, _extends({
    type: "button",
    trailingAction: octiconsReact.TriangleDownIcon
  }, props)));
});
const Overlay = ({
  children,
  align = 'start',
  side = 'outside-bottom',
  'aria-labelledby': ariaLabelledby,
  ...overlayProps
}) => {
  // we typecast anchorRef as required instead of optional
  // because we know that we're setting it in context in Menu
  const {
    anchorRef,
    renderAnchor,
    anchorId,
    open,
    onOpen,
    onClose
  } = React__default.default.useContext(MenuContext);
  const containerRef = React__default.default.useRef(null);
  useMenuKeyboardNavigation.useMenuKeyboardNavigation(open, onClose, containerRef, anchorRef);
  return /*#__PURE__*/React__default.default.createElement(AnchoredOverlay.AnchoredOverlay, {
    anchorRef: anchorRef,
    renderAnchor: renderAnchor,
    anchorId: anchorId,
    open: open,
    onOpen: onOpen,
    onClose: onClose,
    align: align,
    side: side,
    overlayProps: overlayProps,
    focusZoneSettings: {
      focusOutBehavior: 'wrap'
    }
  }, /*#__PURE__*/React__default.default.createElement("div", {
    ref: containerRef
  }, /*#__PURE__*/React__default.default.createElement(ActionListContainerContext.ActionListContainerContext.Provider, {
    value: {
      container: 'ActionMenu',
      listRole: 'menu',
      listLabelledBy: ariaLabelledby || anchorId,
      selectionAttribute: 'aria-checked',
      // Should this be here?
      afterSelect: onClose
    }
  }, children)));
};
Overlay.displayName = "Overlay";
Menu.displayName = 'ActionMenu';
const ActionMenu = Object.assign(Menu, {
  Button: MenuButton,
  Anchor,
  Overlay,
  Divider: Divider.Divider
});

exports.ActionMenu = ActionMenu;
